/*
 * NodeGuard
 * Copyright (C) 2023  Elenpay
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 */

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using FluentAssertions;
using NBitcoin;
using NBitcoin.RPC;
using NBXplorer;

namespace FundsManager.Tests
{
    public class Pentests
    {
        /// <summary>
        /// This takes a Fully signed & finalised PSBT from the FM and modifies it to prove that it is tamperproof when trying to broadcast to the mempool
        /// </summary>
        [Fact]
        public void PSBTTampering()
        {
            //Arrange

            //PSBT Signed from the FM ready to fund a channel -> Needs to be prepared on the FM and pasted here
            var base64 =
                "cHNidP8BAIkBAAAAAUFykXqYj2CWfqlnjsJaU8qw9TVrQHsHs7JZB22DbvlNAAAAAAD/////AsjyNHcAAAAAIgAgg+aofANl6wKKByTgFl5yBnqUK8f7sn4ULhAAIJb1C0cgTgAAAAAAACIAIJytsPi6zmP7rIqJRBy1XYhpzkknKv+T+eeqcv34/O8tAAAAAAABAStkQzV3AAAAACIAILjSyDaZFf/yCBXdbYtooNefupjzoTVspFdJsLJ3jvRXAQcAAQj8BABHMEQCIG0B6+42defE99fhS+UjnG0Ukfhkb+yQzv8Ihw3M6ppsAiBofgokXBD0AyydPhulT38Y+SRhFDX996T/Zr0+kYvsDAJHMEQCIA/5xh2DYpjPVJd3q43kLEenbMN3Ju6jRMOO4Rk/onrMAiBl8eo9+NBOJEYHgoQwZSfcxq720OazcXfQwzzIqqUGGgFpUiEDJ0KjWjE9mM+OzBPgqobBDCvXwdbEERr2wUJD2ruduAYhA4E0C5IanGt26wU7pzZoyLG+FhLBa8k8HdwR/2T0uCpKIQPdbg/RGEZcyAU+sjVNkti/8LzgNP3puKHGjP/73jrTdlOuAAAA";

            var psbt = PSBT.Parse(base64, Network.RegTest);

            //Act
            var transaction = psbt.ExtractTransaction();

            var beforeTamper = transaction.ToHex();

            transaction.Outputs.First().Value = transaction.Outputs.First().Value - new Money(100, MoneyUnit.Satoshi);

            transaction.Check();

            var afterTamper = transaction.ToHex();

            beforeTamper.Should().NotBeEquivalentTo(afterTamper);

            //Assert

            //This test requires polar or a bitcoind setup!!

            var minerRPC = new RPCClient(new NetworkCredential("polaruser", "polarpass"), new Uri("http://host.docker.internal:18443/"),
                Network.RegTest);

            var nontamperedMempoolResult = minerRPC.TestMempoolAccept(psbt.ExtractTransaction());
            nontamperedMempoolResult.IsAllowed.Should().BeTrue();

            var tamperMempoolResult = minerRPC.TestMempoolAccept(transaction);
            tamperMempoolResult.IsAllowed.Should().BeFalse();
            tamperMempoolResult.RejectReason.Should()
                .Be("non-mandatory-script-verify-flag (Signature must be zero for failed CHECK(MULTI)SIG operation)");
        }

        /// <summary>
        /// This takes a transaction broadcasted to the MEMPOOL (i.e Channel funding) and tries to re-broadcast it with some changes
        /// </summary>
        [Fact]
        public void PSBTStealing()
        {
            //Arrange

            //Raw tx stolen from the mempool
            var rawTX =
                "010000000001010b4baa28c76838e1afb5b0e67004e6b90da04543a2792a485039492be555806a0000000000ffffffff026490f5050000000022002083e6a87c0365eb028a0724e0165e72067a942bc7fbb27e142e10002096f50b47204e000000000000220020998944d310ce4109a2da44d96b9052bf5ea6450430a269f840756b9d46f3d2dc040047304402205eba99f741754bf00f9be149866d01ce8e360eefd715a99f091bb6f39003bd4a0220468872187c59c9f230c699e74cf17c13a29f19e16a0f2d0268d5940f022414e40247304402200bfc313a3374cc6afeccc34e09b7e4513b43923902d824d5512aae2b402e011702206cf91f6ed1664580a38c98928d28fba8f285a4480251c8de039cf40396d8279f01695221020ee3618171c0ea2bea36b00c33226b36eb63b3173c70c3637bdbccb475ecccc5210308432c8c572a2feaa7ac586ec6b3588ffd29abf9de0d7aafeecac4a37f07916e2103cc3736e3afc5ab1ead3ff24b906e9d999a03b0b52430ddb59e9c8700239b108053ae00000000";

            //Act
            var transaction = Transaction.Parse(rawTX, Network.RegTest);

            var beforeTamperTx = transaction;
            var beforeTamper = transaction.ToHex();

            transaction.Outputs.First().Value = transaction.Outputs.First().Value - new Money(100, MoneyUnit.Satoshi);

            transaction.Check();

            var afterTamper = transaction.ToHex();

            beforeTamper.Should().NotBeEquivalentTo(afterTamper);

            //Assert

            //This test requires polar or a bitcoind setup!!

            var minerRPC = new RPCClient(new NetworkCredential("polaruser", "polarpass"), new Uri("http://host.docker.internal:18443/"),
                Network.RegTest);

            var nontamperedMempoolResult = minerRPC.TestMempoolAccept(beforeTamperTx);
            nontamperedMempoolResult.IsAllowed.Should().BeFalse();
            nontamperedMempoolResult.RejectReason.Should().Be("txn-mempool-conflict");

            var tamperMempoolResult = minerRPC.TestMempoolAccept(transaction);
            tamperMempoolResult.IsAllowed.Should().BeFalse();
            tamperMempoolResult.RejectReason.Should().Be("txn-mempool-conflict");
        }
    }
}