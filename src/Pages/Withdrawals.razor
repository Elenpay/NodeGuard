@page "/withdrawals"
@using System.Security.Claims
@using Blazorise.Extensions
@using Quartz
@using Humanizer
@using NBitcoin
@using NodeGuard.Jobs
@using Google.Protobuf
@using NBXplorer.Models
@using NodeGuard.Helpers;
@using Polly
@attribute [Authorize(Roles = "Superadmin,NodeManager,FinanceManager")]

<Row>
    @if (_isFinanceManager)
    {
        <Column ColumnSize="ColumnSize.Is12">
            <h3>Withdrawal requests awaiting my signature</h3>
            <DataGrid TItem="WalletWithdrawalRequest"
                  Data="@_userPendingRequests"
                  Editable="@_isFinanceManager"
                  EditMode="DataGridEditMode.Popup"
                  Responsive="true"
                  ResizeMode="TableResizeMode.Columns"
                  UseInternalEditing="true"
                  RowInserted="OnRowInserted"
                  RowRemoving="OnRowRemoving"
                  RowUpdated="OnRowUpdated"
                  NewItemDefaultSetter="NewItemDefaultSetter"
                  ShowPager="true"
                  ShowPageSizes="true"
                  PageSize="25"
                  Narrow="true"
                  Filterable="true"
                  ShowValidationFeedback="true"
                  ShowValidationsSummary="false"
                  UseValidation="true">
                <PopupTitleTemplate>
                    <h2>@(context.EditState) withdrawal</h2>
                </PopupTitleTemplate>
                <DataGridColumns>
                    <DataGridCommandColumn TItem="WalletWithdrawalRequest" Filterable="false" >
                        <NewCommandTemplate>
                            <Button Color="Color.Success" TextColor="TextColor.Light"  Clicked="@(async () => {  OnShowNewWalletWithdrawalModal(); await context.Clicked.InvokeAsync(); })">New</Button>
                        </NewCommandTemplate>
                        <EditCommandTemplate>
                            @*<Button Color="Color.Primary" Clicked="@context.Clicked">Edit</Button>*@

                        </EditCommandTemplate>
                        <DeleteCommandTemplate>
                            @*<Button Color="Color.Danger" Clicked="@context.Clicked">Delete</Button>*@
                        </DeleteCommandTemplate>

                    </DataGridCommandColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true" />
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="Actions" Sortable="false" Displayable="true">
                        <DisplayTemplate>
                            @*TODO Cancel / Reject  *@

                            @if (context.Wallet != null && context.Wallet.Keys != null && context.Wallet.Keys.Any(x => x.UserId == LoggedUser?.Id)
                                 && !context.AreAllRequiredHumanSignaturesCollected
                                 && context.WalletWithdrawalRequestPSBTs.All(x => x.SignerId != LoggedUser?.Id))
                            {
                                <Button Color="Color.Success" Clicked="()=> ShowApprovalModal(context)">Approve</Button>
                            }
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="" Sortable="false" Displayable="true">
                        <DisplayTemplate>
                            @*TODO Cancel / Reject  *@
                            @if ((context.Status == WalletWithdrawalRequestStatus.Pending || context.Status == WalletWithdrawalRequestStatus.PSBTSignaturesPending) && LoggedUser?.Id == context.UserRequestorId)

                            {
                                <Button Color="Color.Danger" Clicked="()=> ShowRejectCancelModal(context, WalletWithdrawalRequestStatus.Cancelled)">Cancel</Button>
                            }
                            else if ((context.Status == WalletWithdrawalRequestStatus.Pending || context.Status == WalletWithdrawalRequestStatus.PSBTSignaturesPending)
                                     && LoggedUser?.Id != context.UserRequestorId)
                            {
                                <Button Color="Color.Danger" Clicked="()=> ShowRejectCancelModal(context, WalletWithdrawalRequestStatus.Rejected)">Reject</Button>
                            }
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Description)">
                        <DisplayTemplate>
                            <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                                @context.Description.Truncate(40)
                            </Tooltip>
                        </DisplayTemplate>
                        <EditTemplate>
                            <Validation Validator="@ValidationRule.IsNotEmpty">
                                <MemoEdit Rows="4" Text="@((string) context.CellValue)" TextChanged="(text) => context.CellValue = text">
                                    <Feedback>
                                        <ValidationError/>
                                    </Feedback>
                                </MemoEdit>
                            </Validation>
                        </EditTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Validator="@ValidationRule.IsSelected" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Wallet)">
                        <DisplayTemplate>
                            @if (context.Wallet != null)
                            {
                                @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                            }
                        </DisplayTemplate>
                        <EditTemplate>
                            <Validation Validator="@ValidationRule.IsSelected">
                            @if (context.CellValue == null || (int) context.CellValue == 0)
                            {
                                <SelectList TItem="Wallet"
                                            TValue="int"
                                            Data="@_availableWallets"
                                            TextField="@((item) => item.Name)"
                                            ValueField="@((item) => item.Id)"
                                            SelectedValueChanged="(id) => OnSelectedWallet(context,id)"
                                            DefaultItemText="Choose the wallet">
                                    <Feedback>
                                        <ValidationError/>
                                    </Feedback>
                                </SelectList>
                            }
                            else
                            {
                                <SelectList TItem="Wallet"
                                            TValue="int"
                                            Data="@_availableWallets"
                                            TextField="@((item) => item.Name)"
                                            ValueField="@((item) => item.Id)"
                                            SelectedValue="(int) context.CellValue"
                                            SelectedValueChanged="(id) => OnSelectedWallet(context,id)">
                                    <Feedback>
                                        <ValidationError/>
                                    </Feedback>
                                </SelectList>
                            }
                            </Validation>
                        </EditTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Editable="false" Field="@nameof(WalletWithdrawalRequest.UserRequestor)" Caption="Requestor" Sortable="true" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Requestor)">
                        <DisplayTemplate>
                            @context?.UserRequestor?.UserName
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.DestinationAddress)" Caption="@nameof(WalletWithdrawalRequest.DestinationAddress).Humanize()" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.DestinationAddress)">
                        <DisplayTemplate>
                            @StringHelper.TruncateHeadAndTail(context.DestinationAddress,10)
                            @* TODO Copy and explorer buttons *@
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is6" Field="@nameof(WalletWithdrawalRequest.WithdrawAllFunds)" Caption="@nameof(WalletWithdrawalRequest.WithdrawAllFunds).Humanize(LetterCasing.Sentence)" Editable="true" Displayable="false">
                        <EditTemplate>
                            <Check TValue="bool" Checked="@((bool) context.CellValue)" CheckedChanged="(value) => HandleCheckboxChange(context, value)"  @bind-Value="IsCheckedAllFunds"/>
                        </EditTemplate>
                    </DataGridColumn>
                    <DataGridColumn PopupFieldColumnSize="ColumnSize.Is6" Caption="Wallet Balance" Editable="true" Displayable="false">
                        <EditTemplate>
                            @if (_selectedRequestWalletBalance != null)
                            {
                                <p>@($"{_selectedRequestWalletBalance:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal)_selectedRequestWalletBalance, _btcPrice), 2)} USD)")</p>
                            }
                        </EditTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Amount)" Caption="Amount" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Amount)" >
                        <DisplayTemplate>
                            @{
                                @($"{context.Amount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                            }
                        </DisplayTemplate>
                        <EditTemplate>
                            <Validation Validator="args => ValidationHelper.ValidateWithdrawalAmount(args, _selectedRequestWalletBalance)">
                                <NumericPicker TValue="decimal" @bind-Value="@_amount" Step="0.00001m" CurrencySymbol="₿ " Decimals="8" DecimalSeparator="," Disabled="@(SelectedUTXOs.Count > 0 || IsCheckedAllFunds)">
                                    <Feedback>
                                        <ValidationError/>
                                    </Feedback>
                                </NumericPicker>
                                <FieldHelp>
                                    @{
                                        decimal amountToShow = _amount < Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT
                                            ? _amount
                                            : Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT;
                                        decimal convertedAmount = Math.Round(PriceConversionService.SatToUsdConversion(new Money(amountToShow, MoneyUnit.BTC).Satoshi, _btcPrice), 2);
                                    }
                                    @($"Minimum {_minimumWithdrawalAmount:f8} BTC. Current amount: {convertedAmount} USD")
                                </FieldHelp>
                            </Validation>
                            <div class="mb-3">
                                <Button Color="Color.Primary" Disabled="@(!_selectedWalletId.HasValue || IsCheckedAllFunds)" Clicked="@OpenCoinSelectionModal">Select Coins</Button> or use
                                <Button Color="Color.Primary" Disabled="@(SelectedUTXOs.Count == 0)" Clicked="@ClearSelectedUTXOs">Default Coin Selection</Button>
                            </div>
                            @if (_selectedWalletId.HasValue && SelectedUTXOs.Count > 0)
                            {
                                <span class="text-danger">Selected @(SelectedUTXOs.Count) UTXOs, this is a changeless operation</span>
                            }
                            else
                            {
                                <span class="text-danger">Default coin selection strategy selected</span>
                            }
                        </EditTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.SignaturesCollected)">
                        <DisplayTemplate>
                            @{
                                if (context.Wallet != null)
                                {
                                    var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                                    var signaturesRequired = context.Wallet?.MofN ?? 0;
                                        @($"{signaturesCollected} out of {signaturesRequired}")
                                }

                            }
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Status).Humanize(LetterCasing.Sentence)" Caption="Status" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Status)">
                        <DisplayTemplate>
                            @context?.Status.Humanize()
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.CreationDate)">
                        <DisplayTemplate>
                            @context.CreationDatetime.Humanize()
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.UpdateDate)">
                        <DisplayTemplate>
                            @context.UpdateDatetime.Humanize()
                        </DisplayTemplate>
                    </DataGridColumn>
                    <DataGridColumn TItem="WalletWithdrawalRequest" Displayable="true">
                        <FilterTemplate>
                            <ColumnLayout @ref="PendingRequestsColumnLayout" Columns="@_pendingRequestsColumns" ColumnType="PendingWithdrawalsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                        </FilterTemplate>
                    </DataGridColumn>
                </DataGridColumns>

                <EmptyTemplate>
                    <div class="box">
                        No records were found.
                    </div>
                </EmptyTemplate>
                <LoadingTemplate>
                    <div class="box">
                        <progress class="progress is-small is-primary" max="100"></progress>
                    </div>
                </LoadingTemplate>
            </DataGrid>

        </Column>
    }

    <Column ColumnSize="ColumnSize.Is12">
        <h3>Withdrawal requests</h3>
        <DataGrid TItem="WalletWithdrawalRequest"
                  @ref="_allRequestsDatagrid"
                  Data="@_withdrawalRequests"
                  Filterable="true"
                  FilterMethod="DataGridFilterMethod.Contains"
                  Editable="false"
                  Responsive="true"
                  ResizeMode="TableResizeMode.Columns"
                  ShowPager="true"
                  ShowPageSizes="true"
                  Narrow="true"
                  PageSize="25">
            <DataGridColumns>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true" />
                <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Description)">
                    <DisplayTemplate>
                        <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                            @context.Description.Truncate(40)
                        </Tooltip>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Wallet)">
                    <DisplayTemplate>
                        @if (context.Wallet != null)
                        {
                            @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                        }
                    </DisplayTemplate>
                    <EditTemplate>
                        @if (context.CellValue == null || (int)context.CellValue == 0)
                        {
                            <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValueChanged="(id) => context.CellValue = id"
                                    DefaultItemText="Choose the wallet" />
                        }
                        else
                        {
                            <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValue="(int) context.CellValue"
                                    SelectedValueChanged="(id) => context.CellValue = id" />
                        }
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.UserRequestor)" Caption="Requestor" Sortable="true" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Requestor)">
                    <DisplayTemplate>
                        @context?.UserRequestor?.UserName
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.DestinationAddress)" Caption="@nameof(WalletWithdrawalRequest.DestinationAddress).Humanize()" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.DestinationAddress)">
                    <DisplayTemplate>
                        @StringHelper.TruncateHeadAndTail(context.DestinationAddress,10)
                        @* TODO Copy and explorer buttons *@
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true"  Field="@nameof(WalletWithdrawalRequest.Amount)" Caption="Amount (BTC)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Amount)">
                    <DisplayTemplate>
                        @{
                            @($"{context.Amount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                        }
                    </DisplayTemplate>

                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.SignaturesCollected)">
                    <DisplayTemplate>
                        @{
                            if (context.Wallet != null)
                            {
                                var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                                var signaturesRequired = context.Wallet?.MofN ?? 0;
                                    @($"{signaturesCollected} out of {signaturesRequired}")
                            }
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Status).Humanize(LetterCasing.Sentence)" Caption="Status" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Status)">
                    <DisplayTemplate>
                        <Tooltip Text=@context.RejectCancelDescription Placement="TooltipPlacement.Top">
                                <span>@context?.Status.Humanize()</span>
                        </Tooltip>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.CreationDate)">
                    <DisplayTemplate>
                        @context.CreationDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.UpdateDate)">
                    <DisplayTemplate>
                        @context.UpdateDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.TxId)" Caption="Links" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Links)">
                    <DisplayTemplate>
                        @if (mempoolUrl != null && !string.IsNullOrEmpty(context.TxId))
                        {
                            <a href="@(mempoolUrl + "/tx/" + context.TxId)" target="_blank">See in explorer</a>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="WalletWithdrawalRequest" Displayable="true">
                    <FilterTemplate>
                        <ColumnLayout @ref="AllRequestsColumnLayout" Columns="@_allRequestsColumns" ColumnType="AllWithdrawalsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                    </FilterTemplate>
                </DataGridColumn>
            </DataGridColumns>
            <EmptyTemplate>
                <div class="box">
                    No records were found.
                </div>
            </EmptyTemplate>
            <LoadingTemplate>
                <div class="box">
                    <progress class="progress is-small is-primary" max="100"></progress>
                </div>
            </LoadingTemplate>
        </DataGrid>

    </Column>

</Row>

<PSBTSign
    @ref="_psbtSignRef"
    SignedPSBT="@_signedPSBT"
    WithdrawalRequest="_selectedRequest"
    SigHashMode="SigHash.All"
    TemplatePsbtString="@_templatePsbtString"
    ApproveRequestDelegate="async ()=> await ApproveRequestDelegate()"
/>

<CancelOrRejectPopup
    @ref="@_rejectCancelModalRef"
    Title='@("Wallet withdrawal:"+_selectedRequest?.Id)'
    Validator="@RejectReasonValidator"
    OnCancel="@HideRejectCancelModal"
    OnSubmit="@RejectOrCancel"
/>

<ConfirmationModal
    @ref="_confirmationModal"
    Title="Are you sure?"
    Body="You selected a hot wallet. This means that the system will automatically use the funds in it without the need of manual approval. Are you sure you want to perform this operation?"
    OkLabel="Yes, I am sure"
    OnCancel="@CloseConfirmationModal"
    OnSubmit="@SubmitConfirmationModal"
/>

<UTXOSelectorModal
    @ref="_utxoSelectorModalRef"
    OnClose="@OnCloseCoinSelectionModal"
    IsWalletWithdrawalValidation="false"/>

@inject IToastService ToastService
@inject IWalletWithdrawalRequestRepository WalletWithdrawalRequestRepository
@inject IWalletWithdrawalRequestPsbtRepository WalletWithdrawalRequestPsbtRepository
@inject IWalletRepository WalletRepository
@inject IBitcoinService BitcoinService
@inject ICoinSelectionService CoinSelectionService
@inject ISchedulerFactory SchedulerFactory
@inject ILocalStorageService LocalStorageService
@inject IPriceConversionService PriceConversionService

@code {
    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }


    [CascadingParameter]
    private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private ColumnLayout<PendingWithdrawalsColumnName> PendingRequestsColumnLayout;
    private List<WalletWithdrawalRequest> _userPendingRequests = new();
    private List<Wallet> _availableWallets = new();
    private List<WalletWithdrawalRequest> _withdrawalRequests = new();
    private string? mempoolUrl = Constants.MEMPOOL_ENDPOINT;
    private bool _isFinanceManager;
    private List<UTXO> SelectedUTXOs = new();
    private WalletWithdrawalRequest? _selectedRequest;
    private PSBTSign? _psbtSignRef;
    private string _signedPSBT;
    private string? _templatePsbtString;
    private int? _selectedWalletId;
    private static readonly decimal _minimumWithdrawalAmount = Constants.MINIMUM_WITHDRAWAL_BTC_AMOUNT;
    private decimal _amount { get; set; } = _minimumWithdrawalAmount;
    //Validation
    private DataGrid<WalletWithdrawalRequest>? _allRequestsDatagrid;
    private UTXOSelectorModal _utxoSelectorModalRef;
    private ConfirmationModal _confirmationModal;
    private CancelOrRejectPopup? _rejectCancelModalRef;
    private bool _isNodeManager = false;
    private WalletWithdrawalRequestStatus? _rejectCancelStatus = WalletWithdrawalRequestStatus.Rejected;
    private decimal? _selectedRequestWalletBalance;
    private decimal _btcPrice;
    private ColumnLayout<AllWithdrawalsColumnName> AllRequestsColumnLayout;
    private Dictionary<string, bool> _pendingRequestsColumns = new();
    private Dictionary<string, bool> _allRequestsColumns = new();
    private bool _columnsLoaded;
    public bool IsCheckedAllFunds;

    public abstract class PendingWithdrawalsColumnName
    {
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault Wallet = new("Wallet");
        public static readonly ColumnDefault Requestor = new("Requestor");
        public static readonly ColumnDefault DestinationAddress = new("Destination Address");
        public static readonly ColumnDefault Amount = new("Amount (BTC)");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
    }

    public abstract class AllWithdrawalsColumnName
    {
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault Wallet = new("Wallet");
        public static readonly ColumnDefault Requestor = new("Requestor");
        public static readonly ColumnDefault DestinationAddress = new("Destination Address");
        public static readonly ColumnDefault Amount = new("Amount (BTC)");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
        public static readonly ColumnDefault Links = new("Links");
    }

    protected override async Task OnInitializedAsync()
    {
        if (LoggedUser == null) return;

        _btcPrice = await PriceConversionService.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }

        _isFinanceManager = ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString());
        await GetData();
        await LoadColumnLayout();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !_columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private decimal SelectedUTXOsValue()
    {
        return SelectedUTXOs.Sum(x => ((Money)x.Value).ToUnit(MoneyUnit.BTC));
    }

    private async Task LoadColumnLayout()
    {
        _allRequestsColumns = await LocalStorageService.LoadStorage(nameof(AllWithdrawalsColumnName), ColumnHelpers.GetColumnsDictionary<AllWithdrawalsColumnName>());
        _pendingRequestsColumns = await LocalStorageService.LoadStorage(nameof(PendingWithdrawalsColumnName), ColumnHelpers.GetColumnsDictionary<PendingWithdrawalsColumnName>());
        _columnsLoaded = true;
        StateHasChanged();
    }

    private async Task GetData()
    {
        if (LoggedUser?.Id != null)
            _userPendingRequests = await WalletWithdrawalRequestRepository.GetUnsignedPendingRequestsByUser(LoggedUser.Id);

        _withdrawalRequests = (await WalletWithdrawalRequestRepository.GetAll()).Except(_userPendingRequests).ToList();

        _availableWallets = await WalletRepository.GetAvailableWallets(false);
        //TODO Fix BIP39 withdrawals, until then, manual hack to filter them out
        _availableWallets = _availableWallets.Where(x => !x.IsBIP39Imported).ToList();

    }

    private void OnCloseCoinSelectionModal(List<UTXO> selectedUTXOs)
    {
        SelectedUTXOs = selectedUTXOs;
        if (SelectedUTXOs.Count > 0)
        {
            _amount = SelectedUTXOsValue();
        }
        StateHasChanged();
    }

    private async Task OnRowInserted(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;
        var amount = SelectedUTXOs.Count > 0 ? SelectedUTXOsValue() : _amount;
        arg.Item.Wallet = await WalletRepository.GetById(arg.Item.WalletId);
        arg.Item.Amount = amount;
        arg.Item.Changeless = SelectedUTXOs.Count > 0;
        arg.Item.WithdrawAllFunds = IsCheckedAllFunds || _amount == _selectedRequestWalletBalance;
        if (arg.Item.Wallet.IsHotWallet)
        {
            await GetData();
            _selectedRequest = arg.Item;
            await _confirmationModal.ShowModal();
            return;
        }

        arg.Item.Wallet = null;
        var addResult = await WalletWithdrawalRequestRepository.AddAsync(arg.Item);


        if (addResult.Item1)
        {
            ToastService.ShowSuccess("Success");
            await GetData();

            if (SelectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(SelectedUTXOs, arg.Item, BitcoinRequestType.WalletWithdrawal);
            }

            _utxoSelectorModalRef.ClearModal();
        }
        else
        {
            ToastService.ShowError("Something went wrong");
            _userPendingRequests.Remove(arg.Item);

        }

    }

    private void HandleCheckboxChange(CellEditContext<WalletWithdrawalRequest> context, bool value)
    {
        context.CellValue = value;
        IsCheckedAllFunds = value;
        if (IsCheckedAllFunds)
        {
            ClearSelectedUTXOs();
            _amount = _selectedRequestWalletBalance ?? _minimumWithdrawalAmount;
        }
    }

    private async Task OnRowRemoving(CancellableRowChange<WalletWithdrawalRequest> arg)
    {
        if (arg.Item != null)
        {

            var (result, _) = WalletWithdrawalRequestRepository.Remove(arg.Item);

            if (!result)
            {
                arg.Cancel = true;
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess("Success");
                await GetData();
            }
        }
    }

    private async Task OnRowUpdated(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {

        if (arg.Item == null) return;
        // Validate balance

        if (await ValidateBalance(arg)) return;

        var updateResult = WalletWithdrawalRequestRepository.Update(arg.Item);


        if (updateResult.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Something went wrong");
        }

        await GetData();
    }

    private async Task<bool> ValidateBalance(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        var wallet = await WalletRepository.GetById(arg.Item.WalletId);

        if (wallet != null)
        {
            var balance = await BitcoinService.GetWalletConfirmedBalance(wallet);

            if (arg.Item.Amount > balance.Item1)
            {
                ToastService.ShowError(
                    $"The confirmed balance({balance.Item1:f8} BTC) for the selected wallet is less than the amount requested to withdraw ({arg.Item.Amount:f8} BTC)");
                await GetData();
                return true;
            }
        }

        return false;
    }

    private void DestinationAddressValidator(ValidatorEventArgs obj)
    {
        var str = obj.Value as string;

        obj.Status = ValidationStatus.Success;

        try
        {
            BitcoinAddress.Create(str!, CurrentNetworkHelper.GetCurrentNetwork());
        }
        catch (Exception)
        {
            obj.ErrorText = "Invalid bitcoin address";
            obj.Status = ValidationStatus.Error;

        }
    }

    private void NewItemDefaultSetter(WalletWithdrawalRequest obj)
    {
        if (LoggedUser != null)
        {
            obj.UserRequestorId = LoggedUser.Id;
            _selectedRequestWalletBalance = null;
        }
    }

    private async Task ShowApprovalModal(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        _selectedRequest = walletWithdrawalRequest;

        //PSBT Generation
        try
        {
            var templatePSBT = await BitcoinService.GenerateTemplatePSBT(walletWithdrawalRequest);

            //TODO Save template PSBT (?)
            _templatePsbtString = templatePSBT.ToBase64();
            if (_psbtSignRef != null) await _psbtSignRef.ShowModal();
        }
        catch (NoUTXOsAvailableException)
        {
            ToastService.ShowError("No UTXOs available for withdrawals were found for this wallet");
        }
        catch (Exception)
        {
            ToastService.ShowError("Error while generating PSBT template for the request");
        }

    }

    private async Task Approve(WalletWithdrawalRequest request)
    {
        if (_selectedRequest == null || string.IsNullOrEmpty(_psbtSignRef?.SignedPSBT) || LoggedUser == null)
        {
             _utxoSelectorModalRef.ClearModal();
            ToastService.ShowError("Invalid request");
        }
        else
        {
            WalletWithdrawalRequestPSBT walletWithdrawalRequestPsbt = new()
                {
                    WalletWithdrawalRequestId = _selectedRequest.Id,
                    PSBT = _psbtSignRef.SignedPSBT,
                    SignerId = LoggedUser.Id,

                };
            var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

            if (addResult.Item1)
            {
                _selectedRequest.Status = WalletWithdrawalRequestStatus.PSBTSignaturesPending;
                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                   && PSBT.TryParse(walletWithdrawalRequestPsbt.PSBT, CurrentNetworkHelper.GetCurrentNetwork(), out _))
                {
                    if (_selectedRequest.AreAllRequiredHumanSignaturesCollected)
                    {
                        var failedWithdrawalRequest = false;
                        try
                        {
                            _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);
                            if (_selectedRequest != null)
                            {
                                CreateJob();
                            }
                        }
                        catch
                        {
                            failedWithdrawalRequest = true;
                        }

                        if (failedWithdrawalRequest)
                        {
                            ToastService.ShowError("Error while requesting to withdraw funds, please contact a superadmin for troubleshooting");
                        }
                        else
                        {
                            ToastService.ShowSuccess("Signature collected");
                        }
                    }

                }
                else
                {
                    ToastService.ShowError("Invalid PSBT");
                }
            }
            else
            {
                ToastService.ShowSuccess("Error while saving the signature");

            }
            await _psbtSignRef.HideModal();
            await GetData();
            StateHasChanged();

        }
    }

    private async Task ApproveRequestDelegate()
    {
        if (_selectedRequest != null)
            await Approve(_selectedRequest);
    }

    private async Task RejectOrCancel()
    {
        if ((_rejectCancelStatus == WalletWithdrawalRequestStatus.Cancelled || _rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
            && _selectedRequest != null)
        {
            _selectedRequest.RejectCancelDescription = _rejectCancelModalRef.Reason;
            _selectedRequest.Status = (WalletWithdrawalRequestStatus) _rejectCancelStatus;

            var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);

             if (updateResult.Item1 == false)
            {
                ToastService.ShowError("Something went wrong");
            }


            await HideRejectCancelModal();

        }
    }

    private async Task HideRejectCancelModal()
    {
        _rejectCancelStatus = null;
        _selectedRequest = null;
        _selectedRequestWalletBalance = 0;
        await GetData();
        await _rejectCancelModalRef.CloseModal();
    }

    private async Task ShowRejectCancelModal(WalletWithdrawalRequest walletWithdrawalRequest, WalletWithdrawalRequestStatus walletWithdrawalRequestStatus)
    {
        _rejectCancelStatus = walletWithdrawalRequestStatus;
        _selectedRequest = walletWithdrawalRequest;

        await _rejectCancelModalRef.ShowModal();
    }

    private async Task OnSelectedWallet(CellEditContext<WalletWithdrawalRequest> context, int id)
    {
        context.CellValue = id;

        var wallet = _availableWallets.SingleOrDefault(x => x.Id == id);
        _selectedWalletId = id == 0 ? null : id;
        if (wallet != null)
        {
            var (balance,_) = await BitcoinService.GetWalletConfirmedBalance(wallet);
            _selectedRequestWalletBalance = balance;
            if (IsCheckedAllFunds)
            {
                _amount = balance;
            }
        }
    }

    private async Task OpenCoinSelectionModal()
    {
        _utxoSelectorModalRef.ShowModal(_selectedWalletId.Value);
    }

    private void ClearSelectedUTXOs()
    {
        _utxoSelectorModalRef.ClearModal();
        SelectedUTXOs.Clear();
        StateHasChanged();
    }

    private void RejectReasonValidator(ValidatorEventArgs e)
    {
        if (_rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
        {
            ValidationRule.IsNotEmpty(e);
        }
        else
        {
            ValidationRule.None(e);
        }
    }

    private async Task CloseConfirmationModal()
    {
        await _confirmationModal.CloseModal();
    }

    private async Task SubmitConfirmationModal()
    {
        async Task CleanUp(string errorMessage)
        {
            ToastService.ShowError(errorMessage);
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
        }

        if (_selectedRequest != null)
        {
            try
            {
                _selectedRequest.Wallet = null;
                _selectedRequest.Changeless = SelectedUTXOs.Count > 0;
                _selectedRequest.WithdrawAllFunds = IsCheckedAllFunds || _amount == _selectedRequestWalletBalance;
                var createWithdrawalResult = await WalletWithdrawalRequestRepository.AddAsync(_selectedRequest);
                if (!createWithdrawalResult.Item1)
                {
                    throw new ShowToUserException(createWithdrawalResult.Item2);
                }
                ToastService.ShowSuccess("Withdrawal request created!");

                if (SelectedUTXOs.Count > 0)
                {
                    await CoinSelectionService.LockUTXOs(SelectedUTXOs, _selectedRequest, BitcoinRequestType.WalletWithdrawal);
                }
                var templatePSBT = await BitcoinService.GenerateTemplatePSBT(_selectedRequest);

                //TODO Save template PSBT (?)
                var walletWithdrawalRequestPsbt = new WalletWithdrawalRequestPSBT()
                {
                    WalletWithdrawalRequestId = _selectedRequest.Id,
                    PSBT = templatePSBT.ToBase64(),
                    SignerId = null,
                };

                var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

                if (!addResult.Item1)
                {
                    throw new ShowToUserException("Error while saving the signature");
                }

                ToastService.ShowSuccess("Signature collected");

                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && _selectedRequest.AreAllRequiredHumanSignaturesCollected)
                {
                    await CreateJob();
                }
                else
                {
                    throw new ShowToUserException("Invalid PSBT");
                }

                await GetData();
                _allRequestsDatagrid.Dispose();
                StateHasChanged();
                await _confirmationModal.CloseModal();
            }
            catch (NoUTXOsAvailableException e)
            {
                CleanUp("No UTXOs available for withdrawals were found for this wallet");
            }
            catch (ShowToUserException e)
            {
                CleanUp(e.Message);
            }
            catch
            {
                CleanUp("Something went wrong");
            }
        }
    }

    private async Task CreateJob()
    {
        try
        {
            IScheduler scheduler = await SchedulerFactory.GetScheduler();

            var map = new JobDataMap();
            map.Put("withdrawalRequestId", _selectedRequest.Id);

            var retryList = RetriableJob.ParseRetryListFromString(Constants.JOB_RETRY_INTERVAL_LIST_IN_MINUTES);
            var job = RetriableJob.Create<PerformWithdrawalJob>(map, _selectedRequest.Id.ToString(), retryList);
            await scheduler.ScheduleJob(job.Job, job.Trigger);

            if (_selectedRequest != null)
            {
                // TODO: Check job id
                _selectedRequest.JobId = job.Job.Key.ToString();
                WalletWithdrawalRequestRepository.Update(_selectedRequest);
            }
        }
        catch
        {
            ToastService.ShowError("Error while requesting a withdrawal, please contact a superadmin for troubleshooting");
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
            return;
        }
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsPendingRequestsColumnVisible(ColumnDefault column)
    {
        if (PendingRequestsColumnLayout	== null)
        {
            return true;
        }
        return PendingRequestsColumnLayout.IsColumnVisible(column);
    }

    private bool IsAllRequestsColumnVisible(ColumnDefault column)
    {
        if (AllRequestsColumnLayout	== null)
        {
            return true;
        }
        return AllRequestsColumnLayout.IsColumnVisible(column);
    }

    private void OnShowNewWalletWithdrawalModal()
    {
        _amount = _minimumWithdrawalAmount;
    }

}
