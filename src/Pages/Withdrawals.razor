@page "/withdrawals"
@using System.Security.Claims
@using Blazorise.Extensions
@using Blazorise.DataGrid
@using Blazorise.Components
@using Quartz
@using Humanizer
@using NBitcoin
@using NodeGuard.Jobs
@using Google.Protobuf
@using NBXplorer.Models
@using System.Text.Json
@using System.Linq
@using NodeGuard.Data.Models
@using NodeGuard.Helpers;
@using NodeGuard.Services;
@using Polly
@attribute [Authorize(Roles = "Superadmin,NodeManager,FinanceManager")]
<h3 class="custom-primary">Withdrawals</h3>

<Row>
@if (_isFinanceManager)
{
    <Column ColumnSize="ColumnSize.Is12">
    <h3>Requests awaiting my signature</h3>
    @* TODO: Convert this grid to paginated ReadData to avoid loading all records in memory. *@
    <DataGrid TItem="WalletWithdrawalRequest"
              Data="@_userPendingRequests"
              Editable="@_isFinanceManager"
              EditMode="DataGridEditMode.Popup"
              Responsive="true"
              ResizeMode="TableResizeMode.Columns"
              UseInternalEditing="true"
              RowInserted="OnRowInserted"
              RowRemoving="OnRowRemoving"
              RowUpdated="OnRowUpdated"
              NewItemDefaultSetter="NewItemDefaultSetter"
              ShowPager="true"
              ShowPageSizes="true"
              PageSize="25"
              Narrow="true"
              ShowValidationFeedback="true"
              ShowValidationsSummary="false"
              UseValidation="true">
        <PopupTitleTemplate>
            <h2>@(context.EditState) withdrawal</h2>
        </PopupTitleTemplate>
        <DataGridColumns>
            <DataGridCommandColumn TItem="WalletWithdrawalRequest" Filterable="false">
                <NewCommandTemplate>
                    <Button Color="Color.Success" TextColor="TextColor.Light" Clicked="@(async () => { await OnShowNewWalletWithdrawalModal(); await context.Clicked.InvokeAsync(); })">New</Button>
                </NewCommandTemplate>
                <EditCommandTemplate>
                    @*<Button Color="Color.Primary" Clicked="@context.Clicked">Edit</Button>*@

                </EditCommandTemplate>
                <DeleteCommandTemplate>
                    @*<Button Color="Color.Danger" Clicked="@context.Clicked">Delete</Button>*@
                </DeleteCommandTemplate>

            </DataGridCommandColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="Actions" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    <Button Color="Color.Success" hidden="@(!_isFinanceManager)" Clicked="() => ShowApprovalModal(context)">Approve</Button>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        var canCancel = context.Status == WalletWithdrawalRequestStatus.Pending || context.Status == WalletWithdrawalRequestStatus.PSBTSignaturesPending;
                        var isRequestor = LoggedUser?.Id == context.UserRequestorId;
                        var action = isRequestor ? "Cancel" : "Reject";
                        var newStatus = isRequestor ? WalletWithdrawalRequestStatus.Cancelled : WalletWithdrawalRequestStatus.Rejected;
                    }

                    @if (canCancel)
                    {
                        <Button Color="Color.Danger" Clicked="() => ShowRejectCancelModal(context, newStatus)">@action</Button>
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                        @context.Description.Truncate(40)
                    </Tooltip>
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationRule.IsNotEmpty">
                        <MemoEdit Rows="4" Text="@((string) context.CellValue)" TextChanged="(text) => context.CellValue = text">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </MemoEdit>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Validator="@ValidationRule.IsSelected" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @if (context.Wallet != null)
                    {
                        @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationRule.IsSelected">
                        @if (context.CellValue == null || (int) context.CellValue == 0)
                        {
                            <SelectList TItem="Wallet"
                                        TValue="int"
                                        Data="@_availableWallets"
                                        TextField="@((item) => item.Name)"
                                        ValueField="@((item) => item.Id)"
                                        SelectedValueChanged="(id) => OnSelectedWallet(context, id)"
                                        DefaultItemText="Choose the wallet">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </SelectList>
                        }
                        else
                        {
                            <SelectList TItem="Wallet"
                                        TValue="int"
                                        Data="@_availableWallets"
                                        TextField="@((item) => item.Name)"
                                        ValueField="@((item) => item.Id)"
                                        SelectedValue="(int) context.CellValue"
                                        SelectedValueChanged="(id) => OnSelectedWallet(context, id)">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </SelectList>
                        }
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Editable="false" Field="@nameof(WalletWithdrawalRequest.RequestMetadata)" Caption="Requestor" Sortable="true" Displayable="true">
                <DisplayTemplate>
                    @ShowRequestor(context)
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.WalletWithdrawalRequestDestinations)" Caption="Destination Address" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @(context.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address ?? "No address provided")
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@DestinationAddressValidator">
                        <TextEdit Text="@(GetDestinationAddressFromCellValue(context.CellValue))" TextChanged="(text) => OnDestinationAddressChanged(context, text)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </TextEdit>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is6" Field="@nameof(WalletWithdrawalRequest.WithdrawAllFunds)" Caption="@nameof(WalletWithdrawalRequest.WithdrawAllFunds).Humanize(LetterCasing.Sentence)" Editable="true" Displayable="false">
                <EditTemplate>
                    <Check TValue="bool" Checked="@((bool) context.CellValue)" CheckedChanged="(value) => HandleCheckboxChange(context, value)" @bind-Value="_isCheckedAllFunds"/>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn PopupFieldColumnSize="ColumnSize.Is6" Caption="Wallet Balance" Editable="true" Displayable="false">
                <EditTemplate>
                    @if (_selectedRequestWalletBalance != null)
                    {
                        <p>@($"{_selectedRequestWalletBalance:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal) _selectedRequestWalletBalance, _btcPrice), 2)} USD)")</p>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Caption="Amount" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        @($"{context.TotalAmount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.TotalAmount, _btcPrice), 2)} USD)")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="args => ValidationHelper.ValidateWithdrawalAmount(args, _selectedRequestWalletBalance)">
                        <NumericPicker TValue="decimal" @bind-Value="@_amount" Step="0.00001m" CurrencySymbol="₿ " Decimals="8" DecimalSeparator="," Disabled="@(_selectedUTXOs.Count > 0 || _isCheckedAllFunds)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                        <FieldHelp>
                            @{
                                var amountToShow = _amount < Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT
                                    ? _amount
                                    : Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT;
                                var convertedAmount = Math.Round(PriceConversionService.SatToUsdConversion(new Money(amountToShow, MoneyUnit.BTC).Satoshi, _btcPrice), 2);
                            }
                            @($"Minimum {_minimumWithdrawalAmount:f8} BTC. Current amount: {convertedAmount} USD")
                        </FieldHelp>
                    </Validation>
                    <div class="mb-3">
                        <Button Color="Color.Primary" Disabled="@(!_selectedWalletId.HasValue || _isCheckedAllFunds)" Clicked="@OpenCoinSelectionModal">Select Coins</Button> or use
                        <Button Color="Color.Primary" Disabled="@(_selectedUTXOs.Count == 0)" Clicked="@ClearSelectedUTXOs">Default Coin Selection</Button>
                    </div>
                    @if (_selectedWalletId.HasValue && _selectedUTXOs.Count > 0)
                    {
                        <span class="text-danger">Selected @(_selectedUTXOs.Count) UTXOs, this is a changeless operation</span>
                    }
                    else
                    {
                        <span class="text-danger">Default coin selection strategy selected</span>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.CustomFeeRate)" Caption="Fee rate" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @(context.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee ? $"Custom fee ({context.CustomFeeRate} sat/vb)" : $"{context.MempoolRecommendedFeesType.Humanize()} ({context.CustomFeeRate} sat/vb)")
                </DisplayTemplate>
                <EditTemplate>
                    <div class="d-flex">
                        <Select TValue="MempoolRecommendedFeesType" SelectedValue="_selectedMempoolRecommendedFeesType" SelectedValueChanged="async (value) => await OnMempoolFeeRateChange(value)">
                            <SelectGroup Label="Mempool.space fee">
                                <SelectItem Value="MempoolRecommendedFeesType.FastestFee">Fastest Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.EconomyFee">Economy Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.HourFee">Hour Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.HalfHourFee">Half Hour Fee</SelectItem>
                            </SelectGroup>
                            <SelectItem Value="MempoolRecommendedFeesType.CustomFee">Custom</SelectItem>
                        </Select>
                        <NumericPicker TValue="long" @bind-Value="@_customSatPerVbAmount" CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix" CurrencySymbol=" sat/vb" Min="1" Disabled="@(_selectedMempoolRecommendedFeesType != MempoolRecommendedFeesType.CustomFee)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                    </div>
                    <FieldHelp>@(_selectedMempoolRecommendedFeesType != MempoolRecommendedFeesType.CustomFee ? "Fees may change by the time the request is first signed" : "")</FieldHelp>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        if (context.Wallet != null)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                            var signaturesRequired = context.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Status)" Caption="Status" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @context?.Status.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="true">
                <DisplayTemplate>
                    @context.CreationDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="true">
                <DisplayTemplate>
                    @context.UpdateDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
        </DataGridColumns>

        <EmptyTemplate>
            <div class="box">
                No records were found.
            </div>
        </EmptyTemplate>
        <LoadingTemplate>
            <div class="box">
                <progress class="progress is-small is-primary" max="100"></progress>
            </div>
        </LoadingTemplate>
    </DataGrid>

    </Column>
}

<Column ColumnSize="ColumnSize.Is12">
    <h3>Requests</h3>
    <Row Class="mb-3" @key="_filtersResetKey">
        <Column ColumnSize="ColumnSize.Is2">
            <Field>
                <FieldLabel>Status</FieldLabel>
                <Autocomplete TItem="WalletWithdrawalRequestStatus?"
                              TValue="WalletWithdrawalRequestStatus?"
                              Data="@_statusOptions"
                              TextField="@(item => item?.Humanize() ?? "All")"
                              ValueField="@(item => item)"
                              @bind-SelectedValue="@_statusFilter"
                              @bind-SelectedValue:after="OnFiltersChanged"
                              Placeholder="All Statuses"
                              FreeTyping="false"
                              MinLength="0"
                              Filter="AutocompleteFilter.Contains" />
            </Field>
        </Column>
        <Column ColumnSize="ColumnSize.Is2">
            <Field>
                <FieldLabel>Wallet</FieldLabel>
                <Autocomplete TItem="Wallet"
                              TValue="int?"
                              Data="@_availableWallets"
                              TextField="@(item => item?.Name ?? "All")"
                              ValueField="@(item => (int?)item?.Id)"
                              @bind-SelectedValue="@_walletFilter"
                              @bind-SelectedValue:after="OnFiltersChanged"
                              Placeholder="All Wallets"
                              FreeTyping="false"
                              MinLength="0"
                              Filter="AutocompleteFilter.Contains" />
            </Field>
        </Column>
        <Column ColumnSize="ColumnSize.Is2">
            <Field>
                <FieldLabel>Requestor</FieldLabel>
                <Autocomplete TItem="ApplicationUser"
                              TValue="string?"
                              Data="@_availableUsers"
                              TextField="@(item => item?.UserName ?? "All")"
                              ValueField="@(item => item?.Id)"
                              @bind-SelectedValue="@_userFilter"
                              @bind-SelectedValue:after="OnFiltersChanged"
                              Placeholder="All Users"
                              FreeTyping="false"
                              MinLength="0"
                              Filter="AutocompleteFilter.Contains" />
            </Field>
        </Column>
        <Column ColumnSize="ColumnSize.Is2">
            <Field>
                <FieldLabel>From Date</FieldLabel>
                <DatePicker TValue="DateTime?" @bind-Date="@_fromDate" @bind-Date:after="OnFiltersChanged" InputMode="DateInputMode.Date" Placeholder="Start date" />
            </Field>
        </Column>
        <Column ColumnSize="ColumnSize.Is2">
            <Field>
                <FieldLabel>To Date</FieldLabel>
                <DatePicker TValue="DateTime?" @bind-Date="@_toDate" @bind-Date:after="OnFiltersChanged" InputMode="DateInputMode.Date" Placeholder="End date" />
            </Field>
        </Column>
        <Column ColumnSize="ColumnSize.Is2" Class="d-flex align-items-end pb-3">
            <Button Color="Color.Secondary" Clicked="ClearAllFilters">
                <Icon Name="IconName.Times" /> Clear
            </Button>
        </Column>
    </Row>
    <DataGrid TItem="WalletWithdrawalRequest"
              @ref="_allRequestsDatagrid"
              Data="@_withdrawalRequests"
              ReadData="@OnAllWithdrawalsReadData"
              TotalItems="@_totalWithdrawalRequests"
              Editable="false"
              Responsive="true"
              ResizeMode="TableResizeMode.Columns"
              ShowPager="true"
              ShowPageSizes="false"
              Narrow="true"
              PageSize="@_pageSize">
        <DataGridColumns>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
            <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                        @context.Description.Truncate(40)
                    </Tooltip>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @if (context.Wallet != null)
                    {
                        @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    @if (context.CellValue == null || (int) context.CellValue == 0)
                    {
                        <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValueChanged="(id) => context.CellValue = id"
                                    DefaultItemText="Choose the wallet"/>
                    }
                    else
                    {
                        <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValue="(int) context.CellValue"
                                    SelectedValueChanged="(id) => context.CellValue = id"/>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.RequestMetadata)" Caption="Requestor" Sortable="true" Displayable="true">
                <DisplayTemplate>
                    @ShowRequestor(context)
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.WalletWithdrawalRequestDestinations)" Caption="Destination Address" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @context.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address
                    @* TODO Copy and explorer buttons *@
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.TotalAmount)" Caption="Amount (BTC)" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        @($"{context.TotalAmount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.TotalAmount, _btcPrice), 2)} USD)")
                    }
                </DisplayTemplate>

            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.CustomFeeRate)" Caption="Fee rate" Sortable="false" Displayable="true">
                            <DisplayTemplate>
                                @(context.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee ? $"Custom fee ({context.CustomFeeRate} sat/vb)" : $"{context.MempoolRecommendedFeesType.Humanize()} ({context.CustomFeeRate} sat/vb)")
                            </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        if (context.Wallet != null)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                            var signaturesRequired = context.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Status)" Caption="Status" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    <Tooltip Text=@context.RejectCancelDescription Placement="TooltipPlacement.Top">
                        <span>@context?.Status.Humanize()</span>
                    </Tooltip>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="true">
                <DisplayTemplate>
                    @context.CreationDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="true">
                <DisplayTemplate>
                    @context.UpdateDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.TxId)" Caption="Links" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @if (mempoolUrl != null && !string.IsNullOrEmpty(context.TxId))
                    {
                        <a href="@(mempoolUrl + "/tx/" + context.TxId)" target="_blank">See in explorer</a>
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Caption="Actions" Displayable="true">
                <DisplayTemplate>
                    @if (_isFinanceManager && context.Status == WalletWithdrawalRequestStatus.OnChainConfirmationPending)
                    {
                            <Dropdown>
                                <DropdownToggle Color="Color.Primary">
                                </DropdownToggle>
                                <DropdownMenu>
                                    <DropdownItem Clicked="async () => await ShowBumpfeeModal(context)">Bump fee</DropdownItem>
                                </DropdownMenu>
                            </Dropdown>
                    }
                </DisplayTemplate>
            </DataGridColumn>
        </DataGridColumns>
        <EmptyTemplate>
            <div class="box">
                No records were found.
            </div>
        </EmptyTemplate>
        <LoadingTemplate>
            <div class="box">
                <progress class="progress is-small is-primary" max="100"></progress>
            </div>
        </LoadingTemplate>
    </DataGrid>

</Column>

</Row>

<PSBTSign
    @ref="_psbtSignRef"
    SignedPSBT="@_signedPSBT"
    WithdrawalRequest="_selectedRequest"
    SigHashMode="SigHash.All"
    TemplatePsbtString="@_templatePsbtString"
    ApproveRequestDelegate="async () => await ApproveRequestDelegate()"/>

<BumpfeeModal
    @ref="_bumpfeeRef"
    WithdrawalRequest="_selectedRequest"
    SubmitBumpfeeModal="@SubmitBumpfeeModal"/>

<CancelOrRejectPopup
    @ref="@_rejectCancelModalRef"
    Title='@("Wallet withdrawal:" + _selectedRequest?.Id)'
    Reason=""
    Validator="@RejectReasonValidator"
    OnCancel="@HideRejectCancelModal"
    OnSubmit="@RejectOrCancel"/>

<ConfirmationModal
    @ref="_confirmationModal"
    Title="Are you sure?"
    Body="You selected a hot wallet. This means that the system will automatically use the funds in it without the need of manual approval. Are you sure you want to perform this operation?"
    OkLabel="Yes, I am sure"
    OnCancel="@CloseConfirmationModal"
    OnSubmit="@SubmitConfirmationModal"/>

<UTXOSelectorModal
    @ref="_utxoSelectorModalRef"
    OnClose="@OnCloseCoinSelectionModal"
    IsWalletWithdrawalValidation="true"/>

@inject IToastService ToastService
@inject IAuditService AuditService
@inject IWalletWithdrawalRequestRepository WalletWithdrawalRequestRepository
@inject IWalletWithdrawalRequestPsbtRepository WalletWithdrawalRequestPsbtRepository
@inject IWalletRepository WalletRepository
@inject IBitcoinService BitcoinService
@inject ICoinSelectionService CoinSelectionService
@inject ISchedulerFactory SchedulerFactory
@inject ILocalStorageService LocalStorageService
@inject IPriceConversionService PriceConversionService
@inject INBXplorerService NBXplorerService
@inject IFMUTXORepository FMUTXORepository
@inject IWalletWithdrawalRequestDestinationRepository WalletWithdrawalRequestDestinationRepository
@inject IApplicationUserRepository ApplicationUserRepository
@inject ILogger<Withdrawals> Logger
@code {

    [CascadingParameter] private ApplicationUser? LoggedUser { get; set; }


    [CascadingParameter] private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private List<WalletWithdrawalRequest> _userPendingRequests = new();
    private List<Wallet> _availableWallets = new();
    private List<ApplicationUser> _availableUsers = new();
    private List<WalletWithdrawalRequest> _withdrawalRequests = new();
    private int _totalWithdrawalRequests;
    private int _currentPage = 1;
    private int _pageSize = 25;
    private string? mempoolUrl = Constants.MEMPOOL_ENDPOINT;
    private bool _isFinanceManager;
    private List<UTXO> _selectedUTXOs = new();
    private WalletWithdrawalRequest? _selectedRequest;
    private PSBTSign? _psbtSignRef;
    private BumpfeeModal? _bumpfeeRef;
    private string _signedPSBT;
    private string? _templatePsbtString;
    private int? _selectedWalletId;
    private static readonly decimal _minimumWithdrawalAmount = Constants.MINIMUM_WITHDRAWAL_BTC_AMOUNT;

    private decimal _amount { get; set; } = _minimumWithdrawalAmount;

    //Validation
    private DataGrid<WalletWithdrawalRequest>? _allRequestsDatagrid;
    private UTXOSelectorModal _utxoSelectorModalRef;
    private ConfirmationModal _confirmationModal;
    private CancelOrRejectPopup? _rejectCancelModalRef;
    private bool _isNodeManager = false;
    private WalletWithdrawalRequestStatus? _rejectCancelStatus = WalletWithdrawalRequestStatus.Rejected;
    private decimal? _selectedRequestWalletBalance;
    private decimal _btcPrice;
    private bool _isCheckedAllFunds;
    private MempoolRecommendedFeesType _selectedMempoolRecommendedFeesType;
    private long _customSatPerVbAmount = 1;

    // Filter state
    private WalletWithdrawalRequestStatus? _statusFilter;
    private int? _walletFilter;
    private string? _userFilter;
    private int _filtersResetKey;
    private DateTime? _fromDate;
    private DateTime? _toDate;

    // Filter options
    private List<WalletWithdrawalRequestStatus?> _statusOptions = new() { null };

    protected override async Task OnInitializedAsync()
    {
        if (LoggedUser == null) return;

        _btcPrice = await PriceConversionService.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }

        _isFinanceManager = ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString());

        // Initialize enum options
        _statusOptions.AddRange(Enum.GetValues<WalletWithdrawalRequestStatus>().Cast<WalletWithdrawalRequestStatus?>());

        await GetData();
    }

    private decimal SelectedUTXOsValue()
    {
        return _selectedUTXOs.Sum(x => ((Money) x.Value).ToUnit(MoneyUnit.BTC));
    }

    private async Task GetData()
    {
        if (LoggedUser?.Id != null && _isFinanceManager)
        {
            _userPendingRequests = await WalletWithdrawalRequestRepository.GetUnsignedPendingRequestsByUser(LoggedUser.Id);
        }
        else
        {
            _userPendingRequests.Clear();
        }

        _availableWallets = await WalletRepository.GetAvailableWallets(false);
        //TODO Fix BIP39 withdrawals, until then, manual hack to filter them out
        _availableWallets = _availableWallets.Where(x => !x.IsBIP39Imported).ToList();

        _availableUsers = await ApplicationUserRepository.GetAll();

        await ReloadAllWithdrawalsAsync();
    }

    private async Task ReloadAllWithdrawalsAsync(System.Threading.CancellationToken cancellationToken = default)
    {
        if (_allRequestsDatagrid != null)
        {
            await _allRequestsDatagrid.Reload();
        }
        else
        {
            await LoadAllWithdrawalRequestsAsync(_currentPage, _pageSize, cancellationToken);
        }
    }

    private async Task LoadAllWithdrawalRequestsAsync(int pageNumber, int pageSize, System.Threading.CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        var excludedIds = _userPendingRequests.Select(request => request.Id);
        var (requests, totalCount) = await WalletWithdrawalRequestRepository.GetPaginatedAsync(
            pageNumber,
            pageSize,
            excludedIds,
            status: _statusFilter,
            walletId: _walletFilter,
            userId: _userFilter,
            fromDate: _fromDate.HasValue ? new DateTimeOffset(_fromDate.Value, TimeSpan.Zero) : null,
            toDate: _toDate.HasValue ? new DateTimeOffset(_toDate.Value.AddDays(1).AddTicks(-1), TimeSpan.Zero) : null);

        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        _withdrawalRequests = requests;
        _totalWithdrawalRequests = totalCount;
        _currentPage = pageNumber;
        _pageSize = pageSize;
    }

    private async Task OnAllWithdrawalsReadData(DataGridReadDataEventArgs<WalletWithdrawalRequest> e)
    {
        await LoadAllWithdrawalRequestsAsync(e.Page, e.PageSize, e.CancellationToken);
    }

    private async Task OnFiltersChanged()
    {
        await ReloadAllWithdrawalsAsync();
    }

    private async Task ClearAllFilters()
    {
        _statusFilter = null;
        _walletFilter = null;
        _userFilter = null;
        _fromDate = null;
        _toDate = null;
        _filtersResetKey++;
        await ReloadAllWithdrawalsAsync();
    }

    private Task LogWithdrawalAuditAsync(
        AuditActionType actionType,
        AuditEventType eventType,
        WalletWithdrawalRequest? request,
        string message,
        object? extraDetails = null)
    {
        var destinationDetails = request?.WalletWithdrawalRequestDestinations?.Select(d => new
        {
            d.Address,
            d.Amount
        });

        var details = new
        {
            Message = message,
            RequestId = request?.Id,
            WalletId = request?.WalletId,
            Status = request?.Status.ToString(),
            Amount = request?.TotalAmount,
            ReferenceId = request?.ReferenceId,
            DestinationAddresses = destinationDetails,
            Extra = extraDetails
        };

        return AuditService.LogAsync(actionType, eventType, AuditObjectType.WalletWithdrawalRequest, request?.Id.ToString(), details);
    }

    private void OnCloseCoinSelectionModal(List<UTXO> selectedUTXOs)
    {
        _selectedUTXOs = selectedUTXOs;
        if (_selectedUTXOs.Count > 0)
        {
            _amount = SelectedUTXOsValue();
        }

        StateHasChanged();
    }

    private async Task OnRowInserted(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;
        var amount = _selectedUTXOs.Count > 0 ? SelectedUTXOsValue() : _amount;
        arg.Item.Wallet = await WalletRepository.GetById(arg.Item.WalletId);
        arg.Item.Changeless = _selectedUTXOs.Count > 0;
        arg.Item.WithdrawAllFunds = _isCheckedAllFunds || _amount == _selectedRequestWalletBalance;
        arg.Item.MempoolRecommendedFeesType = _selectedMempoolRecommendedFeesType;
        arg.Item.CustomFeeRate = _customSatPerVbAmount;
        arg.Item.WalletWithdrawalRequestDestinations = new List<WalletWithdrawalRequestDestination>
        {
            new WalletWithdrawalRequestDestination
            {
                Address = arg.Item.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address ?? "",
                Amount = amount
            }
        };
        
        if (arg.Item.Wallet.IsHotWallet)
        {
            await GetData();
            _selectedRequest = arg.Item;
            await _confirmationModal.ShowModal();
            await LogWithdrawalAuditAsync(AuditActionType.Create, AuditEventType.Attempt, arg.Item, "Hot wallet withdrawal pending confirmation.");
            return;
        }

        arg.Item.Wallet = null;
        var addResult = await WalletWithdrawalRequestRepository.AddAsync(arg.Item);
        if (addResult.Item1)
        {
            await LogWithdrawalAuditAsync(AuditActionType.Create, AuditEventType.Success, arg.Item, "Withdrawal request created.");
            ToastService.ShowSuccess("Success");
            await GetData();

            if (_selectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(_selectedUTXOs, arg.Item, BitcoinRequestType.WalletWithdrawal);
            }

            _utxoSelectorModalRef.ClearModal();
        }
        else
        {
            await LogWithdrawalAuditAsync(AuditActionType.Create, AuditEventType.Failure, arg.Item, addResult.Item2 ?? "Failed to create withdrawal request.");
            ToastService.ShowError("Something went wrong");
            _userPendingRequests.Remove(arg.Item);
        }
    }

    private string ShowRequestor(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        if (!string.IsNullOrEmpty(walletWithdrawalRequest.RequestMetadata))
        {
            var requestMetadata = JsonSerializer.Deserialize<Dictionary<string, string>>(walletWithdrawalRequest.RequestMetadata);
            if (requestMetadata != null && requestMetadata.TryGetValue("userName", out var userName))
            {
                if (ValidationHelper.IsValidEmail(userName))
                {
                    var atIndex = userName.IndexOf('@');
                    return atIndex >= 0 ? userName.Substring(0, atIndex) : userName;
                }

                return userName;
            }
        }

        return walletWithdrawalRequest.UserRequestor?.ToString() ?? "";
    }

    private void HandleCheckboxChange(CellEditContext<WalletWithdrawalRequest> context, bool value)
    {
        context.CellValue = value;
        _isCheckedAllFunds = value;
        if (_isCheckedAllFunds)
        {
            ClearSelectedUTXOs();
            _amount = _selectedRequestWalletBalance ?? _minimumWithdrawalAmount;
        }
    }

    private async Task OnRowRemoving(CancellableRowChange<WalletWithdrawalRequest> arg)
    {
        if (arg.Item != null)
        {
            var (result, errorMessage) = WalletWithdrawalRequestRepository.Remove(arg.Item);

            if (!result)
            {
                arg.Cancel = true;
                var message = errorMessage ?? "Something went wrong";
                ToastService.ShowError(message);
                await LogWithdrawalAuditAsync(AuditActionType.Delete, AuditEventType.Failure, arg.Item, message);
            }
            else
            {
                await LogWithdrawalAuditAsync(AuditActionType.Delete, AuditEventType.Success, arg.Item, "Withdrawal request removed.");
                ToastService.ShowSuccess("Success");
                await GetData();
            }
        }
    }

    private async Task OnRowUpdated(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;
        // Validate balance

        if (await ValidateBalance(arg)) return;

        var (updated, errorMessage) = WalletWithdrawalRequestRepository.Update(arg.Item);
        if (updated)
        {
            await LogWithdrawalAuditAsync(AuditActionType.Update, AuditEventType.Success, arg.Item, "Withdrawal request updated.");
            ToastService.ShowSuccess("Success");
        }
        else
        {
            var message = errorMessage ?? "Something went wrong";
            await LogWithdrawalAuditAsync(AuditActionType.Update, AuditEventType.Failure, arg.Item, message);
            ToastService.ShowError(message);
        }

        await GetData();
    }
    
    private async Task OnMempoolFeeRateChange(MempoolRecommendedFeesType value)
    {
        _selectedMempoolRecommendedFeesType = value;
        _customSatPerVbAmount = (long?)await NBXplorerService.GetFeesByType(_selectedMempoolRecommendedFeesType) ?? 1;
    }

    private async Task<bool> ValidateBalance(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        var wallet = await WalletRepository.GetById(arg.Item.WalletId);

        if (wallet != null)
        {
            var balance = await BitcoinService.GetWalletConfirmedBalance(wallet);

            if (arg.Item.TotalAmount > balance.Item1)
            {
                ToastService.ShowError(
                    $"The confirmed balance({balance.Item1:f8} BTC) for the selected wallet is less than the amount requested to withdraw ({arg.Item.TotalAmount:f8} BTC)");
                await GetData();
                return true;
            }
        }

        return false;
    }

    private void DestinationAddressValidator(ValidatorEventArgs obj)
    {
        var str = obj.Value as string;

        obj.Status = ValidationStatus.Success;

        try
        {
            BitcoinAddress.Create(str!, CurrentNetworkHelper.GetCurrentNetwork());
        }
        catch (Exception)
        {
            obj.ErrorText = "Invalid bitcoin address";
            obj.Status = ValidationStatus.Error;
        }
    }

    private void NewItemDefaultSetter(WalletWithdrawalRequest obj)
    {
        if (LoggedUser != null)
        {
            obj.UserRequestorId = LoggedUser.Id;
            obj.RequestMetadata = JsonSerializer.Serialize(new 
            {
                userName = LoggedUser.UserName ?? ""
            });
            _selectedRequestWalletBalance = null;
        }
    }

    private async Task ShowApprovalModal(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        _selectedRequest = await WalletWithdrawalRequestRepository.GetById(walletWithdrawalRequest.Id);

        //PSBT Generation
        try
        {
            var templatePSBT = await BitcoinService.GenerateTemplatePSBT(walletWithdrawalRequest);

            //TODO Save template PSBT (?)
            _templatePsbtString = templatePSBT.ToBase64();
            if (_psbtSignRef != null) await _psbtSignRef.ShowModal();
        }
        catch (NoUTXOsAvailableException)
        {
            ToastService.ShowError("No UTXOs available for withdrawals were found for this wallet");
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, "No UTXOs available for withdrawal approval.");
        }
        catch (BumpingException e)
        {
            ToastService.ShowError(e.Message);
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, e.Message);
        }
        catch (ShowToUserException e)
        {
            ToastService.ShowError(e.Message);
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, e.Message);
            await GetData();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ToastService.ShowError("Error while generating PSBT template for the request");
            var message = string.IsNullOrWhiteSpace(ex.Message) ? "Error while generating PSBT template." : ex.Message;
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, message);
        }
    }

    private async Task ShowBumpfeeModal(WalletWithdrawalRequest walletWithdrawalRequest)
    {   
        if (walletWithdrawalRequest == null)
        {
            ToastService.ShowError("Invalid request");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, null, "Invalid bump fee request.");
            return;
        }
            
        var request = await WalletWithdrawalRequestRepository.GetById(walletWithdrawalRequest.Id);
        if (request == null)
        {
            ToastService.ShowError("Request not found");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, walletWithdrawalRequest, "Withdrawal request not found for bumping.");
            return;
        }
        
        // We check in case that someone tries to bump a request that is not in the right state
        if (request.Status != WalletWithdrawalRequestStatus.OnChainConfirmationPending)
        {
            ToastService.ShowError("Bumpfee can only be used for transactions that are pending on-chain confirmation.");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, "Bump requested for withdrawal not pending on-chain confirmation.");
            return;
        }
        
        ulong confirmations = 0;
        if (!string.IsNullOrEmpty(request.TxId))
        {
            try
            {
                var nbxplorerStatus = await NBXplorerService.GetTransactionAsync(uint256.Parse(request.TxId));
                confirmations = (ulong)(nbxplorerStatus?.Confirmations ?? throw new Exception("Failed to get confirmations"));
            }
            catch (Exception)
            {
                ToastService.ShowError("Error getting confirmations");
                await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, "Failed to retrieve transaction confirmations for bumping.");
                return;
            }
        }
        
        if (confirmations > 0)
        {
            ToastService.ShowError("Bumpfee can only be used for transactions with no confirmations. " +
                                   "This transaction has already been mined.");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, "Bump requested for transaction that already has confirmations.");
            return;
        }
        
        if (request.Changeless && request.WalletWithdrawalRequestDestinations!.Count > 1)
        {
            ToastService.ShowError("Fee bumping is not supported for changeless transactions. Please create a new withdrawal with higher fees instead.");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, "Bump requested for changeless transaction with multiple outputs.");
            return;
        }
        
        try
        {
            _selectedRequest = request;

            if (_bumpfeeRef != null) await _bumpfeeRef.ShowModal();
        }
        catch (Exception ex)
        {
            ToastService.ShowError("Error while creating bumpfee modal");
            var message = string.IsNullOrWhiteSpace(ex.Message) ? "Error while creating bump fee modal." : ex.Message;
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, message);
        }
    }

    private async Task Approve()
    {
        if (_selectedRequest == null || string.IsNullOrEmpty(_psbtSignRef?.SignedPSBT) || LoggedUser == null)
        {
            _utxoSelectorModalRef.ClearModal();
            ToastService.ShowError("Invalid request");
            await LogWithdrawalAuditAsync(AuditActionType.Sign, AuditEventType.Failure, _selectedRequest, "Attempted to sign withdrawal request with invalid data.");
        }
        else if (_selectedRequest.WalletWithdrawalRequestPSBTs.Any(x => _psbtSignRef.SignedPSBT.Equals(x.PSBT)))
        {
            ToastService.ShowError("You already signed this request with this key");
            await LogWithdrawalAuditAsync(AuditActionType.Sign, AuditEventType.Failure, _selectedRequest, "Duplicate signature submission detected.");
        }
        else
        {
            WalletWithdrawalRequestPSBT walletWithdrawalRequestPsbt = new()
            {
                WalletWithdrawalRequestId = _selectedRequest.Id,
                PSBT = _psbtSignRef.SignedPSBT,
                SignerId = LoggedUser.Id,
            };
            var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

            if (addResult.Item1)
            {
                await LogWithdrawalAuditAsync(AuditActionType.Sign, AuditEventType.Success, _selectedRequest, "PSBT signature stored.");
                _selectedRequest.Status = WalletWithdrawalRequestStatus.PSBTSignaturesPending;
                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && PSBT.TryParse(walletWithdrawalRequestPsbt.PSBT, CurrentNetworkHelper.GetCurrentNetwork(), out _))
                {
                    if (_selectedRequest.AreAllRequiredHumanSignaturesCollected)
                    {
                        var failedWithdrawalRequest = false;
                        try
                        {
                            _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);
                            if (_selectedRequest != null)
                            {
                                await CreateJob();
                                if (_selectedRequest?.BumpingWalletWithdrawalRequestId != null)
                                {
                                    await UpdateBumpWalletWithdrawalRequest();
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            failedWithdrawalRequest = true;
                            var message = string.IsNullOrWhiteSpace(ex.Message) ? "Failed to queue withdrawal." : ex.Message;
                            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, message);
                        }

                        if (failedWithdrawalRequest)
                        {
                            ToastService.ShowError("Error while requesting to withdraw funds, please contact a superadmin for troubleshooting");
                        }
                        else
                        {
                            ToastService.ShowSuccess("Signature collected");
                        }
                    }
                }
                else
                {
                    const string invalidPsbtMessage = "Invalid PSBT";
                    ToastService.ShowError(invalidPsbtMessage);
                    await LogWithdrawalAuditAsync(AuditActionType.Sign, AuditEventType.Failure, _selectedRequest, invalidPsbtMessage);
                }
            }
            else
            {
                var message = addResult.Item2 ?? "Error while saving the signature";
                ToastService.ShowError(message);
                await LogWithdrawalAuditAsync(AuditActionType.Sign, AuditEventType.Failure, _selectedRequest, message);
            }

            await _psbtSignRef.HideModal();
            await GetData();
            StateHasChanged();
        }
    }

    private async Task CreateNewWithdrawal(WalletWithdrawalRequest newRequest)
    {
        _selectedMempoolRecommendedFeesType = newRequest.MempoolRecommendedFeesType;
        _customSatPerVbAmount = (long)newRequest.CustomFeeRate;
        _selectedRequest = newRequest;
        if (newRequest.Wallet.IsHotWallet)
        {
            await GetData();
            await _confirmationModal.ShowModal();
            return;
        }

        newRequest.Wallet = null;

        try {
            if (_selectedRequest.Id == 0)
            {
                var createWithdrawalResult = await WalletWithdrawalRequestRepository.AddAsync(_selectedRequest);
                if (!createWithdrawalResult.Item1)
                {
                    throw new ShowToUserException(createWithdrawalResult.Item2);
                }
            }
            else
            {
                var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);
                if (!updateResult.Item1)
                {
                    throw new ShowToUserException(updateResult.Item2);
                }
            }

            ToastService.ShowSuccess("Success");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Success, _selectedRequest, "Bump withdrawal request created.");
            await GetData();

            if (_selectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(_selectedUTXOs, newRequest, BitcoinRequestType.WalletWithdrawal);
            }

            _utxoSelectorModalRef.ClearModal();
        }
        catch (ShowToUserException e)
        {
            ToastService.ShowError(e.Message);
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, _selectedRequest, e.Message);
            _userPendingRequests.Remove(newRequest);
        }
        catch (Exception e)
        {
            Logger.LogError("Error creating a new withdrawal request for bumping fee: {Error}", e.Message);
            var message = string.IsNullOrWhiteSpace(e.Message) ? "Something went wrong" : e.Message;
            ToastService.ShowError("Something went wrong");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, _selectedRequest, message);
        }
    }

    private async Task Bumpfee(WalletWithdrawalRequest request)
    {
        try
        {
            await CreateNewWithdrawal(request);
        }
        catch
        {
            ToastService.ShowError("Could not bump the withdrawal");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, request, "Could not bump the withdrawal.");
        }
    }

    private async void SubmitBumpfeeModal(WalletWithdrawalRequest newRequest)
    {
        try
        {
            if (newRequest != null && _bumpfeeRef != null)
            {
                newRequest.Wallet = await WalletRepository.GetById(newRequest.WalletId);
                    
                // Use either the custom fee rate or the recommended fee rate based on mempool fee type
                decimal newFeeRate;
                if (newRequest.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee && newRequest.CustomFeeRate.HasValue)
                {
                    newFeeRate = (decimal)newRequest.CustomFeeRate.Value;
                }
                else
                {
                    // Use the recommended fee rate from NBXplorer service based on the selected mempool fee type
                    var recommendedFeeRate = await GetRecommendedFeeRate(newRequest.MempoolRecommendedFeesType);
                    newFeeRate = (decimal)recommendedFeeRate;
                }

                // If the new fee plus the amount exceeds the utxo sum value, show an error
                // NOTE: revisit this when full rbf because we could add a UTXO
                var txInfo = await NBXplorerService.GetTransactionAsync(uint256.Parse(_selectedRequest.TxId));
                var tx = txInfo.Transaction;
                long vSize = tx.GetVirtualSize();
                decimal newFee = (vSize * newFeeRate) / 100_000_000m;

                // Retrieve from database to get the UTXOs
                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest == null)
                {
                    ToastService.ShowError("Withdrawal request not found");
                    await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, _selectedRequest, "Withdrawal request not found while bumping.");
                    return;
                }

                // This enables wds that have only one destination to be bumped by reducing the destination amount
                if (_selectedRequest.UTXOs != null && _selectedRequest.UTXOs.Count > 0 && _selectedRequest.WalletWithdrawalRequestDestinations!.Count > 1)
                {
                    var inputAmount = Money.Satoshis(_selectedRequest.UTXOs.Sum(x => x.SatsAmount)).ToDecimal(MoneyUnit.BTC); // Convert to BTC
                    // Check if the new fee plus the amount exceeds the sum of the selected UTXOs or returns dust
                    if (inputAmount < newFee + _selectedRequest.TotalAmount + Constants.BITCOIN_DUST.ToDecimal(MoneyUnit.BTC))
                    {
                        ToastService.ShowError("The new fee plus the amount exceeds the sum of the selected UTXOs or returns dust. Please lower the fee rate.");
                        await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, _selectedRequest, "New fee amount exceeds available UTXO value.");
                        return;
                    }
                }

                // If the request is changeless and it has more than 1 output, show an error
                if (_selectedRequest.Changeless && _selectedRequest.WalletWithdrawalRequestDestinations!.Count > 1)
                {
                    ToastService.ShowError("Fee bumping is not supported for changeless transactions. Please create a new withdrawal with higher fees instead.");
                    await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, _selectedRequest, "Fee bump not allowed for changeless multi-output transaction.");
                    return;
                }
                
                await Bumpfee(newRequest);
                await _bumpfeeRef.HideModal();
                StateHasChanged();
            }
            else
            {
                ToastService.ShowError("Something went wrong");
                await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, newRequest, "Invalid bump fee request parameters.");
            }
        }
        catch (Exception)
        {
            ToastService.ShowError($"Something went wrong");
            await LogWithdrawalAuditAsync(AuditActionType.BumpFee, AuditEventType.Failure, newRequest, "Unexpected error while bumping withdrawal.");
            await _bumpfeeRef.HideModal();
        }
    }

    private async Task<long> GetRecommendedFeeRate(MempoolRecommendedFeesType feeType)
    {
        return (long?)await NBXplorerService.GetFeesByType(feeType) ?? 1;
    }

    
    private async Task ApproveRequestDelegate()
    {
        if (_selectedRequest != null)
        {
            _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);
            await Approve();
        }
    }

    private async Task RejectOrCancel()
    {
        if ((_rejectCancelStatus == WalletWithdrawalRequestStatus.Cancelled || _rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
            && _selectedRequest != null)
        {
            _selectedRequest.RejectCancelDescription = _rejectCancelModalRef.Reason;
            _selectedRequest.Status = (WalletWithdrawalRequestStatus) _rejectCancelStatus;

            var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);
            if (!updateResult.Item1)
            {
                Logger.LogError("Error while updating the withdrawal request status to cancelled/rejected: {Error}", updateResult.Item2);
                var message = updateResult.Item2 ?? "Something went wrong";
                ToastService.ShowError(message);
                var failureAction = _rejectCancelStatus == WalletWithdrawalRequestStatus.Cancelled ? AuditActionType.Cancel : AuditActionType.Reject;
                await LogWithdrawalAuditAsync(failureAction, AuditEventType.Failure, _selectedRequest, message);
            }
            else
            {
                var successAction = _rejectCancelStatus == WalletWithdrawalRequestStatus.Cancelled ? AuditActionType.Cancel : AuditActionType.Reject;
                var successMessage = successAction == AuditActionType.Cancel ? "Withdrawal request cancelled." : "Withdrawal request rejected.";
                await LogWithdrawalAuditAsync(successAction, AuditEventType.Success, _selectedRequest, successMessage);
            }

            // In case that is a bump, we return the old request status to pending confirmation.
            await ResetStatusBumpedIfError(_selectedRequest);

            await HideRejectCancelModal();
        }
    }

    private async Task HideRejectCancelModal()
    {
        _rejectCancelStatus = null;
        _selectedRequest = null;
        _selectedRequestWalletBalance = 0;
        await GetData();
        await _rejectCancelModalRef.CloseModal();
    }

    private async Task ShowRejectCancelModal(WalletWithdrawalRequest walletWithdrawalRequest, WalletWithdrawalRequestStatus walletWithdrawalRequestStatus)
    {
        _rejectCancelStatus = walletWithdrawalRequestStatus;
        _selectedRequest = walletWithdrawalRequest;

        await _rejectCancelModalRef.ShowModal();
    }

    private async Task OnSelectedWallet(CellEditContext<WalletWithdrawalRequest> context, int id)
    {
        context.CellValue = id;

        var wallet = _availableWallets.SingleOrDefault(x => x.Id == id);
        _selectedWalletId = id == 0 ? null : id;
        if (wallet != null)
        {
            var (balance, _) = await BitcoinService.GetWalletConfirmedBalance(wallet);
            _selectedRequestWalletBalance = balance;
            if (_isCheckedAllFunds)
            {
                _amount = balance;
            }
        }
    }

    private async Task OpenCoinSelectionModal()
    {
        _utxoSelectorModalRef.ShowModal(_selectedWalletId.Value);
    }

    private void ClearSelectedUTXOs()
    {
        _utxoSelectorModalRef.ClearModal();
        _selectedUTXOs.Clear();
        StateHasChanged();
    }

    private void RejectReasonValidator(ValidatorEventArgs e)
    {
        if (_rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
        {
            ValidationRule.IsNotEmpty(e);
        }
        else
        {
            ValidationRule.None(e);
        }
    }

    private async Task CloseConfirmationModal()
    {
        if (_selectedRequest != null)
        {
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Cancelled;
            _selectedRequest.RejectCancelDescription = "User cancelled the operation";
            var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);
            if (!updateResult.Item1)
            {
                Logger.LogError("Error while updating the withdrawal request status to cancelled: {Error}", updateResult.Item2);
                var message = updateResult.Item2 ?? "Something went wrong";
                ToastService.ShowError(message);
                await LogWithdrawalAuditAsync(AuditActionType.Cancel, AuditEventType.Failure, _selectedRequest, message);
            }
            else
            {
                await LogWithdrawalAuditAsync(AuditActionType.Cancel, AuditEventType.Success, _selectedRequest, "Withdrawal request cancelled by user.");
            }
            StateHasChanged();
        }
        await _confirmationModal.CloseModal();
    }

    private async Task UpdateBumpWalletWithdrawalRequest()
    {
        if (_selectedRequest == null) throw new BumpingException("Invalid request");
        
        var outpoints = _selectedRequest.UTXOs.Select(u => OutPoint.Parse($"{u.TxId}:{u.OutputIndex}")).ToList();
        _selectedUTXOs = await CoinSelectionService.GetUTXOsByOutpointAsync(_selectedRequest.Wallet.GetDerivationStrategy()!, outpoints);

        // Update the status of the old withdrawal request
        if (_selectedRequest.BumpingWalletWithdrawalRequestId != null)
        {
            _selectedRequest.BumpingWalletWithdrawalRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.BumpingWalletWithdrawalRequestId.Value);
            if (_selectedRequest.BumpingWalletWithdrawalRequest == null)
            {
                throw new BumpingException("Could not find bumping withdrawal request");
            }
            _selectedRequest.BumpingWalletWithdrawalRequest.Status = WalletWithdrawalRequestStatus.Bumped;
            var updateResultOldWithdrawal = WalletWithdrawalRequestRepository.Update(_selectedRequest.BumpingWalletWithdrawalRequest);
            if (!updateResultOldWithdrawal.Item1)
            {
                throw new BumpingException("Something went wrong");
            }
        }
    }

    private async Task SubmitConfirmationModal()
    {
        async Task CleanUp(string errorMessage)
        {
            ToastService.ShowError(errorMessage);
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await LogWithdrawalAuditAsync(AuditActionType.Create, AuditEventType.Failure, _selectedRequest, errorMessage);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
        }

        if (_selectedRequest != null)
        {
            try
            {   
                _selectedRequest.Wallet = await WalletRepository.GetById(_selectedRequest.WalletId);
                _selectedRequest.WithdrawAllFunds = _isCheckedAllFunds || _amount == _selectedRequestWalletBalance;
                _selectedRequest.MempoolRecommendedFeesType = _selectedMempoolRecommendedFeesType;
                _selectedRequest.CustomFeeRate = _customSatPerVbAmount;
                
                if (_selectedRequest.Id == 0)
                {
                    var createWithdrawalResult = await WalletWithdrawalRequestRepository.AddAsync(_selectedRequest);
                    if (!createWithdrawalResult.Item1)
                    {
                        throw new ShowToUserException(createWithdrawalResult.Item2);
                    }
                }
                else
                {
                    var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);
                    if (!updateResult.Item1)
                    {
                        throw new ShowToUserException(updateResult.Item2);
                    }
                }

                if (_selectedRequest.BumpingWalletWithdrawalRequestId != null)
                {
                    await UpdateBumpWalletWithdrawalRequest();
                }

                _selectedRequest.Changeless = _selectedUTXOs.Count > 0;

                ToastService.ShowSuccess("Withdrawal request created!");
                await LogWithdrawalAuditAsync(AuditActionType.Create, AuditEventType.Success, _selectedRequest, "Withdrawal request created.");

                if (_selectedUTXOs.Count > 0)
                {
                    await CoinSelectionService.LockUTXOs(_selectedUTXOs, _selectedRequest, BitcoinRequestType.WalletWithdrawal);
                }

                var templatePsbt = await BitcoinService.GenerateTemplatePSBT(_selectedRequest);

                var walletWithdrawalRequestPsbt = new WalletWithdrawalRequestPSBT()
                {
                    WalletWithdrawalRequestId = _selectedRequest.Id,
                    PSBT = templatePsbt.ToBase64(),
                    SignerId = null,
                };

                var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);
                if (!addResult.Item1)
                {
                    throw new ShowToUserException("Error while saving the signature");
                }

                ToastService.ShowSuccess("Signature collected");

                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && _selectedRequest.AreAllRequiredHumanSignaturesCollected)
                {
                    await CreateJob();
                }
                else
                {
                    throw new ShowToUserException("Invalid PSBT");
                }

                await GetData();
                StateHasChanged();
                await _confirmationModal.CloseModal();
            }
            catch (NoUTXOsAvailableException e)
            {
                await CleanUp("No UTXOs available for withdrawals were found for this wallet");
                await ResetStatusBumpedIfError(_selectedRequest);
            }
            catch (ShowToUserException e)
            {
                await CleanUp(e.Message);
                await ResetStatusBumpedIfError(_selectedRequest);
            }
            catch (BumpingException e)
            {
                await CleanUp(e.Message);
                await ResetStatusBumpedIfError(_selectedRequest);
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Error while creating withdrawal");
                await CleanUp("Something went wrong");
                await ResetStatusBumpedIfError(_selectedRequest);
            }
        }
    }

    private async Task ResetStatusBumpedIfError(WalletWithdrawalRequest request)
    {
        if (request.BumpingWalletWithdrawalRequestId != null)
        {
            var bumpedRequest = await WalletWithdrawalRequestRepository.GetById(request.BumpingWalletWithdrawalRequestId.Value);

            if (bumpedRequest != null)
            {
                bumpedRequest.Status = WalletWithdrawalRequestStatus.OnChainConfirmationPending;
                var updateResult = WalletWithdrawalRequestRepository.Update(bumpedRequest);
                if (!updateResult.Item1)
                {
                    ToastService.ShowError("Error while updating the bumped request, please contact a superadmin for troubleshooting");
                    return;
                }
            }
        }
    }

    private async Task CreateJob()
    {
        try
        {
            var scheduler = await SchedulerFactory.GetScheduler();

            var map = new JobDataMap();
            map.Put("withdrawalRequestId", _selectedRequest.Id);

            var job = SimpleJob.Create<PerformWithdrawalJob>(map, _selectedRequest.Id.ToString());
            await scheduler.ScheduleJob(job.Job, job.Trigger);

            if (_selectedRequest != null)
            {
                WalletWithdrawalRequestRepository.Update(_selectedRequest);
            }
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Success, _selectedRequest, "Withdrawal job scheduled.");
        }
        catch (Exception ex)
        {
            ToastService.ShowError("Error while requesting a withdrawal, please contact a superadmin for troubleshooting");
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            var message = string.IsNullOrWhiteSpace(ex.Message) ? "Failed to schedule withdrawal job." : ex.Message;
            await LogWithdrawalAuditAsync(AuditActionType.Approve, AuditEventType.Failure, _selectedRequest, message);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
            return;
        }
    }

    private async Task<bool> ShowActionDropdown(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        ulong confirmations = 0;
        if (!string.IsNullOrEmpty(walletWithdrawalRequest.TxId))
        {
            try
            {
                var nbxplorerStatus = await NBXplorerService.GetTransactionAsync(uint256.Parse(walletWithdrawalRequest.TxId));
                confirmations = (ulong)(nbxplorerStatus?.Confirmations ?? throw new Exception("Failed to get confirmations"));
                return walletWithdrawalRequest.Status == WalletWithdrawalRequestStatus.OnChainConfirmationPending && confirmations.Equals((ulong) 0);
            }
            catch (Exception)
            {
                ToastService.ShowError("Error while showing bumpfee action");
                return false;
            }
        }

        return false;
    }

    private async Task OnShowNewWalletWithdrawalModal()
    {
        _selectedMempoolRecommendedFeesType = MempoolRecommendedFeesType.FastestFee;
        await OnMempoolFeeRateChange(_selectedMempoolRecommendedFeesType);

        _amount = _minimumWithdrawalAmount;
    }

    private void OnDestinationAddressChanged(CellEditContext<WalletWithdrawalRequest> context, string text)
    {
        context.CellValue = new List<WalletWithdrawalRequestDestination> { new() { Address = text, Amount = 0m } };
    }

    private string GetDestinationAddressFromCellValue(object cellValue)
    {
        if (cellValue is List<WalletWithdrawalRequestDestination> destinations && destinations.Any())
        {
            return destinations.First().Address ?? string.Empty;
        }
        return string.Empty;
    }

    private bool CustomRequestorFilter(object itemvalue, object searchvalue)
    {
        if (searchvalue is not string search || string.IsNullOrWhiteSpace(search))
        {
            return true;
        }

        if (itemvalue is string metadata)
        {
            try
            {
            var requestMetadata = JsonSerializer.Deserialize<Dictionary<string, string>>(metadata);
            if (requestMetadata != null && requestMetadata.TryGetValue("userName", out var userName))
            {
                return userName.Contains(search, StringComparison.OrdinalIgnoreCase);
            }
            }
            catch (JsonException)
            {
                // If deserialization fails, we assume the filter does not match
                return false;
            }
        }

        return false;
    }
}
