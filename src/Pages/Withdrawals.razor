@page "/withdrawals"
@using System.Security.Claims
@using Blazorise.Extensions
@using Quartz
@using Humanizer
@using NBitcoin
@using NodeGuard.Jobs
@using Google.Protobuf
@using NBXplorer.Models
@using System.Text.Json
@using NodeGuard.Helpers;
@using Polly
@attribute [Authorize(Roles = "Superadmin,NodeManager,FinanceManager")]

<Row>
@if (_isFinanceManager)
{
    <Column ColumnSize="ColumnSize.Is12">
    <h3>Withdrawal requests awaiting my signature</h3>
    <DataGrid TItem="WalletWithdrawalRequest"
              Data="@_userPendingRequests"
              Editable="@_isFinanceManager"
              EditMode="DataGridEditMode.Popup"
              Responsive="true"
              ResizeMode="TableResizeMode.Columns"
              UseInternalEditing="true"
              RowInserted="OnRowInserted"
              RowRemoving="OnRowRemoving"
              RowUpdated="OnRowUpdated"
              NewItemDefaultSetter="NewItemDefaultSetter"
              ShowPager="true"
              ShowPageSizes="true"
              PageSize="25"
              Narrow="true"
              Filterable="true"
              ShowValidationFeedback="true"
              ShowValidationsSummary="false"
              UseValidation="true">
        <PopupTitleTemplate>
            <h2>@(context.EditState) withdrawal</h2>
        </PopupTitleTemplate>
        <DataGridColumns>
            <DataGridCommandColumn TItem="WalletWithdrawalRequest" Filterable="false">
                <NewCommandTemplate>
                    <Button Color="Color.Success" TextColor="TextColor.Light" Clicked="@(async () => { await OnShowNewWalletWithdrawalModal(); await context.Clicked.InvokeAsync(); })">New</Button>
                </NewCommandTemplate>
                <EditCommandTemplate>
                    @*<Button Color="Color.Primary" Clicked="@context.Clicked">Edit</Button>*@

                </EditCommandTemplate>
                <DeleteCommandTemplate>
                    @*<Button Color="Color.Danger" Clicked="@context.Clicked">Delete</Button>*@
                </DeleteCommandTemplate>

            </DataGridCommandColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="Actions" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    <Button Color="Color.Success" hidden="@(!_isFinanceManager)" Clicked="() => ShowApprovalModal(context)">Approve</Button>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Caption="" Sortable="false" Displayable="true">
                <DisplayTemplate>
                    @{
                        var canCancel = context.Status == WalletWithdrawalRequestStatus.Pending || context.Status == WalletWithdrawalRequestStatus.PSBTSignaturesPending;
                        var isRequestor = LoggedUser?.Id == context.UserRequestorId;
                        var action = isRequestor ? "Cancel" : "Reject";
                        var newStatus = isRequestor ? WalletWithdrawalRequestStatus.Cancelled : WalletWithdrawalRequestStatus.Rejected;
                    }

                    @if (canCancel)
                    {
                        <Button Color="Color.Danger" Clicked="() => ShowRejectCancelModal(context, newStatus)">@action</Button>
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Description)">
                <DisplayTemplate>
                    <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                        @context.Description.Truncate(40)
                    </Tooltip>
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationRule.IsNotEmpty">
                        <MemoEdit Rows="4" Text="@((string) context.CellValue)" TextChanged="(text) => context.CellValue = text">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </MemoEdit>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Validator="@ValidationRule.IsSelected" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Wallet)">
                <DisplayTemplate>
                    @if (context.Wallet != null)
                    {
                        @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationRule.IsSelected">
                        @if (context.CellValue == null || (int) context.CellValue == 0)
                        {
                            <SelectList TItem="Wallet"
                                        TValue="int"
                                        Data="@_availableWallets"
                                        TextField="@((item) => item.Name)"
                                        ValueField="@((item) => item.Id)"
                                        SelectedValueChanged="(id) => OnSelectedWallet(context, id)"
                                        DefaultItemText="Choose the wallet">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </SelectList>
                        }
                        else
                        {
                            <SelectList TItem="Wallet"
                                        TValue="int"
                                        Data="@_availableWallets"
                                        TextField="@((item) => item.Name)"
                                        ValueField="@((item) => item.Id)"
                                        SelectedValue="(int) context.CellValue"
                                        SelectedValueChanged="(id) => OnSelectedWallet(context, id)">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </SelectList>
                        }
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Editable="false" Field="@nameof(WalletWithdrawalRequest.RequestMetadata)" Caption="Requestor" Sortable="true" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Requestor)" CustomFilter="CustomRequestorFilter">
                <DisplayTemplate>
                    @ShowRequestor(context)
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.WalletWithdrawalRequestDestinations)" Caption="Destination Address" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.DestinationAddress)">
                <DisplayTemplate>
                    @(context.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address ?? "No address provided")
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@DestinationAddressValidator">
                        <TextEdit Text="@(GetDestinationAddressFromCellValue(context.CellValue))" TextChanged="(text) => OnDestinationAddressChanged(context, text)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </TextEdit>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is6" Field="@nameof(WalletWithdrawalRequest.WithdrawAllFunds)" Caption="@nameof(WalletWithdrawalRequest.WithdrawAllFunds).Humanize(LetterCasing.Sentence)" Editable="true" Displayable="false">
                <EditTemplate>
                    <Check TValue="bool" Checked="@((bool) context.CellValue)" CheckedChanged="(value) => HandleCheckboxChange(context, value)" @bind-Value="_isCheckedAllFunds"/>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn PopupFieldColumnSize="ColumnSize.Is6" Caption="Wallet Balance" Editable="true" Displayable="false">
                <EditTemplate>
                    @if (_selectedRequestWalletBalance != null)
                    {
                        <p>@($"{_selectedRequestWalletBalance:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal) _selectedRequestWalletBalance, _btcPrice), 2)} USD)")</p>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Caption="Amount" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Amount)">
                <DisplayTemplate>
                    @{
                        @($"{context.TotalAmount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.TotalAmount, _btcPrice), 2)} USD)")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="args => ValidationHelper.ValidateWithdrawalAmount(args, _selectedRequestWalletBalance)">
                        <NumericPicker TValue="decimal" @bind-Value="@_amount" Step="0.00001m" CurrencySymbol="₿ " Decimals="8" DecimalSeparator="," Disabled="@(_selectedUTXOs.Count > 0 || _isCheckedAllFunds)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                        <FieldHelp>
                            @{
                                var amountToShow = _amount < Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT
                                    ? _amount
                                    : Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT;
                                var convertedAmount = Math.Round(PriceConversionService.SatToUsdConversion(new Money(amountToShow, MoneyUnit.BTC).Satoshi, _btcPrice), 2);
                            }
                            @($"Minimum {_minimumWithdrawalAmount:f8} BTC. Current amount: {convertedAmount} USD")
                        </FieldHelp>
                    </Validation>
                    <div class="mb-3">
                        <Button Color="Color.Primary" Disabled="@(!_selectedWalletId.HasValue || _isCheckedAllFunds)" Clicked="@OpenCoinSelectionModal">Select Coins</Button> or use
                        <Button Color="Color.Primary" Disabled="@(_selectedUTXOs.Count == 0)" Clicked="@ClearSelectedUTXOs">Default Coin Selection</Button>
                    </div>
                    @if (_selectedWalletId.HasValue && _selectedUTXOs.Count > 0)
                    {
                        <span class="text-danger">Selected @(_selectedUTXOs.Count) UTXOs, this is a changeless operation</span>
                    }
                    else
                    {
                        <span class="text-danger">Default coin selection strategy selected</span>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.CustomFeeRate)" Caption="Fee rate" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.FeeRate)">
                <DisplayTemplate>
                    @(context.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee ? $"Custom fee ({context.CustomFeeRate} sat/vb)" : $"{context.MempoolRecommendedFeesType.Humanize()} ({context.CustomFeeRate} sat/vb)")
                </DisplayTemplate>
                <EditTemplate>
                    <div class="d-flex">
                        <Select TValue="MempoolRecommendedFeesType" SelectedValue="_selectedMempoolRecommendedFeesType" SelectedValueChanged="async (value) => await OnMempoolFeeRateChange(value)">
                            <SelectGroup Label="Mempool.space fee">
                                <SelectItem Value="MempoolRecommendedFeesType.FastestFee">Fastest Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.EconomyFee">Economy Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.HourFee">Hour Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesType.HalfHourFee">Half Hour Fee</SelectItem>
                            </SelectGroup>
                            <SelectItem Value="MempoolRecommendedFeesType.CustomFee">Custom</SelectItem>
                        </Select>
                        <NumericPicker TValue="long" @bind-Value="@_customSatPerVbAmount" CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix" CurrencySymbol=" sat/vb" Min="1" Disabled="@(_selectedMempoolRecommendedFeesType != MempoolRecommendedFeesType.CustomFee)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                    </div>
                    <FieldHelp>@(_selectedMempoolRecommendedFeesType != MempoolRecommendedFeesType.CustomFee ? "Fees may change by the time the request is first signed" : "")</FieldHelp>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.SignaturesCollected)">
                <DisplayTemplate>
                    @{
                        if (context.Wallet != null)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                            var signaturesRequired = context.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.Status).Humanize(LetterCasing.Sentence)" Caption="Status" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.Status)">
                <DisplayTemplate>
                    @context?.Status.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.CreationDate)">
                <DisplayTemplate>
                    @context.CreationDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="false" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsPendingRequestsColumnVisible(PendingWithdrawalsColumnName.UpdateDate)">
                <DisplayTemplate>
                    @context.UpdateDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Displayable="true">
                <FilterTemplate>
                    <ColumnLayout @ref="_pendingRequestsColumnLayout" Columns="@_pendingRequestsColumns" ColumnType="PendingWithdrawalsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                </FilterTemplate>
            </DataGridColumn>
        </DataGridColumns>

        <EmptyTemplate>
            <div class="box">
                No records were found.
            </div>
        </EmptyTemplate>
        <LoadingTemplate>
            <div class="box">
                <progress class="progress is-small is-primary" max="100"></progress>
            </div>
        </LoadingTemplate>
    </DataGrid>

    </Column>
}

<Column ColumnSize="ColumnSize.Is12">
    <h3>Withdrawal requests</h3>
    <DataGrid TItem="WalletWithdrawalRequest"
              @ref="_allRequestsDatagrid"
              Data="@_withdrawalRequests"
              Filterable="true"
              FilterMethod="DataGridFilterMethod.Contains"
              Editable="false"
              Responsive="true"
              ResizeMode="TableResizeMode.Columns"
              ShowPager="true"
              ShowPageSizes="true"
              Narrow="true"
              PageSize="25">
        <DataGridColumns>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
            <DataGridColumn TItem="WalletWithdrawalRequest" PopupFieldColumnSize="ColumnSize.Is12" Editable="true" Field="@nameof(WalletWithdrawalRequest.Description)" Caption="@nameof(WalletWithdrawalRequest.Description)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Description)">
                <DisplayTemplate>
                    <Tooltip Text="@context.Description" Placement="TooltipPlacement.Top">
                        @context.Description.Truncate(40)
                    </Tooltip>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="@nameof(WalletWithdrawalRequest.Wallet)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Wallet)">
                <DisplayTemplate>
                    @if (context.Wallet != null)
                    {
                        @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    @if (context.CellValue == null || (int) context.CellValue == 0)
                    {
                        <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValueChanged="(id) => context.CellValue = id"
                                    DefaultItemText="Choose the wallet"/>
                    }
                    else
                    {
                        <SelectList TItem="Wallet"
                                    TValue="int"
                                    Data="@_availableWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValue="(int) context.CellValue"
                                    SelectedValueChanged="(id) => context.CellValue = id"/>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.RequestMetadata)" Caption="Requestor" Sortable="true" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Requestor)" CustomFilter="@((itemValue, searchValue) => CustomRequestorFilter(itemValue, searchValue))">
                <DisplayTemplate>
                    @ShowRequestor(context)
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="true" Validator="DestinationAddressValidator" Field="@nameof(WalletWithdrawalRequest.WalletWithdrawalRequestDestinations)" Caption="Destination Address" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.DestinationAddress)">
                <DisplayTemplate>
                    @context.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address
                    @* TODO Copy and explorer buttons *@
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Editable="false" Field="@nameof(WalletWithdrawalRequest.TotalAmount)" Caption="Amount (BTC)" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Amount)">
                <DisplayTemplate>
                    @{
                        @($"{context.TotalAmount:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(context.TotalAmount, _btcPrice), 2)} USD)")
                    }
                </DisplayTemplate>

            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Filterable="true" Editable="false" Field="@nameof(WalletWithdrawalRequest.CustomFeeRate)" Caption="Fee rate" Sortable="false" Displayable="@IsAllRequestsColumnVisible(PendingWithdrawalsColumnName.FeeRate)">
                            <DisplayTemplate>
                                @(context.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee ? $"Custom fee ({context.CustomFeeRate} sat/vb)" : $"{context.MempoolRecommendedFeesType.Humanize()} ({context.CustomFeeRate} sat/vb)")
                            </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.SignaturesCollected)">
                <DisplayTemplate>
                    @{
                        if (context.Wallet != null)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.RequiresInternalWalletSigning && !context.Wallet.IsSingleSig ? 1 : 0);
                            var signaturesRequired = context.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.Status).Humanize(LetterCasing.Sentence)" Caption="Status" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Status)">
                <DisplayTemplate>
                    <Tooltip Text=@context.RejectCancelDescription Placement="TooltipPlacement.Top">
                        <span>@context?.Status.Humanize()</span>
                    </Tooltip>
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.CreationDate)">
                <DisplayTemplate>
                    @context.CreationDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.UpdateDate)">
                <DisplayTemplate>
                    @context.UpdateDatetime.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Field="@nameof(WalletWithdrawalRequest.TxId)" Caption="Links" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Links)">
                <DisplayTemplate>
                    @if (mempoolUrl != null && !string.IsNullOrEmpty(context.TxId))
                    {
                        <a href="@(mempoolUrl + "/tx/" + context.TxId)" target="_blank">See in explorer</a>
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="WalletWithdrawalRequest" Caption="Actions" Displayable="@IsAllRequestsColumnVisible(AllWithdrawalsColumnName.Actions)">
                <DisplayTemplate>
                    @if (_isFinanceManager && context.Status == WalletWithdrawalRequestStatus.OnChainConfirmationPending)
                    {
                            <Dropdown>
                                <DropdownToggle Color="Color.Primary">
                                </DropdownToggle>
                                <DropdownMenu>
                                    <DropdownItem Clicked="async () => await ShowBumpfeeModal(context)">Bump fee</DropdownItem>
                                </DropdownMenu>
                            </Dropdown>
                    }
                </DisplayTemplate>
            </DataGridColumn>
            
            <DataGridColumn TItem="WalletWithdrawalRequest" Displayable="true">
                <FilterTemplate>
                    <ColumnLayout @ref="_allRequestsColumnLayout" Columns="@_allRequestsColumns" ColumnType="AllWithdrawalsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                </FilterTemplate>
            </DataGridColumn>
        </DataGridColumns>
        <EmptyTemplate>
            <div class="box">
                No records were found.
            </div>
        </EmptyTemplate>
        <LoadingTemplate>
            <div class="box">
                <progress class="progress is-small is-primary" max="100"></progress>
            </div>
        </LoadingTemplate>
    </DataGrid>

</Column>

</Row>

<PSBTSign
    @ref="_psbtSignRef"
    SignedPSBT="@_signedPSBT"
    WithdrawalRequest="_selectedRequest"
    SigHashMode="SigHash.All"
    TemplatePsbtString="@_templatePsbtString"
    ApproveRequestDelegate="async () => await ApproveRequestDelegate()"/>

<BumpfeeModal
    @ref="_bumpfeeRef"
    WithdrawalRequest="_selectedRequest"
    SubmitBumpfeeModal="@SubmitBumpfeeModal"/>

<CancelOrRejectPopup
    @ref="@_rejectCancelModalRef"
    Title='@("Wallet withdrawal:" + _selectedRequest?.Id)'
    Validator="@RejectReasonValidator"
    OnCancel="@HideRejectCancelModal"
    OnSubmit="@RejectOrCancel"/>

<ConfirmationModal
    @ref="_confirmationModal"
    Title="Are you sure?"
    Body="You selected a hot wallet. This means that the system will automatically use the funds in it without the need of manual approval. Are you sure you want to perform this operation?"
    OkLabel="Yes, I am sure"
    OnCancel="@CloseConfirmationModal"
    OnSubmit="@SubmitConfirmationModal"/>

<UTXOSelectorModal
    @ref="_utxoSelectorModalRef"
    OnClose="@OnCloseCoinSelectionModal"
    IsWalletWithdrawalValidation="true"/>

@inject IToastService ToastService
@inject IWalletWithdrawalRequestRepository WalletWithdrawalRequestRepository
@inject IWalletWithdrawalRequestPsbtRepository WalletWithdrawalRequestPsbtRepository
@inject IWalletRepository WalletRepository
@inject IBitcoinService BitcoinService
@inject ICoinSelectionService CoinSelectionService
@inject ISchedulerFactory SchedulerFactory
@inject ILocalStorageService LocalStorageService
@inject IPriceConversionService PriceConversionService
@inject INBXplorerService NBXplorerService
@inject IFMUTXORepository FMUTXORepository
@inject IWalletWithdrawalRequestDestinationRepository WalletWithdrawalRequestDestinationRepository
@code {

    [CascadingParameter] private ApplicationUser? LoggedUser { get; set; }


    [CascadingParameter] private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private ColumnLayout<PendingWithdrawalsColumnName> _pendingRequestsColumnLayout;
    private List<WalletWithdrawalRequest> _userPendingRequests = new();
    private List<Wallet> _availableWallets = new();
    private List<WalletWithdrawalRequest> _withdrawalRequests = new();
    private string? mempoolUrl = Constants.MEMPOOL_ENDPOINT;
    private bool _isFinanceManager;
    private List<UTXO> _selectedUTXOs = new();
    private WalletWithdrawalRequest? _selectedRequest;
    private PSBTSign? _psbtSignRef;
    private BumpfeeModal? _bumpfeeRef;
    private string _signedPSBT;
    private string? _templatePsbtString;
    private int? _selectedWalletId;
    private static readonly decimal _minimumWithdrawalAmount = Constants.MINIMUM_WITHDRAWAL_BTC_AMOUNT;

    private decimal _amount { get; set; } = _minimumWithdrawalAmount;

    //Validation
    private DataGrid<WalletWithdrawalRequest>? _allRequestsDatagrid;
    private UTXOSelectorModal _utxoSelectorModalRef;
    private ConfirmationModal _confirmationModal;
    private CancelOrRejectPopup? _rejectCancelModalRef;
    private bool _isNodeManager = false;
    private WalletWithdrawalRequestStatus? _rejectCancelStatus = WalletWithdrawalRequestStatus.Rejected;
    private decimal? _selectedRequestWalletBalance;
    private decimal _btcPrice;
    private ColumnLayout<AllWithdrawalsColumnName> _allRequestsColumnLayout;
    private Dictionary<string, bool> _pendingRequestsColumns = new();
    private Dictionary<string, bool> _allRequestsColumns = new();
    private bool _columnsLoaded;
    private bool _isCheckedAllFunds;
    private MempoolRecommendedFeesType _selectedMempoolRecommendedFeesType;
    private long _customSatPerVbAmount = 1;

    public abstract class PendingWithdrawalsColumnName
    {
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault Wallet = new("Wallet");
        public static readonly ColumnDefault Requestor = new("Requestor");
        public static readonly ColumnDefault DestinationAddress = new("Destination Address");
        public static readonly ColumnDefault Amount = new("Amount (BTC)");
        public static readonly ColumnDefault FeeRate = new("Fee Rate");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
    }

    public abstract class AllWithdrawalsColumnName
    {
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault Wallet = new("Wallet");
        public static readonly ColumnDefault Requestor = new("Requestor");
        public static readonly ColumnDefault DestinationAddress = new("Destination Address");
        public static readonly ColumnDefault Amount = new("Amount (BTC)");
        public static readonly ColumnDefault FeeRate = new("Fee Rate");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
        public static readonly ColumnDefault Links = new("Links");
        public static readonly ColumnDefault Actions = new("Actions");
    }

    protected override async Task OnInitializedAsync()
    {
        if (LoggedUser == null) return;

        _btcPrice = await PriceConversionService.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }

        _isFinanceManager = ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString());
        await GetData();
        await LoadColumnLayout();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !_columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private decimal SelectedUTXOsValue()
    {
        return _selectedUTXOs.Sum(x => ((Money) x.Value).ToUnit(MoneyUnit.BTC));
    }

    private async Task LoadColumnLayout()
    {
        _allRequestsColumns = await LocalStorageService.LoadStorage(nameof(AllWithdrawalsColumnName), ColumnHelpers.GetColumnsDictionary<AllWithdrawalsColumnName>());
        _pendingRequestsColumns = await LocalStorageService.LoadStorage(nameof(PendingWithdrawalsColumnName), ColumnHelpers.GetColumnsDictionary<PendingWithdrawalsColumnName>());
        _columnsLoaded = true;
        StateHasChanged();
    }

    private async Task GetData()
    {
        if (LoggedUser?.Id != null && _isFinanceManager)
        {
            _userPendingRequests = await WalletWithdrawalRequestRepository.GetUnsignedPendingRequestsByUser(LoggedUser.Id);
        }

        _withdrawalRequests = (await WalletWithdrawalRequestRepository.GetAll()).Except(_userPendingRequests).ToList();

        _availableWallets = await WalletRepository.GetAvailableWallets(false);
        //TODO Fix BIP39 withdrawals, until then, manual hack to filter them out
        _availableWallets = _availableWallets.Where(x => !x.IsBIP39Imported).ToList();
    }

    private void OnCloseCoinSelectionModal(List<UTXO> selectedUTXOs)
    {
        _selectedUTXOs = selectedUTXOs;
        if (_selectedUTXOs.Count > 0)
        {
            _amount = SelectedUTXOsValue();
        }

        StateHasChanged();
    }

    private async Task OnRowInserted(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;
        var amount = _selectedUTXOs.Count > 0 ? SelectedUTXOsValue() : _amount;
        arg.Item.Wallet = await WalletRepository.GetById(arg.Item.WalletId);
        arg.Item.Changeless = _selectedUTXOs.Count > 0;
        arg.Item.WithdrawAllFunds = _isCheckedAllFunds || _amount == _selectedRequestWalletBalance;
        arg.Item.MempoolRecommendedFeesType = _selectedMempoolRecommendedFeesType;
        arg.Item.CustomFeeRate = _customSatPerVbAmount;
        arg.Item.WalletWithdrawalRequestDestinations = new List<WalletWithdrawalRequestDestination>
        {
            new WalletWithdrawalRequestDestination
            {
                Address = arg.Item.WalletWithdrawalRequestDestinations?.FirstOrDefault()?.Address ?? "",
                Amount = amount
            }
        };
        
        if (arg.Item.Wallet.IsHotWallet)
        {
            await GetData();
            _selectedRequest = arg.Item;
            await _confirmationModal.ShowModal();
            return;
        }

        arg.Item.Wallet = null;
        var addResult = await WalletWithdrawalRequestRepository.AddAsync(arg.Item);


        if (addResult.Item1)
        {
            ToastService.ShowSuccess("Success");
            await GetData();

            if (_selectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(_selectedUTXOs, arg.Item, BitcoinRequestType.WalletWithdrawal);
            }

            _utxoSelectorModalRef.ClearModal();
        }
        else
        {
            ToastService.ShowError("Something went wrong");
            _userPendingRequests.Remove(arg.Item);
        }
    }

    private string ShowRequestor(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        if (walletWithdrawalRequest.RequestMetadata != null)
        {
            var requestMetadata = JsonSerializer.Deserialize<Dictionary<string, string>>(walletWithdrawalRequest.RequestMetadata);
            if (requestMetadata != null && requestMetadata.TryGetValue("userName", out var userName))
            {
                if (ValidationHelper.IsValidEmail(userName))
                {
                    var atIndex = userName.IndexOf('@');
                    return atIndex >= 0 ? userName.Substring(0, atIndex) : userName;
                }

                return userName;
            }
        }

        return walletWithdrawalRequest.UserRequestor?.ToString() ?? "";
    }

    private void HandleCheckboxChange(CellEditContext<WalletWithdrawalRequest> context, bool value)
    {
        context.CellValue = value;
        _isCheckedAllFunds = value;
        if (_isCheckedAllFunds)
        {
            ClearSelectedUTXOs();
            _amount = _selectedRequestWalletBalance ?? _minimumWithdrawalAmount;
        }
    }

    private async Task OnRowRemoving(CancellableRowChange<WalletWithdrawalRequest> arg)
    {
        if (arg.Item != null)
        {
            var (result, _) = WalletWithdrawalRequestRepository.Remove(arg.Item);

            if (!result)
            {
                arg.Cancel = true;
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess("Success");
                await GetData();
            }
        }
    }

    private async Task OnRowUpdated(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;
        // Validate balance

        if (await ValidateBalance(arg)) return;

        var updateResult = WalletWithdrawalRequestRepository.Update(arg.Item);


        if (updateResult.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Something went wrong");
        }

        await GetData();
    }
    
    private async Task OnMempoolFeeRateChange(MempoolRecommendedFeesType value)
    {
        _selectedMempoolRecommendedFeesType = value;
        _customSatPerVbAmount = (long?)await NBXplorerService.GetFeesByType(_selectedMempoolRecommendedFeesType) ?? 1;
    }

    private async Task<bool> ValidateBalance(SavedRowItem<WalletWithdrawalRequest, Dictionary<string, object>> arg)
    {
        var wallet = await WalletRepository.GetById(arg.Item.WalletId);

        if (wallet != null)
        {
            var balance = await BitcoinService.GetWalletConfirmedBalance(wallet);

            if (arg.Item.TotalAmount > balance.Item1)
            {
                ToastService.ShowError(
                    $"The confirmed balance({balance.Item1:f8} BTC) for the selected wallet is less than the amount requested to withdraw ({arg.Item.TotalAmount:f8} BTC)");
                await GetData();
                return true;
            }
        }

        return false;
    }

    private void DestinationAddressValidator(ValidatorEventArgs obj)
    {
        var str = obj.Value as string;

        obj.Status = ValidationStatus.Success;

        try
        {
            BitcoinAddress.Create(str!, CurrentNetworkHelper.GetCurrentNetwork());
        }
        catch (Exception)
        {
            obj.ErrorText = "Invalid bitcoin address";
            obj.Status = ValidationStatus.Error;
        }
    }

    private void NewItemDefaultSetter(WalletWithdrawalRequest obj)
    {
        if (LoggedUser != null)
        {
            obj.UserRequestorId = LoggedUser.Id;
            obj.RequestMetadata = JsonSerializer.Serialize(new 
            {
                userName = LoggedUser.UserName ?? ""
            });
            _selectedRequestWalletBalance = null;
        }
    }

    private async Task ShowApprovalModal(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        _selectedRequest = walletWithdrawalRequest;

        //PSBT Generation
        try
        {
            if (_selectedRequest.BumpingWalletWithdrawalRequestId != null)
            {
                await CopyBumpedRequestData(_selectedRequest);
            }

            var templatePSBT = await BitcoinService.GenerateTemplatePSBT(walletWithdrawalRequest);

            //TODO Save template PSBT (?)
            _templatePsbtString = templatePSBT.ToBase64();
            if (_psbtSignRef != null) await _psbtSignRef.ShowModal();
        }
        catch (NoUTXOsAvailableException)
        {
            ToastService.ShowError("No UTXOs available for withdrawals were found for this wallet");
        }
        catch (Exception)
        {
            ToastService.ShowError("Error while generating PSBT template for the request");
        }
    }

    private async Task ShowBumpfeeModal(WalletWithdrawalRequest walletWithdrawalRequest)
    {   
        if (walletWithdrawalRequest == null)
        {
            ToastService.ShowError("Invalid request");
            return;
        }
            
        var request = await WalletWithdrawalRequestRepository.GetById(walletWithdrawalRequest.Id);
        if (request == null)
        {
            ToastService.ShowError("Request not found");
            return;
        }
        
        // We check in case that someone tries to bump a request that is not in the right state
        if (request.Status != WalletWithdrawalRequestStatus.OnChainConfirmationPending)
        {
            ToastService.ShowError("Bumpfee can only be used for transactions that are pending on-chain confirmation.");
            return;
        }
        
        ulong confirmations = 0;
        if (!string.IsNullOrEmpty(request.TxId))
        {
            try
            {
                var nbxplorerStatus = await NBXplorerService.GetTransactionAsync(uint256.Parse(request.TxId));
                confirmations = (ulong)(nbxplorerStatus?.Confirmations ?? throw new Exception("Failed to get confirmations"));
            }
            catch (Exception)
            {
                ToastService.ShowError("Error getting confirmations");
                return;
            }
        }
        
        if (confirmations > 0)
        {
            ToastService.ShowError("Bumpfee can only be used for transactions with no confirmations. " +
                                   "This transaction has already been mined.");
            return;
        }
        
        if (request.Changeless && request.WalletWithdrawalRequestDestinations!.Count > 1)
        {
            ToastService.ShowError("Fee bumping is not supported for changeless transactions. Please create a new withdrawal with higher fees instead.");
            return;
        }
        
        try
        {
            _selectedRequest = request;

            if (_bumpfeeRef != null) await _bumpfeeRef.ShowModal();
        }
        catch (Exception)
        {
            ToastService.ShowError("Error while creating bumpfee modal");
        }
    }

    private async Task Approve()
    {
        if (_selectedRequest == null || string.IsNullOrEmpty(_psbtSignRef?.SignedPSBT) || LoggedUser == null)
        {
            _utxoSelectorModalRef.ClearModal();
            ToastService.ShowError("Invalid request");
        }
        else if (_selectedRequest.WalletWithdrawalRequestPSBTs.Any(x => _psbtSignRef.SignedPSBT.Equals(x.PSBT)))
        {
            ToastService.ShowError("You already signed this request with this key");
        }
        else
        {
            WalletWithdrawalRequestPSBT walletWithdrawalRequestPsbt = new()
            {
                WalletWithdrawalRequestId = _selectedRequest.Id,
                PSBT = _psbtSignRef.SignedPSBT,
                SignerId = LoggedUser.Id,
            };
            var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

            if (addResult.Item1)
            {
                _selectedRequest.Status = WalletWithdrawalRequestStatus.PSBTSignaturesPending;
                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && PSBT.TryParse(walletWithdrawalRequestPsbt.PSBT, CurrentNetworkHelper.GetCurrentNetwork(), out _))
                {
                    if (_selectedRequest.AreAllRequiredHumanSignaturesCollected)
                    {
                        var failedWithdrawalRequest = false;
                        try
                        {
                            _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);
                            if (_selectedRequest != null)
                            {
                                CreateJob();
                            }
                        }
                        catch
                        {
                            failedWithdrawalRequest = true;
                        }

                        if (failedWithdrawalRequest)
                        {
                            ToastService.ShowError("Error while requesting to withdraw funds, please contact a superadmin for troubleshooting");
                        }
                        else
                        {
                            ToastService.ShowSuccess("Signature collected");
                        }
                    }
                }
                else
                {
                    ToastService.ShowError("Invalid PSBT");
                }
            }
            else
            {
                ToastService.ShowSuccess("Error while saving the signature");
            }

            await _psbtSignRef.HideModal();
            await GetData();
            StateHasChanged();
        }
    }

    private async Task CreateNewWithdrawal(WalletWithdrawalRequest newRequest)
    {
        _selectedMempoolRecommendedFeesType = newRequest.MempoolRecommendedFeesType;
        _customSatPerVbAmount = (long)newRequest.CustomFeeRate;
        if (newRequest.Wallet.IsHotWallet)
        {
            await GetData();
            _selectedRequest = newRequest;
            await _confirmationModal.ShowModal();
            return;
        }

        newRequest.Wallet = null;
        var addResult = await WalletWithdrawalRequestRepository.AddAsync(newRequest);


        if (addResult.Item1)
        {
            ToastService.ShowSuccess("Success");
            await GetData();

            if (_selectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(_selectedUTXOs, newRequest, BitcoinRequestType.WalletWithdrawal);
            }

            _utxoSelectorModalRef.ClearModal();
        }
        else
        {
            ToastService.ShowError("Something went wrong");
            _userPendingRequests.Remove(newRequest);
        }
    }

    private async Task Bumpfee(WalletWithdrawalRequest request)
    {
        try
        {
            await CreateNewWithdrawal(request);
        }
        catch
        {
            ToastService.ShowError("Could not bump the withdrawal");
        }
    }

    private async void SubmitBumpfeeModal(WalletWithdrawalRequest newRequest)
    {
        try
        {
            if (newRequest != null && _bumpfeeRef != null)
            {
                newRequest.WalletId = _selectedRequest.WalletId;
                newRequest.Wallet = await WalletRepository.GetById(newRequest.WalletId);
                    
                // Use either the custom fee rate or the recommended fee rate based on mempool fee type
                decimal newFeeRate;
                if (newRequest.MempoolRecommendedFeesType == MempoolRecommendedFeesType.CustomFee && newRequest.CustomFeeRate.HasValue)
                {
                    newFeeRate = (decimal)newRequest.CustomFeeRate.Value;
                }
                else
                {
                    // Use the recommended fee rate from NBXplorer service based on the selected mempool fee type
                    var recommendedFeeRate = await GetRecommendedFeeRate(newRequest.MempoolRecommendedFeesType);
                    newFeeRate = (decimal)recommendedFeeRate;
                }

                // If the new fee plus the amount exceeds the utxo sum value, show an error
                // NOTE: revisit this when full rbf because we could add a UTXO
                var txInfo = await NBXplorerService.GetTransactionAsync(uint256.Parse(_selectedRequest.TxId));
                var tx = txInfo.Transaction;
                long vSize = tx.GetVirtualSize();
                decimal newFee = (vSize * newFeeRate) / 100_000_000m;

                // Retrieve from database to get the UTXOs
                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest == null)
                {
                    ToastService.ShowError("Withdrawal request not found");
                    return;
                }

                // This enables wds that have only one destination to be bumped by reducing the destination amount
                if (_selectedRequest.UTXOs != null && _selectedRequest.UTXOs.Count > 0 && _selectedRequest.WalletWithdrawalRequestDestinations!.Count > 1)
                {
                    var inputAmount = Money.Satoshis(_selectedRequest.UTXOs.Sum(x => x.SatsAmount)).ToDecimal(MoneyUnit.BTC); // Convert to BTC
                    // Check if the new fee plus the amount exceeds the sum of the selected UTXOs or returns dust
                    if (inputAmount < newFee + _selectedRequest.TotalAmount + Constants.BITCOIN_DUST.ToDecimal(MoneyUnit.BTC))
                    {
                        ToastService.ShowError("The new fee plus the amount exceeds the sum of the selected UTXOs or returns dust. Please lower the fee rate.");
                        return;
                    }
                }

                // If the request is changeless and it has more than 1 output, show an error
                if (_selectedRequest.Changeless && _selectedRequest.WalletWithdrawalRequestDestinations!.Count > 1)
                {
                    ToastService.ShowError("Fee bumping is not supported for changeless transactions. Please create a new withdrawal with higher fees instead.");
                    return;
                }
                
                await Bumpfee(newRequest);
                await _bumpfeeRef.HideModal();
            }
            else
            {
                ToastService.ShowError("Something went wrong");
            }
        }
        catch (Exception)
        {
            ToastService.ShowError($"Something went wrong");
            await _bumpfeeRef.HideModal();
        }
    }

    private async Task<long> GetRecommendedFeeRate(MempoolRecommendedFeesType feeType)
    {
        return (long?)await NBXplorerService.GetFeesByType(feeType) ?? 1;
    }

    
    private async Task ApproveRequestDelegate()
    {
        if (_selectedRequest != null)
        {
            _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);
            await Approve();
        }
    }

    private async Task RejectOrCancel()
    {
        if ((_rejectCancelStatus == WalletWithdrawalRequestStatus.Cancelled || _rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
            && _selectedRequest != null)
        {
            _selectedRequest.RejectCancelDescription = _rejectCancelModalRef.Reason;
            _selectedRequest.Status = (WalletWithdrawalRequestStatus) _rejectCancelStatus;

            var updateResult = WalletWithdrawalRequestRepository.Update(_selectedRequest);

            if (updateResult.Item1 == false)
            {
                ToastService.ShowError("Something went wrong");
            }

            await HideRejectCancelModal();
        }
    }

    private async Task HideRejectCancelModal()
    {
        _rejectCancelStatus = null;
        _selectedRequest = null;
        _selectedRequestWalletBalance = 0;
        await GetData();
        await _rejectCancelModalRef.CloseModal();
    }

    private async Task ShowRejectCancelModal(WalletWithdrawalRequest walletWithdrawalRequest, WalletWithdrawalRequestStatus walletWithdrawalRequestStatus)
    {
        _rejectCancelStatus = walletWithdrawalRequestStatus;
        _selectedRequest = walletWithdrawalRequest;

        await _rejectCancelModalRef.ShowModal();
    }

    private async Task OnSelectedWallet(CellEditContext<WalletWithdrawalRequest> context, int id)
    {
        context.CellValue = id;

        var wallet = _availableWallets.SingleOrDefault(x => x.Id == id);
        _selectedWalletId = id == 0 ? null : id;
        if (wallet != null)
        {
            var (balance, _) = await BitcoinService.GetWalletConfirmedBalance(wallet);
            _selectedRequestWalletBalance = balance;
            if (_isCheckedAllFunds)
            {
                _amount = balance;
            }
        }
    }

    private async Task OpenCoinSelectionModal()
    {
        _utxoSelectorModalRef.ShowModal(_selectedWalletId.Value);
    }

    private void ClearSelectedUTXOs()
    {
        _utxoSelectorModalRef.ClearModal();
        _selectedUTXOs.Clear();
        StateHasChanged();
    }

    private void RejectReasonValidator(ValidatorEventArgs e)
    {
        if (_rejectCancelStatus == WalletWithdrawalRequestStatus.Rejected)
        {
            ValidationRule.IsNotEmpty(e);
        }
        else
        {
            ValidationRule.None(e);
        }
    }

    private async Task CloseConfirmationModal()
    {
        await _confirmationModal.CloseModal();
    }

    private async Task SubmitConfirmationModal()
    {
        async Task CleanUp(string errorMessage)
        {
            ToastService.ShowError(errorMessage);
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
        }

        if (_selectedRequest != null)
        {
            try
            {   
                _selectedRequest.Wallet = null;
                _selectedRequest.WithdrawAllFunds = _isCheckedAllFunds || _amount == _selectedRequestWalletBalance;
                _selectedRequest.MempoolRecommendedFeesType = _selectedMempoolRecommendedFeesType;
                _selectedRequest.CustomFeeRate = _customSatPerVbAmount;
                
                var createWithdrawalResult = await WalletWithdrawalRequestRepository.AddAsync(_selectedRequest);
                if (!createWithdrawalResult.Item1)
                {
                    throw new ShowToUserException(createWithdrawalResult.Item2);
                }

                if (_selectedRequest.BumpingWalletWithdrawalRequestId != null)
                {
                    await CopyBumpedRequestData(_selectedRequest);
                }

                _selectedRequest.Changeless = _selectedUTXOs.Count > 0;

                ToastService.ShowSuccess("Withdrawal request created!");

                if (_selectedUTXOs.Count > 0)
                {
                    await CoinSelectionService.LockUTXOs(_selectedUTXOs, _selectedRequest, BitcoinRequestType.WalletWithdrawal);
                }

                var templatePsbt = await BitcoinService.GenerateTemplatePSBT(_selectedRequest);

                var walletWithdrawalRequestPsbt = new WalletWithdrawalRequestPSBT()
                {
                    WalletWithdrawalRequestId = _selectedRequest.Id,
                    PSBT = templatePsbt.ToBase64(),
                    SignerId = null,
                };

                var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

                if (!addResult.Item1)
                {
                    throw new ShowToUserException("Error while saving the signature");
                }

                ToastService.ShowSuccess("Signature collected");

                _selectedRequest = await WalletWithdrawalRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && _selectedRequest.AreAllRequiredHumanSignaturesCollected)
                {
                    await CreateJob();
                }
                else
                {
                    throw new ShowToUserException("Invalid PSBT");
                }

                await GetData();
                _allRequestsDatagrid.Dispose();
                StateHasChanged();
                await _confirmationModal.CloseModal();
            }
            catch (NoUTXOsAvailableException e)
            {
                CleanUp("No UTXOs available for withdrawals were found for this wallet");
                await ResetStatusBumpedIfError(_selectedRequest);
            }
            catch (ShowToUserException e)
            {
                CleanUp(e.Message);
                await ResetStatusBumpedIfError(_selectedRequest);
            }
            catch
            {
                CleanUp("Something went wrong");
                await ResetStatusBumpedIfError(_selectedRequest);
            }
        }
    }

    private async Task ResetStatusBumpedIfError(WalletWithdrawalRequest request)
    {
        if (request.BumpingWalletWithdrawalRequestId != null)
        {
            var bumpedRequest = await WalletWithdrawalRequestRepository.GetById(request.BumpingWalletWithdrawalRequestId.Value);

            if (bumpedRequest != null)
            {
                bumpedRequest.Status = WalletWithdrawalRequestStatus.OnChainConfirmationPending;
                var updateResult = WalletWithdrawalRequestRepository.Update(bumpedRequest);
                if (!updateResult.Item1)
                {
                    ToastService.ShowError("Error while updating the bumped request, please contact a superadmin for troubleshooting");
                    return;
                }
            }
        }
    }

    private async Task CreateJob()
    {
        try
        {
            var scheduler = await SchedulerFactory.GetScheduler();

            var map = new JobDataMap();
            map.Put("withdrawalRequestId", _selectedRequest.Id);

            var job = SimpleJob.Create<PerformWithdrawalJob>(map, _selectedRequest.Id.ToString());
            await scheduler.ScheduleJob(job.Job, job.Trigger);

            if (_selectedRequest != null)
            {
                WalletWithdrawalRequestRepository.Update(_selectedRequest);
            }
        }
        catch
        {
            ToastService.ShowError("Error while requesting a withdrawal, please contact a superadmin for troubleshooting");
            _selectedRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(_selectedRequest);
            await _confirmationModal.CloseModal();
            await GetData();
            StateHasChanged();
            return;
        }
    }

    private async Task<bool> ShowActionDropdown(WalletWithdrawalRequest walletWithdrawalRequest)
    {
        ulong confirmations = 0;
        if (!string.IsNullOrEmpty(walletWithdrawalRequest.TxId))
        {
            try
            {
                var nbxplorerStatus = await NBXplorerService.GetTransactionAsync(uint256.Parse(walletWithdrawalRequest.TxId));
                confirmations = (ulong)(nbxplorerStatus?.Confirmations ?? throw new Exception("Failed to get confirmations"));
                return walletWithdrawalRequest.Status == WalletWithdrawalRequestStatus.OnChainConfirmationPending && confirmations.Equals((ulong) 0);
            }
            catch (Exception)
            {
                ToastService.ShowError("Error while showing bumpfee action");
                return false;
            }
        }

        return false;
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsPendingRequestsColumnVisible(ColumnDefault column)
    {
        if (_pendingRequestsColumnLayout == null)
        {
            return true;
        }

        return _pendingRequestsColumnLayout.IsColumnVisible(column);
    }

    private bool IsAllRequestsColumnVisible(ColumnDefault column)
    {
        if (_allRequestsColumnLayout == null)
        {
            return true;
        }

        return _allRequestsColumnLayout.IsColumnVisible(column);
    }

    private async Task OnShowNewWalletWithdrawalModal()
    {
        _selectedMempoolRecommendedFeesType = MempoolRecommendedFeesType.FastestFee;
        await OnMempoolFeeRateChange(_selectedMempoolRecommendedFeesType);

        _amount = _minimumWithdrawalAmount;
    }

    private void OnDestinationAddressChanged(CellEditContext<WalletWithdrawalRequest> context, string text)
    {
        context.CellValue = new List<WalletWithdrawalRequestDestination> { new() { Address = text, Amount = 0m } };
    }

    private string GetDestinationAddressFromCellValue(object cellValue)
    {
        if (cellValue is List<WalletWithdrawalRequestDestination> destinations && destinations.Any())
        {
            return destinations.First().Address ?? string.Empty;
        }
        return string.Empty;
    }

    private bool CustomRequestorFilter(object itemvalue, object searchvalue)
    {
        if (searchvalue is not string search || string.IsNullOrWhiteSpace(search))
        {
            return true;
        }

        if (itemvalue is string metadata)
        {
            try
            {
            var requestMetadata = JsonSerializer.Deserialize<Dictionary<string, string>>(metadata);
            if (requestMetadata != null && requestMetadata.TryGetValue("userName", out var userName))
            {
                return userName.Contains(search, StringComparison.OrdinalIgnoreCase);
            }
            }
            catch (JsonException)
            {
                // If deserialization fails, we assume the filter does not match
                return false;
            }
        }

        return false;
    }
    
    private async Task CopyBumpedRequestData(WalletWithdrawalRequest request)
    {
        WalletWithdrawalRequest originalRequest = await WalletWithdrawalRequestRepository.GetById((int)request.BumpingWalletWithdrawalRequestId);
        if (originalRequest == null)
        {
            throw new ShowToUserException("Original withdrawal request not found");
        }

        // Get destinations from the original request
        List<WalletWithdrawalRequestDestination> originalDestinations = await WalletWithdrawalRequestDestinationRepository.GetByWalletWithdrawalRequestId(originalRequest.Id);
        if (originalDestinations == null || originalDestinations.Count == 0)
        {
            throw new ShowToUserException("Original withdrawal request destinations not found");
        }

        request.WalletWithdrawalRequestDestinations = originalDestinations.Select(d => new WalletWithdrawalRequestDestination
            {
                Address = d.Address,
                Amount = d.Amount,
                WalletWithdrawalRequestId = request.Id
            }).ToList();

        // Get utxos from the original request
        List<FMUTXO> mUTXOs = await FMUTXORepository.GetLockedUTXOsByWithdrawalId(originalRequest.Id);

        request.UTXOs = mUTXOs;
        List<OutPoint> outpoints = new List<OutPoint>();
        mUTXOs.ForEach(u => {
            OutPoint o;
            if (OutPoint.TryParse($"{u.TxId}:{u.OutputIndex}", out o))
                outpoints.Add(o);
            else
                throw new FormatException("Failed to parse OutPoint from TxId and OutputIndex");
        });
        _selectedUTXOs = await CoinSelectionService.GetUTXOsByOutpointAsync(originalRequest.Wallet.GetDerivationStrategy(), outpoints);
        originalRequest.Status = WalletWithdrawalRequestStatus.Bumped;

        var updateResult = WalletWithdrawalRequestRepository.Update(request);
        if (!updateResult.Item1)
        {
            ToastService.ShowError("Something went wrong");
            return;
        }

        updateResult = WalletWithdrawalRequestRepository.Update(originalRequest);
        if (!updateResult.Item1)
        {
            ToastService.ShowError("Something went wrong");
            return;
        }
    }
}
