@page "/nodes"
@using System.Security.Claims
@using System.Threading
@using NodeGuard.Jobs
@using Humanizer
@using Quartz

@attribute [Authorize(Roles = "FinanceManager, NodeManager, Superadmin")]
<PageTitle>Active Nodes</PageTitle>
<h3 class="custom-primary">Nodes</h3>

<Row>
    <Column ColumnSize="ColumnSize.Is12">
        <DataGrid TItem="Node"
                  Data="@_nodes"
                  Editable="@_editable"
                  EditMode="DataGridEditMode.Popup"
                  @bind-SelectedRow="@_selectedNode"
                  Responsive="true"
                  ResizeMode="TableResizeMode.Columns"
                  UseInternalEditing="true"
                  RowInserted="OnRowInserted"
                  RowUpdated="OnRowUpdated"
                  Filterable="true"
                  UseValidation="true">
            <PopupTitleTemplate>
                <h2>@(context.EditState) node</h2>
            </PopupTitleTemplate>
            <DataGridColumns>
    
                <DataGridCommandColumn TItem="Node" Filterable="false"  Editable="false" Width="60px">

                    <EditCommandTemplate>
                        <Dropdown @onclick:stopPropagation="true">
                            <DropdownToggle Color="Color.Primary">
                            </DropdownToggle>
                            <DropdownMenu>
                                <DropdownItem Clicked="context.Clicked">Edit</DropdownItem>
                                <DropdownItem Clicked="@(() => ShowDeleteDialog(context.Item))">Delete</DropdownItem>
                                <DropdownItem Clicked="@(() => ToggleNodeStatus(context.Item))">@_NodesState(context.Item)</DropdownItem>
                            </DropdownMenu>
                        </Dropdown>
                    </EditCommandTemplate>
                    <DeleteCommandTemplate/>
                    <NewCommandTemplate>
                        <Button Color="Color.Success" TextColor="TextColor.Light" Clicked="@context.Clicked" Block>New</Button>
                    </NewCommandTemplate>
                </DataGridCommandColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.Name)" Validator="ValidationHelper.ValidateName" Caption="@nameof(Node.Name)" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.Name)"/>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.PubKey)" Caption="@nameof(Node.PubKey)" Sortable="false" Width="220px" Displayable="@IsColumnVisible(NodesColumnName.PubKey)">
                    <DisplayTemplate>
                        @StringHelper.TruncateHeadAndTail(context.PubKey, 6)&nbsp;
                        @{State state = new("Copy", "oi oi-clipboard");}
                        <Button Color="Color.Primary" Size="Size.Small" Outline @onclick="@(() => CopyToClipboard(context.PubKey))" disabled=@state.IsDisabled>
                            <i class="@state.ClassName"></i>
                        </Button>
                    </DisplayTemplate>
                    <EditTemplate>
                        <Validation Validator="@((ValidatorEventArgs obj) => @ValidationHelper.ValidatePubKey(obj, _nodes, context.Item.PubKey))">
                            <TextEdit Text="@((string)context.CellValue)" TextChanged="(text) => { context.CellValue = text; }">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </TextEdit>
                        </Validation>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.Description)" Caption="@nameof(Node.Description)" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.Description)"/>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.ChannelAdminMacaroon)" Caption="LND Macaroon" CellsEditableOnNewCommand="true" CellsEditableOnEditCommand="true" Displayable="false" Sortable="false">
                    <DisplayTemplate>
                        @if (!string.IsNullOrEmpty(context.ChannelAdminMacaroon))
                        {
                            <span class="text-success">Macaroon configured</span>
                        }
                        else
                        {
                            <span class="text-muted">No macaroon</span>
                        }
                    </DisplayTemplate>
                    <EditTemplate>
                        <MemoEdit Rows="4" Text="" TextChanged="(text) => { if (!string.IsNullOrWhiteSpace(text)) context.CellValue = text; }" Placeholder="Base64 encoded macaroon (leave empty to keep existing)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </MemoEdit>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.Endpoint)" Validator="ValidationRule.IsNotEmpty" Caption="@nameof(Node.Endpoint)" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.Endpoint)"/>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.LoopdEndpoint)" Caption="Loopd Endpoint" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.LoopdEndpoint)">
                    <DisplayTemplate>
                        @if (context.LoopdEndpoint != null)
                        {
                            <span>@context.LoopdEndpoint</span>
                        }
                        else
                        {
                            <span class="text-muted">Not configured</span>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true" Field="@nameof(Node.FortySwapEndpoint)" Caption="40swapd Endpoint" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.FortySwapEndpoint)">
                    <DisplayTemplate>
                        @if (context.FortySwapEndpoint != null)
                        {
                            <span>@context.FortySwapEndpoint</span>
                        }
                        else
                        {
                            <span class="text-muted">Not configured</span>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true"
                    Field="@nameof(Node.LoopdMacaroon)" Caption="Loopd Macaroon"
                    CellsEditableOnNewCommand="true" CellsEditableOnEditCommand="true" Displayable="false"
                    Sortable="false">
                    <DisplayTemplate>
                        @if (!string.IsNullOrEmpty(context.LoopdMacaroon))
                        {
                            <span class="text-success">Macaroon configured</span>
                        }
                        else
                        {
                            <span class="text-muted">No macaroon</span>
                        }
                    </DisplayTemplate>
                    <EditTemplate>
                        <MemoEdit Rows="4" Text="@((string)context.CellValue)" TextChanged="(text) => { context.CellValue = text; }" Placeholder="Base64 encoded macaroon">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </MemoEdit>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="true"
                    Field="@nameof(Node.LoopdCert)" Caption="Loopd Certificate"
                    CellsEditableOnNewCommand="true" CellsEditableOnEditCommand="true" Displayable="@IsColumnVisible(NodesColumnName.LoopdCert)"
                    Sortable="false">
                    <DisplayTemplate>
                        @if (!string.IsNullOrEmpty(context.LoopdCert))
                        {
                            <span class="text-success">Certificate configured</span>
                        }
                        else
                        {
                            <span class="text-muted">No certificate</span>
                        }
                    </DisplayTemplate>
                    <EditTemplate>
                        <MemoEdit Rows="4" Text="@((string)context.CellValue)" TextChanged="(text) => { context.CellValue = text; }" Placeholder="Base64 encoded certificate">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </MemoEdit>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridNumericColumn TItem="Node" Filterable="false" Editable="false" Caption="Outbound Open Channels" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.OutboundOpenChannels)">
                    <DisplayTemplate>
                        @{
                            IEnumerable<int?> associatedChannels = context?.ChannelOperationRequestsAsDestination?
                                .Where(request => request.ChannelId != null)
                                .Select(channel => channel.ChannelId)
                                .Distinct();
                            @($"{associatedChannels?.Count()}")
                        }
                    </DisplayTemplate>
                </DataGridNumericColumn>
                <DataGridColumn TItem="Node" Filterable="false" Editable="false" Field="@nameof(Node.IsNodeDisabled)" Caption="Disabled" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.Disabled)"></DataGridColumn>
                
                <DataGridColumn TItem="Node" Filterable="false" Caption="Liquidity Config" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.AutoLiquidityManagement)">
                    <DisplayTemplate>
                        <Button Color="Color.Primary" Clicked="@(() => ShowLiquidityManagementModal(context))" Block>Manage</Button>
                    </DisplayTemplate>
                </DataGridColumn>
                
                <DataGridColumn TItem="Node" Filterable="false" Field="@nameof(Node.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsColumnVisible(NodesColumnName.CreationDate)">
                    <DisplayTemplate>
                        @context.CreationDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Field="@nameof(Node.UpdateDatetime)" Caption="Update date" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.UpdateDate)">
                    <DisplayTemplate>
                        @context.UpdateDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Filterable="false" Caption="@nameof(Node.Users)" Editable="false" CellsEditableOnEditCommand="false" Sortable="false" Displayable="@IsColumnVisible(NodesColumnName.Users)">
                    <DisplayTemplate>
                        <Button Color="Color.Primary" Clicked="@ShowModal" Block>Display Users</Button>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Node" Displayable="true">
                    <FilterTemplate>
                        <ColumnLayout @ref="NodesColumnLayout" Columns="@NodesColumns" ColumnType="NodesColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                    </FilterTemplate>
                </DataGridColumn>
            </DataGridColumns>
        </DataGrid>
    </Column>
</Row>
<Modal @bind-Visible="@_modalVisible" >
    <ModalContent Centered Size="ModalSize.Large">
        <ModalHeader>
            <ModalTitle>Users assigned to Node: @_selectedNode?.Name</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
           <DataGrid TItem="ApplicationUser"
                     Data=@_selectedNode?.Users
                     Sortable="false"
                     ShowCaptions="true">
               <DataGridColumn Field="@nameof(ApplicationUser.Id)" Caption="@nameof(ApplicationUser.Id)" />
               <DataGridColumn Field="@nameof(ApplicationUser.UserName)" Caption="@nameof(ApplicationUser.UserName)" />
           </DataGrid>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@HideModal">Back</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_nodeLiquidityModal">
    @if (_selectedNodeForLiquidity != null)
    {
        <ModalContent Centered Scrollable Size="ModalSize.ExtraLarge">
            <ModalHeader>
                <ModalTitle>Liquidity management for node: @_selectedNodeForLiquidity.Name </ModalTitle>
                <CloseButton/>
            </ModalHeader>
            <ModalBody>
                <Validations @ref="_nodeLiquidityValidationsRef">                    
                    <Field>
                        <FieldLabel>Autosweep</FieldLabel>
                        <FieldHelp>Automatically sweep channel closing funds to the destination wallet</FieldHelp>
                        <Check TValue="bool" Checked="@_selectedNodeForLiquidity.AutosweepEnabled" CheckedChanged="@((value) => _selectedNodeForLiquidity.AutosweepEnabled = value)">
                            Enable automatic sweep of funds
                        </Check>
                    </Field>
                    
                    <Field>
                        <Validation Validator="ValidationRule.IsSelected">
                            <FieldLabel>Funds Destination Wallet</FieldLabel>
                            <FieldHelp>Wallet to receive on-chain funds from channel closings and swap operations</FieldHelp>
                            <SelectList TItem="Wallet"
                                        TValue="int"
                                        Data="@_availableWallets"
                                        SelectedValue="_selectedNodeForLiquidity.FundsDestinationWalletId ?? 0"
                                        TextField="@((item) => item.Name)"
                                        ValueField="@((item) => item.Id)"
                                        SelectedValueChanged="@OnSelectedFundsDestinationWalletChanged"
                                        DefaultItemText="Choose the destination wallet">
                                <Feedback>
                                    <ValidationError>A destination wallet must be selected</ValidationError>
                                </Feedback>
                            </SelectList>
                        </Validation>
                    </Field>
                    
                    <Divider Text="Automatic Liquidity Management" TextAlignment="TextAlignment.Start" Type="DividerType.Dashed" />
                    
                    <Field>
                        <FieldLabel>Automatic Liquidity Management</FieldLabel>
                        <FieldHelp>Enables automatic swap outs based on balance thresholds and configuration below</FieldHelp>
                        <Check TValue="bool" Checked="@_selectedNodeForLiquidity.AutoLiquidityManagementEnabled" CheckedChanged="OnEnableAutoLiquidityChanged">
                            Enable automatic liquidity management
                        </Check>
                    </Field>
                    
                    @if (_selectedNodeForLiquidity.AutoLiquidityManagementEnabled)
                    {
                        <Divider Text="Swap Provider Selection Weights" TextAlignment="TextAlignment.Start" Type="DividerType.Dashed" />
                        
                        <Alert Color="Color.Info" Visible="true">
                            <AlertDescription>Configure weights for each swap provider (must sum to 100). Higher weight = higher probability of selection. Set to 0 to disable a provider.</AlertDescription>
                        </Alert>
                        
                        <Row>
                            <Column>
                                <Field>
                                    <Validation Validator="ValidateProviderWeights">
                                        <FieldLabel>Loop Weight</FieldLabel>
                                        <FieldHelp>Weight for Loop provider (0-100, must sum to 100 with 40swap)</FieldHelp>
                                        <NumericEdit TValue="int" 
                                                     @bind-Value="@_selectedNodeForLiquidity.LoopSwapWeight" 
                                                     Min="0"
                                                     Max="100">
                                            <Feedback>
                                                <ValidationError />
                                            </Feedback>
                                        </NumericEdit>
                                        @if (string.IsNullOrEmpty(_selectedNodeForLiquidity.LoopdEndpoint) && _selectedNodeForLiquidity.LoopSwapWeight > 0)
                                        {
                                            <FieldHelp>
                                                <Badge Color="Color.Warning">⚠️ Loop endpoint not configured</Badge>
                                            </FieldHelp>
                                        }
                                    </Validation>
                                </Field>
                            </Column>
                            <Column>
                                <Field>
                                    <Validation Validator="ValidateProviderWeights">
                                        <FieldLabel>40swap Weight</FieldLabel>
                                        <FieldHelp>Weight for 40swap provider (0-100, must sum to 100 with Loop)</FieldHelp>
                                        <NumericEdit TValue="int" 
                                                     @bind-Value="@_selectedNodeForLiquidity.FortySwapWeight" 
                                                     Min="0"
                                                     Max="100">
                                            <Feedback>
                                                <ValidationError />
                                            </Feedback>
                                        </NumericEdit>
                                        @if (string.IsNullOrEmpty(_selectedNodeForLiquidity.FortySwapEndpoint) && _selectedNodeForLiquidity.FortySwapWeight > 0)
                                        {
                                            <FieldHelp>
                                                <Badge Color="Color.Warning">⚠️ 40swap endpoint not configured</Badge>
                                            </FieldHelp>
                                        }
                                    </Validation>
                                </Field>
                            </Column>
                        </Row>
                        
                        <Divider Text="Swap Configuration" TextAlignment="TextAlignment.Start" Type="DividerType.Dashed" />
                        
                        <Row>
                            <Column>
                                <Field>
                                    <Validation Validator="ValidateMinSwapSize">
                                        <FieldLabel>Min Swap Size</FieldLabel>
                                        <FieldHelp>Minimum amount for each swap (must be ≥ @Constants.MINIMUM_SWAP_OUT_SIZE_BTC BTC)</FieldHelp>
                                        <NumericPicker TValue="decimal" 
                                                       @bind-Value="@_minSwapSizeBtc" 
                                                       CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix"
                                                       CurrencySymbol=" BTC"
                                                       Decimals="8"
                                                       Step="0.01m"
                                                       Min="@Constants.MINIMUM_SWAP_OUT_SIZE_BTC"
                                                       Max="@Constants.MAXIMUM_SWAP_OUT_SIZE_BTC">
                                            <Feedback>
                                                <ValidationError>Min swap size must be ≥ @Constants.MINIMUM_SWAP_OUT_SIZE_BTC BTC and ≤ max swap size</ValidationError>
                                            </Feedback>
                                        </NumericPicker>
                                    </Validation>
                                </Field>
                            </Column>
                            <Column>
                                <Field>
                                    <Validation Validator="ValidateMaxSwapSize">
                                        <FieldLabel>Max Swap Size</FieldLabel>
                                        <FieldHelp>Maximum amount for each swap (must be ≤ @Constants.MAXIMUM_SWAP_OUT_SIZE_BTC BTC)</FieldHelp>
                                        <NumericPicker TValue="decimal" 
                                                       @bind-Value="@_maxSwapSizeBtc" 
                                                       CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix"
                                                       CurrencySymbol=" BTC"
                                                       Decimals="8"
                                                       Step="0.01m"
                                                       Min="@Constants.MINIMUM_SWAP_OUT_SIZE_BTC"
                                                       Max="@Constants.MAXIMUM_SWAP_OUT_SIZE_BTC">
                                            <Feedback>
                                                <ValidationError>Max swap size must be ≤ @Constants.MAXIMUM_SWAP_OUT_SIZE_BTC BTC and ≥ min swap size</ValidationError>
                                            </Feedback>
                                        </NumericPicker>
                                    </Validation>
                                </Field>
                            </Column>
                        </Row>
                        <Row>
                            <Column>
                                <Field>
                                        <FieldLabel>Max Swaps in Flight</FieldLabel>
                                        <FieldHelp>Maximum concurrent swaps (0-100) to limit HTLC locking</FieldHelp>
                                        <NumericEdit TValue="int" @bind-Value="_selectedNodeForLiquidity.MaxSwapsInFlight" Min="0" Max="100">
                                            <Feedback>
                                                <ValidationError>Must be between 0 and 100</ValidationError>
                                            </Feedback>
                                        </NumericEdit>
                                </Field>
                            </Column>
                            <Column>
                                <Field>
                                        <FieldLabel>Max Swap Routing Fee</FieldLabel>
                                        <FieldHelp>Maximum acceptable routing fee as percentage</FieldHelp>
                                        <NumericPicker TValue="decimal" 
                                                       @bind-Value="@_maxSwapRoutingFeePercent" 
                                                       CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix"
                                                       CurrencySymbol=" %"
                                                       Decimals="2"
                                                       Step="0.1m"
                                                       Min="0M" 
                                                       Max="100M">
                                            <Feedback>
                                                <ValidationError>Fee percent must be between 0 and 100</ValidationError>
                                            </Feedback>
                                        </NumericPicker>
                                </Field>
                            </Column>
                        </Row>
                        <Field>
                                <FieldLabel>Balance Threshold</FieldLabel>
                                <FieldHelp>Trigger swap out when node balance exceeds this threshold</FieldHelp>
                                <NumericPicker TValue="decimal" 
                                               @bind-Value="@_balanceThresholdBtc" 
                                               CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix"
                                               CurrencySymbol=" BTC"
                                               Decimals="8"
                                               Step="0.1m"
                                               Min="0M">
                                    <Feedback>
                                        <ValidationError>Balance threshold must be ≥ 0</ValidationError>
                                    </Feedback>
                                </NumericPicker>
                        </Field>
                        <Row>
                            <Column>
                                <Field>
                                        <FieldLabel>Swap Budget</FieldLabel>
                                        <FieldHelp>Maximum budget per refresh period</FieldHelp>
                                        <NumericPicker TValue="decimal" 
                                                       @bind-Value="@_swapBudgetBtc" 
                                                       CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix"
                                                       CurrencySymbol=" BTC"
                                                       Decimals="8"
                                                       Step="0.1m"
                                                       Min="0M">
                                            <Feedback>
                                                <ValidationError>Budget must be ≥ 0</ValidationError>
                                            </Feedback>
                                        </NumericPicker>
                                </Field>
                            </Column>
                            <Column>
                                <Field>
                                        <FieldLabel>Budget Refresh Interval (days)</FieldLabel>
                                        <FieldHelp>Period after which swap budget is refreshed (minimum 1 day)</FieldHelp>
                                        <NumericEdit TValue="int" @bind-Value="@_budgetRefreshDays" Min="1">
                                            <Feedback>
                                                <ValidationError>Interval must be ≥ 1 day</ValidationError>
                                            </Feedback>
                                        </NumericEdit>
                                </Field>
                            </Column>
                        </Row>
                    }
                </Validations>
            </ModalBody>
            <ModalFooter>
                <Button Color="Color.Secondary" Clicked="@CloseLiquidityManagementModal">Cancel</Button>
                <Button Color="Color.Primary" Clicked="@SaveAndCloseLiquidityManagementModal">Save</Button>
            </ModalFooter>
        </ModalContent>
    }
</Modal>

@inject INodeRepository NodeRepository
@inject IToastService ToastService;
@inject ClipboardService ClipboardService
@inject IMessageService MessageService
@inject IWalletRepository WalletRepository
@inject ISchedulerFactory  SchedulerFactory
@inject ILocalStorageService LocalStorageService
@implements IDisposable
@code {
    private List<Node>? _nodes;
    private Node? _selectedNode;
    private bool _modalVisible;
    private bool _hideDelete = true;
    private bool _editable;
    private List<Wallet> _availableWallets = new();

    CancellationTokenSource cts = new();

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private ColumnLayout<NodesColumnName> NodesColumnLayout;
    private Dictionary<string, bool> NodesColumns = new();
    private bool columnsLoaded;
    
    // Liquidity management modal
    private Modal? _nodeLiquidityModal;
    private Node? _selectedNodeForLiquidity;
    private Validations? _nodeLiquidityValidationsRef;
    
    // BTC conversion fields for easier editing
    private decimal _minSwapSizeBtc;
    private decimal _maxSwapSizeBtc;
    private decimal _balanceThresholdBtc;
    private decimal _swapBudgetBtc;
    private int _budgetRefreshDays;
    private decimal _maxSwapRoutingFeePercent;

    public abstract class NodesColumnName
    {
        public static readonly ColumnDefault Name = new("Name");
        public static readonly ColumnDefault PubKey = new("PubKey");
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault Endpoint = new("Endpoint");
        public static readonly ColumnDefault OutboundOpenChannels = new("Outbound Open Channels");
        public static readonly ColumnDefault FundsDestinationWallet = new("Funds Destination Wallet");
        public static readonly ColumnDefault Disabled = new("Disabled");
        public static readonly ColumnDefault Autosweep = new("Autosweep");
        public static readonly ColumnDefault AutoLiquidityManagement = new("Auto Liquidity Management");
        public static readonly ColumnDefault SwapMinAmount = new("Min Swap Amount",false);
        public static readonly ColumnDefault SwapMaxAmount = new("Max Swap Amount",false);
        public static readonly ColumnDefault MaxSwapsInFlight = new("Max Swaps In Flight",false);
        public static readonly ColumnDefault MaxSwapFeeRatio = new("Max Swap Fee Ratio",false);
        public static readonly ColumnDefault MinimumBalanceThreshold = new("Minimum Balance Threshold",false);
        public static readonly ColumnDefault SwapBudget = new("Swap Budget",false);
        public static readonly ColumnDefault SwapBudgetRefreshInterval = new("Budget Refresh Interval",false);
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
        public static readonly ColumnDefault Users = new("Users");
        public static readonly ColumnDefault LoopdEndpoint = new("Loopd Endpoint");
        public static readonly ColumnDefault LoopdCert = new("Loopd Certificate");
        public static readonly ColumnDefault FortySwapEndpoint = new("40swap Endpoint");
    }

    protected override async Task OnInitializedAsync()
    {
        if (LoggedUser != null)
        {
            await GetData();

            if (ClaimsPrincipal != null &&
                (ClaimsPrincipal.IsInRole(ApplicationUserRole.Superadmin.ToString())
                 || ClaimsPrincipal.IsInRole(ApplicationUserRole.NodeManager.ToString())))
            {
                _editable = true;
                _hideDelete = false;
            }
        }
    }
    
    private string _NodesState(Node node)
    {
        return node.IsNodeDisabled ?  "Enable Node" : "Disable Node";
    }
    
    private async Task ToggleNodeStatus(Node node)
    {
        try
        {
            node.IsNodeDisabled = !node.IsNodeDisabled;
            if (node.IsNodeDisabled)
            {
                await StopJob(node);
            }
            else
            {
                await CreateJobs(node);
            }
            var (result, _) = NodeRepository.Update(node);
            if (result)
            {
                _nodes = await NodeRepository.GetAllManagedByNodeGuard();
                _availableWallets = await WalletRepository.GetAvailableWallets();
                string status = node.IsNodeDisabled ? "disabled": "enabled";
                string message = $"{node.Name} is {status}";
                ToastService.ShowSuccess(message);
            }
            else
            {
                ToastService.ShowError($"Error while disabling the {node.Name}, please contact a superadmin for troubleshooting");
            }
        }
        catch
        {
            ToastService.ShowError($"Error while disabling {node.Name}, please contact a superadmin for troubleshooting");
        }
    }

    private async Task GetData()
    {
        _nodes = await NodeRepository.GetAllManagedByNodeGuard();
        _availableWallets = await WalletRepository.GetAvailableWallets(false);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !columnsLoaded)
        {
            await LoadColumnLayout();

        }
    }

    private async Task LoadColumnLayout()
    {
        NodesColumns = await LocalStorageService.LoadStorage(nameof(NodesColumnName), ColumnHelpers.GetColumnsDictionary<NodesColumnName>());
        columnsLoaded = true;
        StateHasChanged();
    }

    private async Task OnRowInserted(SavedRowItem<Node, Dictionary<string, object>> arg)
    {
        if (arg.Item == null)
        {
            ToastService.ShowError("Couldn't fetch data");
        }
        else
        {
            Node newNode = arg.Item as Node;
            (bool, string?) addResult;
            var restoredNode = await NodeRepository.GetByPubkey(arg.Item.PubKey);
            if (restoredNode != null)
            {
                newNode.Id = restoredNode.Id;
                newNode.CreationDatetime = restoredNode.CreationDatetime;
                addResult =  NodeRepository.Update(newNode);
            }
            else
            {
                addResult = await NodeRepository.AddAsync(arg.Item);
            }
            if (addResult.Item1)
            {
                ToastService.ShowSuccess($"Node {arg.Item.Name} Created");
                _nodes = await NodeRepository.GetAll();
                await CreateJobs(arg.Item);
            }
            else
            {
                ToastService.ShowError("Something went wrong");
                _nodes?.Remove(arg.Item);
            }
        }
        await GetData();
    }

    private async Task OnRowUpdated(SavedRowItem<Node, Dictionary<string, object>> arg)
    {
        if (arg.Item == null)
        {
            ToastService.ShowError("Couldn't fetch data");
        }
        else
        {
            arg.Item.UpdateDatetime = DateTimeOffset.Now;
            var updateResult = NodeRepository.Update(arg.Item);
            if (updateResult.Item1)
            {
                ToastService.ShowSuccess($"Node {arg.Item.Name} Updated");
            }
            else
            {
                ToastService.ShowError("Something went wrong");
            }
        }
        await GetData();
    }

    private void ShowModal()
    {
        _modalVisible = true;
    }

    private void HideModal()
    {
        _modalVisible = false;
    }

    private async Task CopyToClipboard(String pubkey)
    {
        await ClipboardService.WriteTextAsync(pubkey);
        ToastService.ShowSuccess("Text copied");
    }

    public void Dispose()
    {
        cts.Cancel(); // Cancel Task.Delay
        cts.Dispose();
    }

    private async Task ShowDeleteDialog(Node node)
    {
        if (await MessageService.Confirm($"Are you sure you want to delete { node.Name }?", "Confirmation"))
        {
            if (node != null)
            {
                node.IsNodeDisabled = true;
                node.Endpoint = null;
                node.ChannelAdminMacaroon = null;
                var (result, _) = NodeRepository.Update(node);
                if (!result)
                {
                    ToastService.ShowError($"{node.Name} could not be deleted");
                }
                else
                {
                    ToastService.ShowSuccess($"{node.Name} deleted successfully");
                    _nodes = await NodeRepository.GetAll();

                }
                await StopJob(node);
            }
        }

        await GetData();

    }


    private async Task StopJob(Node node)
    {
        try
        {
            IScheduler scheduler = await SchedulerFactory.GetScheduler();
            
            await SimpleJob.DeleteJob<NodeChannelSuscribeJob>(scheduler, node.Id.ToString());
            await SimpleJob.DeleteJob<ProcessNodeChannelAcceptorJob>(scheduler, node.Id.ToString());
            
        }
        catch
        {
            ToastService.ShowError("Error while stopping jobs, please contact a superadmin for troubleshooting");
        }
    }

    private async Task CreateJobs(Node node)
    {
        try
        {
            IScheduler scheduler = await SchedulerFactory.GetScheduler();
           
            await UpsertJob<ProcessNodeChannelAcceptorJob>(scheduler, node, map =>
            {
                map.Put("managedNodeId", node.Id.ToString());
            });
            
            await UpsertJob<NodeChannelSuscribeJob>(scheduler, node, map =>
            {
                map.Put("nodeId", node.Id);
            });
            
            ToastService.ShowSuccess("Node subscription job created");
        }
        
        catch
        {
            ToastService.ShowError("Error while requesting to open the channel, please contact a superadmin for troubleshooting");
        }
    }

    private async Task UpsertJob<TJob>(IScheduler scheduler, Node node, Action<JobDataMap> configureMap) where TJob : IJob
    {
        var isJobExists = await SimpleJob.IsJobExists<TJob>(scheduler, node.Id.ToString());

        if (isJobExists)
        {
            await SimpleJob.Reschedule<TJob>(scheduler, node.Id.ToString());
        }
        else
        {
            var map = new JobDataMap();
            configureMap(map);

            var job = SimpleJob.Create<TJob>(map, node.Id.ToString());

            await scheduler.ScheduleJob(job.Job, job.Trigger);

            var (result, _) = NodeRepository.Update(node);
            if (!result)
            {
                ToastService.ShowError($"Error while subscribing to job for node {node.Name}");
            }
        }
    }

    record State(string Text, string ClassName, bool IsDisabled = false);

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsColumnVisible(ColumnDefault column)
    {
        if (NodesColumnLayout	== null)
        {
            return true;
        }
        return NodesColumnLayout.IsColumnVisible(column);
    }

    // Liquidity Management Modal Methods
    private async Task ShowLiquidityManagementModal(Node node)
    {
        _selectedNodeForLiquidity = node;
        
        // Convert sats to BTC for display
        _minSwapSizeBtc = (decimal)new NBitcoin.Money(node.SwapMinAmountSats).ToUnit(NBitcoin.MoneyUnit.BTC);
        _maxSwapSizeBtc = (decimal)new NBitcoin.Money(node.SwapMaxAmountSats).ToUnit(NBitcoin.MoneyUnit.BTC);
        _balanceThresholdBtc = (decimal)new NBitcoin.Money(node.MinimumBalanceThresholdSats).ToUnit(NBitcoin.MoneyUnit.BTC);
        _swapBudgetBtc = (decimal)new NBitcoin.Money(node.SwapBudgetSats).ToUnit(NBitcoin.MoneyUnit.BTC);
        _budgetRefreshDays = node.SwapBudgetRefreshInterval.Days;
        // Convert ratio from 0-1 to 0-100 for display
        _maxSwapRoutingFeePercent = node.MaxSwapRoutingFeeRatio * 100m;
        
        if (_nodeLiquidityModal != null) await _nodeLiquidityModal.Show();
    }

    private async Task CloseLiquidityManagementModal()
    {
        if (_nodeLiquidityModal != null) await _nodeLiquidityModal.Close(CloseReason.UserClosing);
        _selectedNodeForLiquidity = null;
        await GetData();
    }

    private async Task SaveAndCloseLiquidityManagementModal()
    {
        if (_nodeLiquidityValidationsRef != null && await _nodeLiquidityValidationsRef.ValidateAll() && _selectedNodeForLiquidity != null)
        {

            // Convert BTC back to sats and percent back to ratio (0-1)
            _selectedNodeForLiquidity.SwapMinAmountSats = (long)new NBitcoin.Money(_minSwapSizeBtc, NBitcoin.MoneyUnit.BTC).Satoshi;
            _selectedNodeForLiquidity.SwapMaxAmountSats = (long)new NBitcoin.Money(_maxSwapSizeBtc, NBitcoin.MoneyUnit.BTC).Satoshi;
            _selectedNodeForLiquidity.MinimumBalanceThresholdSats = (long)new NBitcoin.Money(_balanceThresholdBtc, NBitcoin.MoneyUnit.BTC).Satoshi;
            _selectedNodeForLiquidity.SwapBudgetSats = (long)new NBitcoin.Money(_swapBudgetBtc, NBitcoin.MoneyUnit.BTC).Satoshi;
            _selectedNodeForLiquidity.SwapBudgetRefreshInterval = TimeSpan.FromDays(_budgetRefreshDays);
            // Convert percent (0-100) back to ratio (0-1)
            _selectedNodeForLiquidity.MaxSwapRoutingFeeRatio = _maxSwapRoutingFeePercent / 100m;
            
            _selectedNodeForLiquidity.UpdateDatetime = DateTimeOffset.Now;
            var updateResult = NodeRepository.Update(_selectedNodeForLiquidity);
            
            if (!updateResult.Item1)
            {
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess($"Node {_selectedNodeForLiquidity.Name} liquidity configuration updated successfully");
            }
            
            
            await CloseLiquidityManagementModal();
        }
    }

    private async Task OnEnableAutoLiquidityChanged(bool enabled)
    {
        if (_selectedNodeForLiquidity != null)
        {
            _selectedNodeForLiquidity.AutoLiquidityManagementEnabled = enabled;
        }
    }

    private async Task OnSelectedFundsDestinationWalletChanged(int walletId)
    {
        if (_selectedNodeForLiquidity != null)
        {
            _selectedNodeForLiquidity.FundsDestinationWalletId = walletId;
        }
    }

    // Validation methods
    private void ValidateMinSwapSize(ValidatorEventArgs arg)
    {
        arg.Status = ValidationStatus.Success;
        
        if (_minSwapSizeBtc < Constants.MINIMUM_SWAP_OUT_SIZE_BTC)
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = $"Min swap size must be at least {Constants.MINIMUM_SWAP_OUT_SIZE_BTC} BTC";
            return;
        }
        
        if (_minSwapSizeBtc > _maxSwapSizeBtc)
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = "Min swap size must be less than or equal to max swap size";
        }
    }

    private void ValidateMaxSwapSize(ValidatorEventArgs arg)
    {
        arg.Status = ValidationStatus.Success;
        
        if (_maxSwapSizeBtc > Constants.MAXIMUM_SWAP_OUT_SIZE_BTC)
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = $"Max swap size must be at most {Constants.MAXIMUM_SWAP_OUT_SIZE_BTC} BTC";
            return;
        }
        
        if (_maxSwapSizeBtc < _minSwapSizeBtc)
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = "Max swap size must be greater than or equal to min swap size";
        }
    }

    private void ValidateProviderWeights(ValidatorEventArgs arg)
    {
        arg.Status = ValidationStatus.Success;
        
        if (_selectedNodeForLiquidity == null) return;
        
        var totalWeight = _selectedNodeForLiquidity.LoopSwapWeight + _selectedNodeForLiquidity.FortySwapWeight;
        
        if (totalWeight != 100)
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = $"Weights must sum to 100 (current: {totalWeight})";
            return;
        }
        
        // Validate that providers with weight > 0 have their endpoints configured
        if (_selectedNodeForLiquidity.LoopSwapWeight > 0 && string.IsNullOrEmpty(_selectedNodeForLiquidity.LoopdEndpoint))
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = "Loop endpoint must be configured when Loop weight > 0";
            return;
        }
        
        if (_selectedNodeForLiquidity.FortySwapWeight > 0 && string.IsNullOrEmpty(_selectedNodeForLiquidity.FortySwapEndpoint))
        {
            arg.Status = ValidationStatus.Error;
            arg.ErrorText = "40swap endpoint must be configured when 40swap weight > 0";
            return;
        }
    }


}