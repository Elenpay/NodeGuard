@page "/channel-requests"
@using System.Security.Claims
@using Blazorise.Extensions
@using Quartz
@using Humanizer
@using NBitcoin
@using NodeGuard.Jobs
@using Google.Protobuf
@using NBXplorer.Models
@attribute [Authorize(Roles = "FinanceManager, Superadmin, NodeManager")]

<PageTitle>Channel Operation Requests</PageTitle>

@if (_isFinanceManager || _isNodeManager)
{
    <Field Flex="Flex.JustifyContent.Between">
        @if (_isFinanceManager)
        {
            <h3>Requests awaiting my signature</h3>
        }
        else if (_isNodeManager)
        {
            <h3>Requests awaiting signature by a Finance Manager</h3>
        }

        @if (_isNodeManager) // Admin can be node manager and finance manager
        {
            <Button Color="Color.Success" TextColor="TextColor.Light" Clicked="OnShowNewChannelRequestModal">New</Button>
        }
    </Field>
    <br/>
    <DataGrid TItem="ChannelOperationRequest"
              @ref="datagridRef"
              Data="@_channelRequests"
              CustomFilter="@RequestPendingFilter"
              EditMode="DataGridEditMode.Popup"
              ShowPager="true"
              UseValidation="true"
              UseInternalEditing="true"
              ShowPageSizes="true"
              Editable="_isFinanceManager"
              ShowValidationsSummary="true"
              Striped="true"
              PopupClosing="OnChannelRequestRejectModalClosing">
        <PopupTitleTemplate>
            <h2>Create Channel Request</h2>
        </PopupTitleTemplate>
        <ChildContent>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
            <DataGridColumn TItem="ChannelOperationRequest" Field="SourceNode.Name" Caption="Source Node" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.SourceNode)" PopupFieldColumnSize="ColumnSize.Is12" Editable="true">
                <EditTemplate>
                    <Validation Validator="ValidationRule.IsSelected" @ref="_sourceNodeValidation">
                        <SelectList TItem="Node"
                                    TValue="int"
                                    Data="@_manageableNodes"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValueChanged="@OnSelectedSourceNode"
                                    DefaultItemText="Choose the source node">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </SelectList>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="DestNode.Name" Caption="Remote Node" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.RemoteNode)" PopupFieldColumnSize="ColumnSize.Is12" Editable="true"
                            Validator="ValidationRule.IsAlphanumeric">
                <EditTemplate>
                    <Validation Validator="@((ValidatorEventArgs obj) => ValidationHelper.validateDestNode(obj, _selectedDestNode))" @ref="_destNodeValidation">
                        <Addons>
                            <Addon AddonType="AddonType.Body">
                                <TextEdit @bind-Text="@_destNodeName" Placeholder="Type the destination Node public key">
                                </TextEdit>
                            </Addon>
                            <Addon AddonType="AddonType.End">
                                <Button Color="Color.Primary" Clicked="@SearchNode">Search</Button>
                            </Addon>
                            <ValidationError/>
                        </Addons>
                        <FieldHelp>@(_selectedDestNode == null ? "Node Not found" : $"Found Node: {_selectedDestNode.Name}") </FieldHelp>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="Wallet.Name" Caption="Source of Funds" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.SourceOfFunds)" PopupFieldColumnSize="ColumnSize.Is12" Editable="true">
                <DisplayTemplate>
                    @if (context.Wallet != null)
                    {
                        @($"{context.Wallet.Name} ({context.Wallet.MofN}-of-{context.Wallet.Keys.Count})")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationRule.IsSelected" @ref="_walletValidation">
                        <SelectList TItem="Wallet"
                                    TValue="int?"
                                    DefaultItemText="Choose the wallet"
                                    DefaultItemDisabled
                                    Data="@_allWallets"
                                    TextField="@((item) => item.Name)"
                                    ValueField="@((item) => item.Id)"
                                    SelectedValueChanged="(id) => OnSelectedWallet(id.Value)"
                                    SelectedValue="@(_selectedWalletId)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </SelectList>
                        <FieldHelp>
                            @if (_selectedWalletId != null)
                            {
                                @($"Wallet balance: {_selectedWalletBalance:f8} BTC ({Math.Round(PriceConversionHelper.BtcToUsdConversion(_selectedWalletBalance, _btcPrice), 2)} USD)")
                            }
                            else
                            {
                                @("Wallet not selected")
                            }
                        </FieldHelp>
                    </Validation>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Amount)" Caption="Capacity" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.Capacity)" PopupFieldColumnSize="ColumnSize.Is12" Editable="true">
                <DisplayTemplate>
                    @{
                        @($"{context.Amount:f8} BTC")
                        @($" ({Math.Round(PriceConversionHelper.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                    }
                </DisplayTemplate>
                <EditTemplate>
                    <Validation Validator="@ValidationHelper.ValidateChannelCapacity" @ref="_capacityValidation">
                        <NumericPicker TValue="decimal" @bind-Value="@_amount" Min="0" Decimals="8" Step="0.00001m" CurrencySymbol=" BTC" CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix" Disabled="@(SelectedUTXOs.Count > 0)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                        <FieldHelp>

                            @($"Amount in Satoshis. Minimum {_minimumChannelCapacity:f8}. Current amount: {Math.Round(PriceConversionHelper.SatToUsdConversion(new Money(_amount, MoneyUnit.BTC).Satoshi, _btcPrice), 2)} USD")

                        </FieldHelp>
                    </Validation>
                    <div class="mb-3">
                        <Button Color="Color.Primary" Disabled="@(!_selectedWalletId.HasValue)" Clicked="@OpenCoinSelectionModal">Select Coins</Button> or use
                        <Button Color="Color.Primary" Disabled="@(SelectedUTXOs.Count == 0)" Clicked="@ClearSelectedUTXOs">Default Coin Selection</Button>
                    </div>
                    @if (_selectedWalletId.HasValue && SelectedUTXOs.Count > 0)
                    {
                        <span class="text-danger">Selected @(SelectedUTXOs.Count) UTXOs, this is a changeless operation</span>
                    }
                    else
                    {
                        <span class="text-danger">Default coin selection strategy selected</span>
                    }
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.FeeRates)" Editable="true" Caption="Fee Rate" PopupFieldColumnSize="ColumnSize.Is12">
                <EditTemplate>
                    <div class="d-flex">
                        <Select TValue="MempoolRecommendedFeesTypes" SelectedValueChanged="async (value) => await OnChangeFeeSelection(value)">
                            <SelectGroup Label="Default">
                                <SelectItem Value="MempoolRecommendedFeesTypes.EconomyFee">Economy Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesTypes.FastestFee">Fastest Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesTypes.HourFee">Hour Fee</SelectItem>
                                <SelectItem Value="MempoolRecommendedFeesTypes.HalfHourFee">Half Hour Fee</SelectItem>
                            </SelectGroup>
                            <SelectItem Value="MempoolRecommendedFeesTypes.CustomFee">Custom</SelectItem>
                        </Select>
                        <NumericPicker TValue="long" @bind-Value="@FeeAmount" CurrencySymbolPlacement="CurrencySymbolPlacement.Suffix" CurrencySymbol=" sats/vb" Min="1" Disabled="@(FeesSelection != MempoolRecommendedFeesTypes.CustomFee)">
                            <Feedback>
                                <ValidationError/>
                            </Feedback>
                        </NumericPicker>
                    </div>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.IsChannelPrivate)" Caption="Private" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.Private)" Editable="true">
                <EditTemplate>
                    <Check TValue="bool" @bind-Checked="_selectedPrivate"></Check>
                    <FieldHelp>Check to make this channel private</FieldHelp>
                </EditTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.SignaturesCollected)">
                <DisplayTemplate>
                    @{
                        if (context.RequestType == OperationRequestType.Open)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.IsSingleSig ? 0 : 1);
                            var signaturesRequired = context.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                        else
                        {
                            @("N/A")
                        }
                    }
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Status).Humanize(LetterCasing.Sentence)" Caption="Status" Sortable="false" Displayable="@IsPendingRequestsColumnVisible(PendingChannelsColumnName.Status)">
                <DisplayTemplate>
                    @context?.Status.Humanize()
                </DisplayTemplate>
            </DataGridColumn>
            <DataGridCommandColumn TItem="ChannelOperationRequest" Caption="Actions" Displayable="true">
                <EditCommandTemplate>
                    <Button Color="Color.Primary" hidden=@(!_isFinanceManager) Clicked="@(() => ShowModal(context.Item))">Approve</Button>
                    @{
                        if (LoggedUser?.Id == context.Item.UserId)
                        {
                            <Button Color="Color.Danger" Clicked="@(() => OpenModalForRejectOrCancelRequest(context.Item, ChannelOperationRequestStatus.Cancelled))">
                                Cancel
                            </Button>
                        }
                        else
                        {
                            <Button Color="Color.Danger" Clicked="@(() => OpenModalForRejectOrCancelRequest(context.Item, ChannelOperationRequestStatus.Rejected))">
                                Reject
                            </Button>
                        }
                    }
                </EditCommandTemplate>
                <NewCommandTemplate>
                    <ColumnLayout @ref="PendingRequestsColumnLayout" Columns="@PendingRequestsColumns" ColumnType="PendingChannelsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                </NewCommandTemplate>
                <DeleteCommandTemplate>
                    <Button Color="Color.Primary" hidden></Button>
                </DeleteCommandTemplate>
                <SaveCommandTemplate>
                    <Button Color="Color.Primary" Clicked="@(async () => await CreateChannelRequest())">Save</Button>
                </SaveCommandTemplate>
            </DataGridCommandColumn>
            <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.CreationDatetime)" Sortable="true" Displayable="false" SortDirection="SortDirection.Descending">
            </DataGridColumn>
        </ChildContent>
        <EmptyTemplate>
            <div class="box">
                No records were found.
            </div>
        </EmptyTemplate>
        <LoadingTemplate>
            <div class="box">
                <progress class="progress is-small is-primary" max="100"></progress>
            </div>
        </LoadingTemplate>
    </DataGrid>
}
<br/>
<br/>
<h3>All Requests</h3>
<br/>
<DataGrid TItem="ChannelOperationRequest"
          @ref="@_allRequestsDatagrid"
          Data="@_allRequests"
          Filterable="true"
          ShowPager="true"
          ShowPageSizes="true"
          Striped="true">
    <ChildContent>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Id)" Caption="#" Sortable="false" Displayable="true"/>
        <DataGridColumn TItem="ChannelOperationRequest" Field="SourceNode.Name" Caption="Source Node" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.SourceNode)"/>
        <DataGridColumn TItem="ChannelOperationRequest" Field="DestNode.Name" Caption="Remote Node" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.RemoteNode)"/>
        <DataGridColumn TItem="ChannelOperationRequest" Field="Wallet.Name" Caption="Source of Funds" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.SourceOfFunds)"/>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Amount)" Caption="Capacity" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.Capacity)">
            <DisplayTemplate>
                @{
                    @($"{context.Amount:f8} BTC")
                    @($" ({Math.Round(PriceConversionHelper.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                }
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.FeeRate)" Caption="Fee Rate" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.FeeRates)">
            <DisplayTemplate>
                @{
                    if (context.FeeRate != null)
                    {
                        @($"{context.FeeRate} sats/vbyte")
                    }
                }
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.IsChannelPrivate)" Caption="Private" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.Private)"></DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.WalletId)" Caption="Signatures Collected" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.SignaturesCollected)">
            <DisplayTemplate>
                @{
                    if (context.RequestType == OperationRequestType.Open)
                    {
                        var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.IsSingleSig ? 0 : 1);
                        var signaturesRequired = context.Wallet?.MofN ?? 0;
                        @($"{signaturesCollected} out of {signaturesRequired}")
                    }
                    else
                    {
                        @("N/A")
                    }
                }
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Status)" Caption="Status" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.Status)">
            <DisplayTemplate>
                <Row Style="white-space: nowrap;">
                    @context.Status.Humanize(LetterCasing.Sentence)
                    <ChannelStatusLogsTooltip ChannelStatusLogs="@context.StatusLogs"/>
                </Row>
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.CreationDate)">
            <DisplayTemplate>
                @context.CreationDatetime.Humanize()
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.UpdateDate)">
            <DisplayTemplate>
                @context.UpdateDatetime.Humanize()
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.TxId)" Caption="Links" Sortable="false" Displayable="@IsAllRequestsColumnVisible(AllChannelsColumnName.Links)">
            <DisplayTemplate>
                @if (mempoolUrl != null && !context.TxId.IsNullOrEmpty())
                {
                    <a href="@(mempoolUrl + "/tx/" + context.TxId)" target="_blank">See in Mempool</a>
                }
            </DisplayTemplate>
        </DataGridColumn>
        <DataGridColumn TItem="ChannelOperationRequest" Caption="Actions" Displayable="true">
            <FilterTemplate>
                <ColumnLayout @ref="AllRequestsColumnLayout" Columns="@AllRequestsColumns" ColumnType="AllChannelsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
            </FilterTemplate>
            <DisplayTemplate>
                @if (_isNodeManager && ShowActionDrowpdown(context))
                {
                    <Dropdown>
                        <DropdownToggle Color="Color.Primary">
                        </DropdownToggle>
                        <DropdownMenu>
                            <DropdownItem Clicked="() => ShowMarkRequestAsFailedConfirmationModal(context)">Mark as failed</DropdownItem>
                        </DropdownMenu>
                    </Dropdown>
                }
            </DisplayTemplate>
        </DataGridColumn>
    </ChildContent>
    <EmptyTemplate>
        <div class="box">
            No records were found.
        </div>
    </EmptyTemplate>
    <LoadingTemplate>
        <div class="box">
            <progress class="progress is-small is-primary" max="100"></progress>
        </div>
    </LoadingTemplate>
</DataGrid>

<PSBTSign
    @ref="_psbtSignRef"
    ApproveRequestDelegate="async () => await ApproveRequest()"
    SigHashMode="SigHash.None"
    ChannelRequest="_selectedRequest"
    TemplatePsbtString="@_templatePSBTString"
    SignedPSBT="@_psbt"/>

<CancelOrRejectPopup
    @ref=@_rejectCancelModalRef
    Title='@(_selectedStatusActionString + " operation: " + _selectedRequest?.Id)'
    Reason="@_cancelOrRejectReason"
    Validator="@RejectReasonValidator"
    OnCancel="@ResetChannelCancelModal"
    OnSubmit="@RejectOrCancelRequest"/>

<ConfirmationModal
    @ref="_approveOperationConfirmationModal"
    Title="Are you sure?"
    Body="You selected a hot wallet. This means that the system will automatically use the funds in it without the need of manual approval. Are you sure you want to perform this operation?"
    OkLabel="Yes, I am sure"
    OnCancel="@ApproveOperationCloseConfirmationModal"
    OnSubmit="@ApproveOperationSubmitConfirmationModal"/>

<ConfirmationModal
    @ref="_markRequestAsFailedConfirmationModal"
    Title="Are you sure?"
    Body="You are about to mark a request as failed. Operations pending on-chain confirmation might still go through. Are you sure you want to perform this operation?"
    OkLabel="Yes, I am sure"
    OnCancel="@MarkRequestAsFailedCloseConfirmationModal"
    OnSubmit="@MarkRequestAsFailedSubmitConfirmationModal"/>

<UTXOSelectorModal
    @ref="_utxoSelectorModalRef"
    OnClose="@OnCloseCoinSelectionModal"/>

@inject IChannelOperationRequestRepository ChannelOperationRequestRepository
@inject IChannelOperationRequestPSBTRepository ChannelOperationRequestPsbtRepository
@inject IToastService ToastService
@inject ILightningService LightningService
@inject ISchedulerFactory SchedulerFactory
@inject IWalletRepository WalletRepository
@inject INodeRepository NodeRepository
@inject ICoinSelectionService CoinSelectionService
@inject INBXplorerService NBXplorerService
@inject ILocalStorageService LocalStorageService

@code {
    private List<ChannelOperationRequest>? _channelRequests;
    private List<ChannelOperationRequest>? _allRequests;
    private ChannelOperationRequest? _selectedRequest;
    private ChannelOperationRequestStatus _selectedStatus;
    private ChannelOperationRequest _selectedRequestForMarkingAsFailed;
    private string? _psbt;
    private string? _templatePSBTString;
    private string? _cancelOrRejectReason;
    private CancelOrRejectPopup _rejectCancelModalRef;
    private string? _selectedStatusActionString;
    private bool _isFinanceManager = false;
    private bool _isNodeManager = false;
    private ConfirmationModal _approveOperationConfirmationModal;
    private ConfirmationModal _markRequestAsFailedConfirmationModal;
    private UTXOSelectorModal _utxoSelectorModalRef;
    private List<UTXO> SelectedUTXOs = new();
    private MempoolRecommendedFeesTypes FeesSelection;
    private long FeeAmount = 1;
    private MempoolRecommendedFees? _recommendedFees;

    // New Request integration
    private List<Wallet> _allWallets = new List<Wallet>();
    protected DataGrid<ChannelOperationRequest>? datagridRef;
    protected DataGrid<ChannelOperationRequest>? _allRequestsDatagrid;
    private List<Node>? _manageableNodes;
    private int _selectedSourceNodeId;
    private Node? _selectedDestNode;
    private int? _selectedWalletId;
    private decimal _selectedWalletBalance;
    private string? _destNodeName;
    private static readonly decimal _minimumChannelCapacity = new Money(Constants.MINIMUM_CHANNEL_CAPACITY_SATS).ToUnit(MoneyUnit.BTC);
    private decimal _amount { get; set; } = _minimumChannelCapacity;
    private bool _selectedPrivate = false;

    //Validation
    private Validation? _walletValidation;
    private Validation? _sourceNodeValidation;
    private Validation? _destNodeValidation;
    private Validation? _capacityValidation;

    private decimal _btcPrice;

    private string? mempoolUrl = Constants.MEMPOOL_ENDPOINT;

    private PSBTSign? _psbtSignRef;

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private ColumnLayout<PendingChannelsColumnName> PendingRequestsColumnLayout;
    private ColumnLayout<AllChannelsColumnName> AllRequestsColumnLayout;
    private Dictionary<string, bool> PendingRequestsColumns = new();
    private Dictionary<string, bool> AllRequestsColumns = new();
    private bool columnsLoaded;

    public abstract class PendingChannelsColumnName
    {
        public static readonly ColumnDefault SourceNode = new("Source Node");
        public static readonly ColumnDefault RemoteNode = new("Remote Node");
        public static readonly ColumnDefault SourceOfFunds = new("Source of Funds");
        public static readonly ColumnDefault Capacity = new("Capacity");
        public static readonly ColumnDefault FeeRates = new("Fee Rate");
        public static readonly ColumnDefault Private = new("Private");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
    }

    public abstract class AllChannelsColumnName
    {
        public static readonly ColumnDefault SourceNode = new("Source Node");
        public static readonly ColumnDefault RemoteNode = new("Remote Node");
        public static readonly ColumnDefault SourceOfFunds = new("Source of Funds");
        public static readonly ColumnDefault Capacity = new("Capacity");
        public static readonly ColumnDefault FeeRates = new("Fee Rate");
        public static readonly ColumnDefault Private = new("Private");
        public static readonly ColumnDefault SignaturesCollected = new("Signatures Collected");
        public static readonly ColumnDefault Status = new("Status");
        public static readonly ColumnDefault CreationDate = new("Creation Date");
        public static readonly ColumnDefault UpdateDate = new("Update Date");
        public static readonly ColumnDefault Links = new("Links");
    }

    protected override async Task OnInitializedAsync()
    {
        if (LoggedUser == null) return;

        _isFinanceManager = ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString());
        _isNodeManager = ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.NodeManager.ToString());

        _btcPrice = PriceConversionHelper.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }
        await FetchRequests();
        await LoadData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private async Task LoadColumnLayout()
    {
        AllRequestsColumns = await LocalStorageService.LoadStorage(nameof(AllChannelsColumnName), ColumnHelpers.GetColumnsDictionary<AllChannelsColumnName>());
        PendingRequestsColumns = await LocalStorageService.LoadStorage(nameof(PendingChannelsColumnName), ColumnHelpers.GetColumnsDictionary<PendingChannelsColumnName>());
        columnsLoaded = true;
        StateHasChanged();
    }

    private async Task OnShowNewChannelRequestModal()
    {
        _recommendedFees = await NBXplorerService.GetMempoolRecommendedFeesAsync();
        _utxoSelectorModalRef.ClearModal();
        FeesSelection = 0;
        await OnChangeFeeSelection(FeesSelection);
        await datagridRef.New();
    }

    private async Task ResetChannelRequestRejectModal()
    {
        await datagridRef.Edit(null);
        _destNodeName = "";
        _selectedDestNode = null;
        _selectedPrivate = false;
        _selectedWalletId = null;
        _amount = _minimumChannelCapacity;
    }

    private async Task ResetChannelCancelModal()
    {
        _cancelOrRejectReason = null;
        await _rejectCancelModalRef.CloseModal();
    }

    private async Task FetchRequests()
    {
        if (LoggedUser == null) return;

        _allRequests = await ChannelOperationRequestRepository.GetAll();

        if (_isFinanceManager)
        {
            _channelRequests = await ChannelOperationRequestRepository.GetUnsignedPendingRequestsByUser(LoggedUser.Id);
        }
        else if (_isNodeManager)
        {
            _channelRequests = await ChannelOperationRequestRepository.GetPendingRequests();
        }
        _allRequests = _allRequests.Except(_channelRequests ?? new List<ChannelOperationRequest>()).ToList();
    }

    #region New Request Integration

    private async Task LoadData()
    {
        if (LoggedUser != null)
        {
            _manageableNodes = await NodeRepository.GetAllManagedByUser(LoggedUser.Id);
            if (_selectedDestNode != null)
            {
                _manageableNodes = _manageableNodes.Where(node => node.Id != _selectedDestNode.Id).ToList();
            }
            _allWallets = await WalletRepository.GetAvailableWallets();
        }
    }

    private void OnSelectedSourceNode(int nodeId)
    {
        _selectedSourceNodeId = nodeId;
    }

    private async Task OnSelectedWallet(int walletId)
    {
        _selectedWalletId = walletId == 0 ? null : walletId;
        var wallet = _allWallets.Find(w => w.Id == _selectedWalletId);
        var balance = (await LightningService.GetWalletBalance(wallet))?.Available ?? new Money(0);
        _selectedWalletBalance = ((Money)balance).ToUnit(MoneyUnit.BTC);
    }

    private async Task SearchNode()
    {
        _selectedDestNode = null;
        if (!string.IsNullOrWhiteSpace(_destNodeName))
        {
            var foundNode = await LightningService.GetNodeInfo(_destNodeName);
            if (foundNode != null)
            {
                _selectedDestNode = (await NodeRepository.GetByPubkey(_destNodeName));

    //if not found we create it..
                if (_selectedDestNode == null)
                {
                    _selectedDestNode = new Node
                    {
                        Name = foundNode.Alias,
                        PubKey = _destNodeName,
                    };

                    var nodeAddResult = await NodeRepository.AddAsync(_selectedDestNode);

                    if (nodeAddResult.Item1)
                    {
                        _selectedDestNode = await NodeRepository.GetByPubkey(_selectedDestNode.PubKey);
                    }
                }

    // Refresh the list of available source nodes and take out the one selected
                _manageableNodes = await NodeRepository.GetAllManagedByUser(LoggedUser.Id);
                _manageableNodes = _manageableNodes.Where(node => node.Id != _selectedDestNode?.Id).ToList();
                _destNodeValidation.Clear();
            }
        }
    }

    private async Task CreateChannelRequest()
    {
        if (LoggedUser == null) return;

        List<Validation?> validators = new() { _destNodeValidation, _sourceNodeValidation, _walletValidation };
        if (SelectedUTXOs.Count == 0)
        {
            validators.Add(_capacityValidation);
        }

        if (validators.All(v => v != null && (int)v.Validate() == 1))
        {
            if (_selectedDestNode?.Id != _selectedSourceNodeId)
            {
                var amount = SelectedUTXOs.Count > 0 ? SelectedUTXOsValue() : _amount;
                var request = new ChannelOperationRequest()
                {
                    SatsAmount = new Money(amount, MoneyUnit.BTC).Satoshi,
                    RequestType = OperationRequestType.Open,
                    Description = "Created by user via Funds Manager",
                    WalletId = _selectedWalletId,
                    Status = ChannelOperationRequestStatus.Pending, //TODO Reject and cancel
                    UserId = LoggedUser.Id,
                    SourceNodeId = _selectedSourceNodeId,
                    DestNodeId = _selectedDestNode?.Id,
                    IsChannelPrivate = _selectedPrivate,
                    Changeless = SelectedUTXOs.Count > 0,
                    FeeRate = FeeAmount
                };

                var selectedWallet = await WalletRepository.GetById(_selectedWalletId.Value);


                if (selectedWallet.IsHotWallet)
                {
                    _selectedRequest = request;
                    await datagridRef.Edit(null);
                    await _approveOperationConfirmationModal.ShowModal();
                    await ResetChannelRequestRejectModal();
                    return;
                }

                var createChannelResult = await ChannelOperationRequestRepository.AddAsync(request);

                if (createChannelResult.Item1)
                {
                    ToastService.ShowSuccess("Open channel request created!");

                    if (SelectedUTXOs.Count > 0)
                    {
                        await CoinSelectionService.LockUTXOs(SelectedUTXOs, request, BitcoinRequestType.ChannelOperation);
                    }
                }
                else
                {
                    ToastService.ShowError(createChannelResult.Item2);
                }
                _utxoSelectorModalRef.ClearModal();
            }
            else
            {
                ToastService.ShowError("The Source Node cannot be the same as the Destitation Node");
            }
            await ResetChannelRequestRejectModal();
        }
        await LoadData();
        await FetchRequests();
    }

    #endregion

    private static bool RequestPendingFilter(ChannelOperationRequest req)
    {
        return req.Status.Equals(ChannelOperationRequestStatus.Pending) || req.Status == ChannelOperationRequestStatus.PSBTSignaturesPending;
    }

    private Task OnChannelRequestRejectModalClosing(ModalClosingEventArgs args)
    {
        return ResetChannelRequestRejectModal();
    }

    private async Task OpenModalForRejectOrCancelRequest(ChannelOperationRequest req, ChannelOperationRequestStatus status)
    {
        _selectedRequest = req;
        _selectedStatus = status;
        switch (_selectedStatus)
        {
            case ChannelOperationRequestStatus.Rejected:
                _selectedStatusActionString = "Reject";
                break;
            case ChannelOperationRequestStatus.Cancelled:
                _selectedStatusActionString = "Cancel";
                break;
        }
        await _rejectCancelModalRef.ShowModal();
    }

    private async Task RejectOrCancelRequest()
    {
        if (_selectedRequest != null)
        {
            _selectedRequest.ClosingReason = _cancelOrRejectReason;
            _selectedRequest.Status = _selectedStatus;
            var jobUpdateResult = ChannelOperationRequestRepository.Update(_selectedRequest);
            if (!jobUpdateResult.Item1)
            {
                ToastService.ShowError("There has been an error when updating the request");
            }
            else
            {
                ToastService.ShowSuccess("Request " + _selectedStatus);
                await FetchRequests();
            }
        }
        else
        {
            ToastService.ShowError("Couldn't fetch data from the request");
        }
        ResetChannelCancelModal();
    }

    private async Task ShowModal(ChannelOperationRequest channelOperationRequest)
    {
        _selectedRequest = channelOperationRequest;
        _psbt = string.Empty;
        if (_selectedRequest != null && !_selectedRequest.AreAllRequiredHumanSignaturesCollected)
        {
            var (templatePsbt,noUtxosAvailable) = (await LightningService.GenerateTemplatePSBT(_selectedRequest));
            if (templatePsbt != null)
            {
                _templatePSBTString = templatePsbt.ToBase64();
                await _psbtSignRef.ShowModal();
            }
            else
            {
                if (noUtxosAvailable)
                {
                    ToastService.ShowError("No UTXOs found for this wallet, please wait for other requests to be confirmed or fund the wallet with more UTXOs");
                }
                else
                {
                    ToastService.ShowError("Something went wrong");
                }
            }
        }
    }

    private async Task ApproveRequest()
    {
        _psbtSignRef?.HideModal();

        if (_selectedRequest == null || string.IsNullOrEmpty(_psbtSignRef?.SignedPSBT) || LoggedUser == null)
        {
            ToastService.ShowError("Error: Not all fields were set");
        }
        else
        {
            ChannelOperationRequestPSBT channelOperationRequestPsbt = new()
            {
                ChannelOperationRequestId = _selectedRequest.Id,
                PSBT = _psbtSignRef.SignedPSBT,
                UserSignerId = LoggedUser.Id,
            };
            var addResult = await ChannelOperationRequestPsbtRepository.AddAsync(channelOperationRequestPsbt);

            if (addResult.Item1)
            {
                ToastService.ShowSuccess("Signature collected");

                _selectedRequest = await ChannelOperationRequestRepository.GetById(_selectedRequest.Id);

                if (_selectedRequest != null
                    && _selectedRequest.AreAllRequiredHumanSignaturesCollected)
                {
                    await CreateJob();
                }
            }
            else
            {
                ToastService.ShowError("Error while saving the signature");
            }

            await FetchRequests();
            await _psbtSignRef.HideModal();
            StateHasChanged();
        }
    }

    private void RejectReasonValidator(ValidatorEventArgs e)
    {
        if (_selectedStatus == ChannelOperationRequestStatus.Rejected)
        {
            ValidationRule.IsNotEmpty(e);
        }
        else
        {
            ValidationRule.None(e);
        }
    }

    private async Task ApproveOperationCloseConfirmationModal()
    {
        await _approveOperationConfirmationModal.CloseModal();
    }

    private async Task ApproveOperationSubmitConfirmationModal()
    {
        if (_selectedRequest != null)
        {
            var createChannelResult = await ChannelOperationRequestRepository.AddAsync(_selectedRequest);
            if (createChannelResult.Item1)
            {
                ToastService.ShowSuccess("Open channel request created!");
            }
            else
            {
                ToastService.ShowError(createChannelResult.Item2);
                _utxoSelectorModalRef.ClearModal();
                await _approveOperationConfirmationModal.CloseModal();
                return;
            }

            if (SelectedUTXOs.Count > 0)
            {
                await CoinSelectionService.LockUTXOs(SelectedUTXOs, _selectedRequest, BitcoinRequestType.ChannelOperation);
            }

            var (templatePsbt, noUtxosAvailable) = (await LightningService.GenerateTemplatePSBT(_selectedRequest));
            if (templatePsbt == null)
            {
                if (noUtxosAvailable)
                {
                    ToastService.ShowError("No UTXOs found for this wallet, please wait for other requests to be confirmed or fund the wallet with more UTXOs");
                }
                else
                {
                    ToastService.ShowError("Something went wrong");
                }
                _selectedRequest.Status = ChannelOperationRequestStatus.Failed;
                ChannelOperationRequestRepository.Update(_selectedRequest);
                _utxoSelectorModalRef.ClearModal();
                await _approveOperationConfirmationModal.CloseModal();
                await FetchRequests();
                StateHasChanged();
                return;
            }


            _selectedRequest = await ChannelOperationRequestRepository.GetById(_selectedRequest.Id);

            if (_selectedRequest != null
                && _selectedRequest.AreAllRequiredHumanSignaturesCollected)
            {
                await CreateJob();
            }
            else
            {
                ToastService.ShowError("Invalid PSBT");
            }


            await FetchRequests();
            _utxoSelectorModalRef.ClearModal();
            await _approveOperationConfirmationModal.CloseModal();
        }
    }

    private async Task CreateJob()
    {
        try
        {
    //TODO Async notifications when the channel has opened -> event / notifications system
            var scheduler = await SchedulerFactory.GetScheduler();

            var map = new JobDataMap();
            map.Put("openRequestId", _selectedRequest.Id);

            var retryList = RetriableJob.ParseRetryListFromString(Constants.JOB_RETRY_INTERVAL_LIST_IN_MINUTES);
            var job = RetriableJob.Create<ChannelOpenJob>(map, _selectedRequest.Id.ToString(), retryList);
            await scheduler.ScheduleJob(job.Job, job.Trigger);

    // TODO: Check job id
            _selectedRequest.JobId = job.Job.Key.ToString();

            var jobUpdateResult = ChannelOperationRequestRepository.Update(_selectedRequest);
            ToastService.ShowSuccess("Channel opening job created");
        }
        catch
        {
            ToastService.ShowError("Error while requesting to open the channel, please contact a superadmin for troubleshooting");
        }
    }

    private bool ShowActionDrowpdown(ChannelOperationRequest request)
    {
        return request.Status == ChannelOperationRequestStatus.OnChainConfirmationPending ||
               request.Status == ChannelOperationRequestStatus.PSBTSignaturesPending ||
               request.Status == ChannelOperationRequestStatus.Pending;
    }

    private async Task MarkRequestAsFailedCloseConfirmationModal()
    {
        _selectedRequestForMarkingAsFailed = null;
        await _markRequestAsFailedConfirmationModal.CloseModal();
    }

    private async Task MarkRequestAsFailedSubmitConfirmationModal()
    {
        try
        {
            var request = await ChannelOperationRequestRepository.GetById(_selectedRequestForMarkingAsFailed.Id);
            request.Status = ChannelOperationRequestStatus.Failed;
            var scheduler = await SchedulerFactory.GetScheduler();
            await scheduler.DeleteJob(new JobKey($"{nameof(ChannelOpenJob)}-{request.Id}"));
            if (!ChannelOperationRequestRepository.Update(request).Item1) throw new Exception();
            if (request.Channel?.ChanId != null)
            {
                LightningService.CancelPendingChannel(request.SourceNode, ByteString.CopyFromUtf8(request.Channel?.ChanId.ToString()).ToByteArray());
            }
        }
        catch (Exception? e)
        {
            ToastService.ShowError("Error while marking request as failed");
        }
        finally
        {
            await MarkRequestAsFailedCloseConfirmationModal();
            await FetchRequests();
        }
    }

    private async Task ShowMarkRequestAsFailedConfirmationModal(ChannelOperationRequest context)
    {
        _selectedRequestForMarkingAsFailed = context;
        await _markRequestAsFailedConfirmationModal.ShowModal();
    }

    private async Task OpenCoinSelectionModal()
    {
        _utxoSelectorModalRef.ShowModal(_selectedWalletId.Value);
    }

    private void OnCloseCoinSelectionModal(List<UTXO> selectedUTXOs)
    {
        SelectedUTXOs = selectedUTXOs;
        if (SelectedUTXOs.Count > 0)
        {
            _amount = SelectedUTXOsValue();
        }
        StateHasChanged();
    }

    private decimal SelectedUTXOsValue()
    {
        return SelectedUTXOs.Sum(x => ((Money)x.Value).ToUnit(MoneyUnit.BTC));
    }

    private void ClearSelectedUTXOs()
    {
        _utxoSelectorModalRef.ClearModal();
        SelectedUTXOs.Clear();
        StateHasChanged();
    }

    private async Task OnChangeFeeSelection(MempoolRecommendedFeesTypes value)
    {
        _recommendedFees = await NBXplorerService.GetMempoolRecommendedFeesAsync();
        FeesSelection = value;

        switch (FeesSelection)
        {
            case MempoolRecommendedFeesTypes.EconomyFee:
                FeeAmount = _recommendedFees.EconomyFee;
                break;
            case MempoolRecommendedFeesTypes.FastestFee:
                FeeAmount = _recommendedFees.FastestFee;
                break;
            case MempoolRecommendedFeesTypes.HourFee:
                FeeAmount = _recommendedFees.HourFee;
                break;
            case MempoolRecommendedFeesTypes.HalfHourFee:
                FeeAmount = _recommendedFees.HalfHourFee;
                break;
            case MempoolRecommendedFeesTypes.CustomFee:
                FeeAmount = 1;
                break;
        }
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsPendingRequestsColumnVisible(ColumnDefault column)
    {
        if (PendingRequestsColumnLayout	== null)
        {
            return true;
        }
        return PendingRequestsColumnLayout.IsColumnVisible(column);
    }

    private bool IsAllRequestsColumnVisible(ColumnDefault column)
    {
        if (AllRequestsColumnLayout	== null)
        {
            return true;
        }
        return AllRequestsColumnLayout.IsColumnVisible(column);
    }
}