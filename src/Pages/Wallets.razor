@page "/wallets"
@using System.Security.Claims
@using Humanizer
@using NBitcoin
@using NBXplorer.DerivationStrategy
@using NSubstitute
@using Field = Blazorise.Field
@using Key = FundsManager.Data.Models.Key
@inject IWalletRepository WalletRepository
@inject IToastService ToastService
@inject IApplicationUserRepository ApplicationUserRepository
@inject IKeyRepository KeyRepository
@inject ILightningService LightningService
@attribute [Authorize(Roles = "NodeManager, FinanceManager, Superadmin")]

<h3 class="custom-primary">Treasury Wallets</h3>
<Row>
    <Column ColumnSize="ColumnSize.Is12">
        <DataGrid TItem="Wallet"
                  @bind-SelectedRow="_selectedWallet"
                  Data="_wallets"
                  Editable="@_isFinanceManager"
                  EditMode="DataGridEditMode.Popup"
                  Responsive="true"
                  ResizeMode="TableResizeMode.Columns"
                  UseInternalEditing="true"
                  RowInserted="OnRowInserted"
                  RowRemoving="OnRowRemoving"
                  RowUpdated="OnRowUpdated"
                  DetailRowStartsVisible="false"
                  NewItemDefaultSetter="NewItemDefaultSetter"
                  ShowPager="true"
                  ShowPageSizes="true"
                  PageSize="25"
                  Filterable="true"
                  UseValidation="true">
            <PopupTitleTemplate>
                <h2>@(context.EditState) wallet</h2>
            </PopupTitleTemplate>
            <DataGridColumns>
                <DataGridCommandColumn TItem="Wallet">
                    <NewCommandTemplate>
                        @if (_isFinanceManager)
                        {
                            <Dropdown>
                                <DropdownToggle Color="Color.Primary">
                                </DropdownToggle>
                                <DropdownMenu>

                                    <DropdownItem Clicked="context.Clicked">New</DropdownItem>
                                    <DropdownItem Clicked="@(() => ShowImportWalletModal())">Import Wallet</DropdownItem>
                                    <DropdownItem Clicked="@ShowWallets">@("Archived & compromised wallets" + (_showNotAvailableWallets ? "  \u2713" : ""))</DropdownItem>

                                </DropdownMenu>
                            </Dropdown>
                        }

                    </NewCommandTemplate>
                    <EditCommandTemplate>
                        <Dropdown>
                            <DropdownToggle Color="Color.Primary">
                            </DropdownToggle>
                            <DropdownMenu>

                                <DropdownItem Clicked="context.Clicked">Edit</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => LoadAndOpenTextModalBalance(context.Item))">Balance</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => LoadAndOpenModalTextModalUnusedAddress(context.Item))">Get address</DropdownItem>

                            </DropdownMenu>
                        </Dropdown>
                    </EditCommandTemplate>
                    <DeleteCommandTemplate>
                        @if (!context.Item.IsFinalised)
                        {
                            <Button Color="Color.Danger" Clicked="@context.Clicked" @onclick:stopPropagation="true" Block>Delete</Button>
                        }
                    </DeleteCommandTemplate>
                </DataGridCommandColumn>
                <DataGridColumn TItem="Wallet" Filterable="false" ShowCaption="false" Sortable="false">
                    <DisplayTemplate>
                        @if (!context.IsFinalised && !context.IsSingleSig)
                        {
                            <Button Color="Color.Info" Disabled="@(context.Keys != null && context.Keys.Count > context.MofN)" Clicked="@(() => LoadAndOpenModal(context))" @onclick:stopPropagation="true">Add key</Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Filterable="false" ShowCaption="false" Sortable="false" Width="140px">
                    <DisplayTemplate>
                        @if (!context.IsFinalised)
                        {
                            <Button Color="Color.Warning" Disabled="@(context.Keys != null && context.Keys.Count < context.MofN)" Clicked="@(() => LoadAndOpenFinaliseTextModal(context))" Block @onclick:stopPropagation="true">Finalise</Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.Name)" Caption="@nameof(Wallet.Name)" Sortable="false">
                    <EditTemplate>
                        <Validation Validator="@ValidationHelper.ValidateName">
                            <TextEdit Text="@((string) context.CellValue)" TextChanged="(text) => { context.CellValue = text; }">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </TextEdit>
                        </Validation>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.Description)" Caption="@nameof(Wallet.Description)" Sortable="false"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Field="@nameof(Wallet.IsHotWallet)" CustomFilter="((searchItem, searchValue) => OnCustomFilter(searchItem, _hotWalletFilter))"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Field="@nameof(Wallet.IsHotWallet)" CustomFilter="((searchItem, searchValue) => OnCustomFilter(!(bool)searchItem, _coldWalletFilter))"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Field="@nameof(Wallet.IsFinalised)" CustomFilter="((searchItem, searchValue) => OnCustomFilter(searchItem, _finalizedWalletFilter))"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Field="@nameof(Wallet.IsArchived)" CustomFilter="((searchItem, searchValue) => OnCustomFilter(searchItem, _archivedWalletFilter))"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Field="@nameof(Wallet.IsCompromised)" CustomFilter="((searchItem, searchValue) => OnCustomFilter(searchItem, _compromisedWalletFilter))"/>
                <DataGridSelectColumn TItem="Wallet" Sortable="false" Filterable="true">
                    <FilterTemplate>
                        <Dropdown>
                            <DropdownToggle>Select</DropdownToggle>
                            <DropdownMenu>
                                <div class="checkbox-drop">
                                    <Check TValue="bool" @bind-Checked="_hotWalletFilter">üî• Hot Wallet</Check>
                                    <Check TValue="bool" @bind-Checked="_coldWalletFilter">‚ùÑÔ∏è Cold Wallet</Check>
                                    <Check TValue="bool" @bind-Checked="_finalizedWalletFilter">üèÅ Finalized</Check>
                                    <Check TValue="bool" @bind-Checked="_archivedWalletFilter">üìÇ Archived</Check>
                                    <Check TValue="bool" @bind-Checked="_compromisedWalletFilter">‚õîÔ∏è Compromised</Check>
                                </div>
                            </DropdownMenu>
                        </Dropdown>
                    </FilterTemplate>
                    <CaptionTemplate>
                        <span>
                            Wallet Properties
                        </span>
                        <span title="@("üî• Hot Wallet\n‚ùÑÔ∏è Cold Wallet\nüèÅ Finalized\nüìÇ Archived\n‚õîÔ∏è Compromised")">
                            @("\u24D8")
                        </span>
                    </CaptionTemplate>
                    <DisplayTemplate>
                        @{
                            string walletProperties = "";
                            if (context.IsHotWallet) walletProperties = walletProperties + "üî• ";
                            else walletProperties = walletProperties + "‚ùÑÔ∏è ";
                            if (context.IsFinalised) walletProperties = walletProperties + "üèÅ ";
                            if (context.IsArchived) walletProperties = walletProperties + "üìÇ ";
                            if (context.IsCompromised) walletProperties = walletProperties + "‚õîÔ∏è ";
                            <span>@walletProperties</span>
                        }
                    </DisplayTemplate>
                </DataGridSelectColumn>
                <DataGridNumericColumn TItem="Wallet" Decimals="0" Editable="true" Field="@nameof(Wallet.MofN)" Caption="Threshold" Sortable="false">
                    <EditTemplate>
                        <Validation Validator="@ValidateThreshold">
                            <NumericEdit TValue="int" Value="@(IsHotWallet(_hotWalletCheckComponent) ? 1 : (int) context.CellValue)" Disabled="@(context.Item.IsFinalised || IsHotWallet(_hotWalletCheckComponent))" ValueChanged="(value) => { context.CellValue = value; }">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </NumericEdit>
                        </Validation>
                    </EditTemplate>
                </DataGridNumericColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.ReferenceId)" Caption="Reference Id" Sortable="true"/>
                <DataGridColumn TItem="Wallet" Field="@nameof(Wallet.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending">
                    <DisplayTemplate>
                        @context.CreationDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Field="@nameof(Wallet.UpdateDatetime)" Caption="Update date" Sortable="true">
                    <DisplayTemplate>
                        @context.UpdateDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
            </DataGridColumns>
            <DetailRowTemplate>
                @{
                    var keys = (context as Wallet).Keys?.ToList() ?? new List<Key>();
                    <ReadOnlyKeyDatagrid Keys="@keys"></ReadOnlyKeyDatagrid>
                }
            </DetailRowTemplate>
        </DataGrid>
    </Column>
</Row>
<Modal @ref="_modalRef">
    <ModalContent Centered Size="ModalSize.ExtraLarge">
        <ModalHeader>
            <ModalTitle>Please select the key will be added this wallet</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Field>
                <FieldLabel>Select the Finance user(s) who will be a co-approver</FieldLabel>
                <SelectList TItem="ApplicationUser"
                            TValue="string"
                            Data="@_financeManagers"
                            TextField="@((item) => item.UserName)"
                            ValueField="@((item) => item.Id)"
                            SelectedValueChanged="@OnSelectedFinanceManager"
                            DefaultItemText="Choose the approver"/>

            </Field>
            @if (_selectedFinanceManager != null && _selectedFinanceManagerAvailableKeys.Any())
            {
                <Field>
                    <FieldLabel>Select the Finance user(s) key</FieldLabel>
                    <SelectList TItem="Key"
                                TValue="int"
                                Data="@_selectedFinanceManagerAvailableKeys"
                                TextField="@((item) => $"{item.Name}-{StringHelper.TruncateHeadAndTail(item.XPUB, 10)}")"
                                ValueField="@((item) => item.Id)"
                                SelectedValueChanged="@OnSelectedWalletKey"
                                DefaultItemText="Choose the key of the manager"/>
                </Field>
            }
            else
            {
                <Alert Color="Color.Warning" Visible>
                    <AlertMessage>No keys found!</AlertMessage>
                    <AlertDescription>No keys are available for this Finance Manager, either are archived/compromised or already used.</AlertDescription>

                </Alert>
            }

            <Field>
                <Alert Color="Color.Info" Visible>
                    <AlertMessage>Below you will find the key that form this wallet</AlertMessage>
                    <AlertDescription>Take into account that the NodeGuard key will be always be added to your wallet by the system</AlertDescription>

                </Alert>
                <ReadOnlyKeyDatagrid Keys="@_selectedWalletKeysPlusInternalWalletKey"></ReadOnlyKeyDatagrid>
            </Field>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseModal">Cancel</Button>
            <Button Color="Color.Primary" Clicked="@SaveAndCloseModal">Add</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_textModalRef">
    <ModalContent Centered Size="ModalSize.Large">
        <ModalHeader>
            <ModalTitle>@_textModalTitle</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <p>@_textModalContent</p>
        </ModalBody>
        <ModalFooter>
            @if (_textModalCopy)
            {
                <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard(_textModalContent))">Copy</Button>
            }
            <Button Color="Color.Secondary" Clicked="@CloseTextModal">Close</Button>
        </ModalFooter>
    </ModalContent>
</Modal>
<Modal @ref="_finaliseModalRef">
    <ModalContent Centered Size="ModalSize.Default">
        <ModalHeader>
            <ModalTitle>Do you want to finalise this wallet?</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <p>If you confirm to finalise this wallet, it will become a ready-to-use wallet for the system but at the same time you won't be allowed to update it in terms of keys, thresholds and other configuration parameters</p>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseAndCleanFinaliseModal">Close</Button>
            <Button Color="Color.Primary" Clicked="@FinaliseWallet">Finalise</Button>

        </ModalFooter>
    </ModalContent>
</Modal>
<Modal @ref="_importWalletModal">
    <ModalContent Centered Size="ModalSize.Default">
        <ModalHeader>
            <ModalTitle>Import external wallet</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Alert Color="Color.Warning" Visible>

                <AlertDescription>
                    @if (@Constants.ENABLE_REMOTE_SIGNER)
                    {
                        <p>Remote signer is enabled, therefore the seedphrase <b>won't be stored in NodeGuard database.</b>. Take into account that a seedphrase will leak all the subwallets you have on it.</p>
                    }
                    else
                    {
                        <p>Remote signer is not enabled, therefore the seedphrase will be stored as plain-text in the NodeGuard database, please reconsider your security threat model based on this. Take into account that a seedphrase will leak all the subwallets you have on it.</p>
                    }
                </AlertDescription>
            </Alert>
            <Fields>
                <Validations @ref="_importWalletValidations">
                    <Column ColumnSize="ColumnSize.Is12">
                        <Validation Validator="ValidationRule.IsNotEmpty">
                            <Field>
                                <FieldLabel>Name</FieldLabel>
                                <FieldBody>
                                    <TextEdit @bind-Text="@_name">
                                        <Feedback>
                                            <ValidationNone>Enter a valid name</ValidationNone>
                                            <ValidationError>Invalid name</ValidationError>
                                        </Feedback>
                                    </TextEdit>
                                </FieldBody>
                            </Field>
                        </Validation>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is12">
                        <Field>
                            <FieldLabel>Description</FieldLabel>
                            <FieldBody>
                                <MemoEdit @bind-Text="@_description" Rows="4">
                                    <Feedback>
                                        <ValidationNone>Enter a valid description</ValidationNone>
                                        <ValidationError>Invalid description</ValidationError>
                                    </Feedback>
                                </MemoEdit>
                            </FieldBody>
                        </Field>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is12">
                        <Validation AsyncValidator="@ValidateSeedphrase">
                            <Field>
                                <FieldLabel>Seedphrase</FieldLabel>
                                <FieldHelp>Paste your seedphrase (English wordlist only)</FieldHelp>
                                <FieldBody>
                                    <MemoEdit @bind-Text="@_seedphrase" Rows="4">
                                        <Feedback>
                                            <ValidationNone>Enter a valid seedphrase</ValidationNone>
                                            <ValidationError>Invalid seedphrase</ValidationError>
                                        </Feedback>
                                    </MemoEdit>
                                </FieldBody>
                            </Field>
                        </Validation>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is12">
                        <Validation AsyncValidator="ValidateDerivationPath">
                            <Field>
                                <FieldLabel>Derivation path</FieldLabel>
                                <FieldBody>
                                    <TextEdit @bind-Text="@_derivationPath">
                                        <Feedback>
                                            <ValidationNone>Enter a valid derivation path</ValidationNone>
                                            <ValidationError>Invalid derivation path</ValidationError>
                                        </Feedback>
                                    </TextEdit>
                                </FieldBody>
                            </Field>
                        </Validation>
                    </Column>


                </Validations>
            </Fields>

        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseAndCleanImportWalletModal">Close</Button>
            <Button Color="Color.Primary" Clicked="@ImportWallet">Import</Button>

        </ModalFooter>
    </ModalContent>
</Modal>

@code {

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal ClaimsPrincipal { get; set; }

    private List<ApplicationUser> _financeManagers = new();

    private Modal _modalRef;

    private List<Wallet> _wallets = new();

    private Wallet? _selectedWallet;

    private ApplicationUser? _selectedFinanceManager;

    private List<Key> _selectedWalletKeysPlusInternalWalletKey = new();
    private List<Key> _selectedFinanceManagerAvailableKeys = new();
    private Key? _selectedWalletKey;

    private Modal _textModalRef;
    private string _textModalTitle = string.Empty;
    private string _textModalContent = string.Empty;
    private bool _textModalCopy;

    private Modal _finaliseModalRef;
    private Wallet? _selectedWalletToFinalise;

    private bool _isFinanceManager = false;

    private decimal _btcPrice;

    private Check<bool> _hotWalletCheckComponent;

    private Modal? _importWalletModal;
    private string? _importWalletSeedphrase;
    private Validations _importWalletValidations;


    private string _seedphrase = string.Empty;
    private string _name = string.Empty;
    private string _description = string.Empty;
    private string _derivationPath = string.Empty;

    private bool _hotWalletFilter = false;
    private bool _coldWalletFilter = false;
    private bool _finalizedWalletFilter = false;
    private bool _archivedWalletFilter = false;
    private bool _compromisedWalletFilter = false;

    private bool _showNotAvailableWallets = false;

    protected override async Task OnInitializedAsync()
    {
        _btcPrice = PriceConversionHelper.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }
        if (LoggedUser != null)
        {
            if (ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString()))
            {
                _isFinanceManager = true;
            }
            await GetData();
        }
    }

    private async Task GetData()
    {
        var allWallets = await WalletRepository.GetAll();
        _wallets = _showNotAvailableWallets ? allWallets.Where(x => x.IsArchived || x.IsCompromised).ToList() : allWallets.Where(x => !x.IsArchived && !x.IsCompromised).ToList();
        var financeManagers = (await ApplicationUserRepository.GetUsersInRole(ApplicationUserRole.FinanceManager));
        _financeManagers = financeManagers.Where(x => x.Keys.Any()).ToList();

        if (_financeManagers.Any())
            _selectedFinanceManager = financeManagers.FirstOrDefault();
        if (_selectedFinanceManager?.Keys != null)
            _selectedFinanceManagerAvailableKeys = await FilterKeys(_selectedFinanceManager.Keys);
    }


    private async Task OnRowInserted(SavedRowItem<Wallet, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;

        if (arg.Item.IsHotWallet) arg.Item.MofN = 1;

        var addResult = await WalletRepository.AddAsync(arg.Item);


        if (addResult.Item1)
        {
            ToastService.ShowSuccess("Success");
            await GetData();
        }
        else
        {
            ToastService.ShowError("Something went wrong");
            _wallets.Remove(arg.Item);
        }
    }

    private void NewItemDefaultSetter(Wallet obj)
    {
        obj.WalletAddressType = WalletAddressType.NativeSegwit;
    }

    private async Task OnRowRemoving(CancellableRowChange<Wallet> arg)
    {
        if (arg.Item != null)
        {
            var (result, message) = WalletRepository.Remove(arg.Item);

            if (!result)
            {
                arg.Cancel = true;
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess("Success");
                await GetData();
            }
        }
    }


    private async Task OnRowUpdated(SavedRowItem<Wallet, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;

        if (arg.Item.IsHotWallet) arg.Item.MofN = 1;

        var updateResult = WalletRepository.Update(arg.Item);

        if (updateResult.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Something went wrong");
        }

        await GetData();
    }

    private async Task CloseModal()
    {
        CleanModal();
        await _modalRef.Close(CloseReason.UserClosing);
    }

    private void CleanModal()
    {
        _selectedWalletKeysPlusInternalWalletKey = new List<Key>();
        _selectedFinanceManager = _financeManagers.FirstOrDefault();
        _selectedFinanceManagerAvailableKeys = new();

        _selectedWallet = null;
    }

    private async Task LoadAndOpenModal(Wallet wallet)
    {
        CleanModal();
        _selectedWallet = await WalletRepository.GetById(wallet.Id);


        if (_selectedWallet != null)
        {
            await GetData();

    //Modal data
            await GetModalDefaultData();


            await _modalRef.Show();
        }
    }

    private async Task SaveAndCloseModal()
    {
        if (_selectedWallet == null) return;

    //Add the key

        if (_selectedWalletKey != null)
        {
            if (_selectedWallet.Keys == null)
            {
                ToastService.ShowError("No co-signer key found");
                return;
            }

            _selectedWallet.Keys.Add(_selectedWalletKey);

            var updateResult = WalletRepository.Update(_selectedWallet);

            if (updateResult.Item1)
            {
                ToastService.ShowSuccess("Key added");
            }
            else
            {
                ToastService.ShowError("Error while adding key...");
            }
        }


        CleanModal();

        await GetData();

        await _modalRef.Close(CloseReason.UserClosing);
    }

    private async Task OnSelectedFinanceManager(string applicationUserId)

    {
        if (!string.IsNullOrWhiteSpace(applicationUserId))
        {
            var applicationUser = await ApplicationUserRepository.GetById(applicationUserId);
            _selectedFinanceManager = applicationUser;
            if (_selectedFinanceManager != null && _selectedFinanceManager.Keys.Any() && _selectedWallet != null)
            {
    //Filter Keys
                _selectedFinanceManagerAvailableKeys = await FilterKeys(_selectedFinanceManager.Keys);
            }
        }
    }

    private async Task<List<Key>> FilterKeys(ICollection<Key> keys)
    {
        var result = new List<Key>();
        if (_selectedWallet != null && _selectedWallet.Keys != null)
        {
            result = keys.Where(x => !x.IsArchived && !x.IsCompromised && x.InternalWalletId == null).Except(_selectedWallet.Keys)
                .ToList();
        }
        else
        {
            result = keys.Where(x => !x.IsArchived && !x.IsCompromised && x.InternalWalletId == null)
                .ToList();
        }

        return result;
    }

    private async Task OnSelectedWalletKey(int keyId)
    {
        _selectedWalletKeysPlusInternalWalletKey = new List<Key>();

        if (keyId > 0)
        {
            var selectedKey = await KeyRepository.GetById(keyId);

            if (selectedKey != null)
            {
                _selectedWalletKey = selectedKey;

                _selectedWalletKeysPlusInternalWalletKey.Add(selectedKey);
            }
        }

        await GetModalDefaultData();
    }

    private async Task GetModalDefaultData()
    {
        if (_selectedWallet != null)
            _selectedWalletKeysPlusInternalWalletKey.AddRange(_selectedWallet.Keys.ToList());

        var currentInternalWalletKey = await KeyRepository.GetCurrentInternalWalletKey(_selectedWallet.InternalWalletSubDerivationPath);

    //TODO What happens when the internal wallet changes? This is not correct, FUTURE FIX required
        if (!_selectedWalletKeysPlusInternalWalletKey.Any(x => x.Id == currentInternalWalletKey.Id))
        {
            _selectedWalletKeysPlusInternalWalletKey.Add(currentInternalWalletKey);
        }
    }

    private async Task CleanTextModal()
    {
        _textModalContent = string.Empty;
        _textModalTitle = string.Empty;
    }

    private async Task CloseTextModal()
    {
        await CleanTextModal();

        await _textModalRef.Close(CloseReason.UserClosing);
    }

    private async Task LoadAndOpenTextModalBalance(Wallet wallet)
    {
        await CleanTextModal();
        if (wallet != null)
        {
            var balance = await LightningService.GetWalletBalance(wallet);

            if (balance != null)
            {
                _textModalTitle = $"Wallet: {wallet.Name} On-chain Balance";
                _textModalContent = $"Confirmed: {((Money) balance.Confirmed).ToUnit(MoneyUnit.BTC):f8} BTC ({Math.Round(PriceConversionHelper.BtcToUsdConversion(((Money) balance.Confirmed).ToUnit(MoneyUnit.BTC), _btcPrice), 2)} USD) - " +
                                    $"Unconfirmed: {((Money) balance.Unconfirmed).ToUnit(MoneyUnit.BTC):f8} BTC ({Math.Round(PriceConversionHelper.BtcToUsdConversion(((Money) balance.Unconfirmed).ToUnit(MoneyUnit.BTC), _btcPrice), 2)} USD)";
                _textModalCopy = false;

                await _textModalRef.Show();
            }
            else
            {
                ToastService.ShowError("Error while getting the wallet on-chain balance");
            }
        }
    }

    private async Task LoadAndOpenModalTextModalUnusedAddress(Wallet wallet)
    {
        await CleanTextModal();
        if (wallet != null)
        {
            var bitcoinAddress = await LightningService.GetUnusedAddress(wallet, DerivationFeature.Deposit);

            if (bitcoinAddress != null)
            {
                _textModalTitle = $"Unused BTC Address for funding this wallet";
                _textModalContent = bitcoinAddress.ToString();
                _textModalCopy = true;
                await _textModalRef.Show();
            }
            else
            {
                ToastService.ShowError("Error while getting the wallet on-chain balance");
            }
        }
    }

    private async Task LoadAndOpenFinaliseTextModal(Wallet wallet)
    {
        _selectedWalletToFinalise = wallet;

        await _finaliseModalRef.Show();
    }

    private async Task FinaliseWallet()
    {
        if (_selectedWalletToFinalise == null || _selectedWalletToFinalise.IsFinalised)
            return;


        var result = await WalletRepository.FinaliseWallet(_selectedWalletToFinalise);

        if (result.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Error while marking wallet as finalised");
        }

        _selectedWalletToFinalise = null;

        await _finaliseModalRef.Close(CloseReason.UserClosing);

        await GetData();
    }

    private async Task CloseAndCleanFinaliseModal()
    {
        _selectedWalletToFinalise = null;
        await _finaliseModalRef.Close(CloseReason.UserClosing);
    }

    private void ValidateThreshold(ValidatorEventArgs obj)
    {
        obj.Status = ValidationStatus.Success;
        if (obj.Value is int threshold)
        {
            if (threshold < 2 || threshold > 5)
            {
                obj.ErrorText = "The threshold should be minimum 2 and maximum 5";
                obj.Status = ValidationStatus.Error;
            }
        }
    }

    private void OnCheckedChanged(CellEditContext<Wallet> context, bool value)
    {
        context.CellValue = value;
    }

    private bool IsHotWallet(Check<bool>? component)
    {
        if (component == null)
        {
            return false;
        }
        return component.Checked;
    }

    private async Task CloseAndCleanImportWalletModal()
    {
        await _importWalletModal?.Close(CloseReason.UserClosing);

        _seedphrase = string.Empty;
        _name = string.Empty;
        _description = string.Empty;
        _derivationPath = string.Empty;
    }

    private async Task ImportWallet()
    {
        if (!await _importWalletValidations.ValidateAll())
        {
            ToastService.ShowError("Please fill in all the required fields");
            return;
        }

    //Import bip39 wallet
        var result = await WalletRepository.ImportBIP39Wallet(_name, _description, _seedphrase, _derivationPath);

    //Handle error
        if (!result.Item1)
        {
            ToastService.ShowError("Something went wrong while importing the wallet");
            return;
        }

    //Load data
        await GetData();

    //Success
        ToastService.ShowSuccess("Wallet imported successfully");

    //Close modal
        await CloseAndCleanImportWalletModal();
    }

    private async Task ShowImportWalletModal()
    {
        _seedphrase = string.Empty;
        _name = string.Empty;
        _description = string.Empty;
        _derivationPath = string.Empty;

        await _importWalletModal?.Show();
    }

    private async Task ValidateDerivationPath(ValidatorEventArgs arg1, CancellationToken arg2)
    {
        arg1.Status = ValidationStatus.Success;

    //if the string is empty, it is not valid

        if (string.IsNullOrEmpty(arg1.Value.ToString()))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid derivation path";
            return;
        }

        if (!KeyPath.TryParse(arg1.Value.ToString() ?? string.Empty, out _))
        {
    //error
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid derivation path";
        }
    }


    private async Task ValidateSeedphrase(ValidatorEventArgs arg1, CancellationToken arg2)
    {
    //Create a Mnemonic and validate it
        try
        {
            var mnemonic = new Mnemonic(arg1.Value.ToString());
            var isValid = mnemonic.IsValidChecksum;

            if (!isValid)
            {
                arg1.Status = ValidationStatus.Error;
                arg1.ErrorText = "Invalid seedphrase";
            }
            else
            {
                arg1.Status = ValidationStatus.Success;
            }
        }
        catch (Exception e)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid seedphrase";
        }
    }

    private async Task CopyStrToClipboard(string arg)
    {
        await ClipboardService.WriteTextAsync(arg);
        ToastService.ShowSuccess("Address copied");
    }

    private async Task ShowWallets()
    {
        _showNotAvailableWallets = !_showNotAvailableWallets;
        await GetData();
    }

    private bool OnCustomFilter(object item, object value)
    {
        bool anyCheck = _archivedWalletFilter || _compromisedWalletFilter || _hotWalletFilter || _coldWalletFilter || _finalizedWalletFilter;
        if (!anyCheck)
            return true;

        if ((bool)value)
        {
            return (bool)item == (bool)value;
        }
        return true;
    }
}