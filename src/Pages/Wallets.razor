@page "/wallets"
@using System.Security.Claims
@using System.Linq;
@using Blazorise.Extensions
@using NodeGuard.Jobs
@using Humanizer
@using NBitcoin
@using NBXplorer.DerivationStrategy
@using Quartz
@using Field = Blazorise.Field
@using Key = NodeGuard.Data.Models.Key
@inject IWalletRepository WalletRepository
@inject IToastService ToastService
@inject IApplicationUserRepository ApplicationUserRepository
@inject IWalletWithdrawalRequestRepository WalletWithdrawalRequestRepository
@inject IWalletWithdrawalRequestPsbtRepository WalletWithdrawalRequestPsbtRepository
@inject IKeyRepository KeyRepository
@inject IBitcoinService BitcoinService
@inject ILightningService LightningService
@inject ILocalStorageService LocalStorageService
@inject ISchedulerFactory SchedulerFactory
@inject IPriceConversionService PriceConversionService
@inject IInternalWalletRepository InternalWalletRepository

@attribute [Authorize(Roles = "NodeManager, FinanceManager, Superadmin")]

<h3 class="custom-primary">Treasury Wallets</h3>
<Row>
    <Column ColumnSize="ColumnSize.Is12">
        <DataGrid TItem="Wallet"
                  @ref="_walletsDataGrid"
                  @bind-SelectedRow="_selectedWallet"
                  Data="_wallets"
                  Editable="@_isFinanceManager"
                  EditMode="DataGridEditMode.Popup"
                  Responsive="true"
                  ResizeMode="TableResizeMode.Columns"
                  UseInternalEditing="true"
                  RowInserted="OnRowInserted"
                  RowRemoving="OnRowRemoving"
                  RowUpdated="OnRowUpdated"
                  DetailRowStartsVisible="false"
                  NewItemDefaultSetter="NewItemDefaultSetter"
                  ShowPager="true"
                  ShowPageSizes="true"
                  PageSize="25"
                  Filterable="true"
                  UseValidation="true"
                  CustomFilter="OnWalletCustomFilter">
            <PopupTitleTemplate>
                <h2>@(context.EditState) wallet</h2>
            </PopupTitleTemplate>
            <DataGridColumns>
                <DataGridCommandColumn TItem="Wallet">
                    <NewCommandTemplate>
                        @if (_isFinanceManager)
                        {
                            <Dropdown>
                                <DropdownToggle Color="Color.Primary">
                                </DropdownToggle>
                                <DropdownMenu>

                                    <DropdownItem Clicked="context.Clicked">New</DropdownItem>
                                    <DropdownItem Clicked="@(() => ShowImportWalletModal())">Import Wallet</DropdownItem>

                                </DropdownMenu>
                            </Dropdown>
                        }

                    </NewCommandTemplate>
                    <EditCommandTemplate>
                        <Dropdown>
                            <DropdownToggle Color="Color.Primary">
                            </DropdownToggle>
                            <DropdownMenu>

                                <DropdownItem Clicked="context.Clicked">Edit</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => LoadAndOpenTextModalBalance(context.Item))">Balance</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => LoadAndOpenModalTextModalUnusedAddress(context.Item))">Get address</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised || context.Item.IsWatchOnly" Clicked="@(() => ShowTransferFundsModal(context.Item))">Transfer funds</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => RescanWallet(context.Item))">Rescan wallet</DropdownItem>
                                <DropdownItem Disabled="!context.Item.IsFinalised" Clicked="@(() => LoadAndOpenExportOutputDescriptor(context.Item))">Export output descriptor</DropdownItem>

                            </DropdownMenu>
                        </Dropdown>
                    </EditCommandTemplate>
                    <DeleteCommandTemplate>
                        @if (!context.Item.IsFinalised)
                        {
                            <Button Color="Color.Danger" Clicked="@context.Clicked" @onclick:stopPropagation="true" Block>Delete</Button>
                        }
                    </DeleteCommandTemplate>
                </DataGridCommandColumn>
                <DataGridColumn TItem="Wallet" Filterable="false" ShowCaption="false" Sortable="false">
                    <DisplayTemplate>
                        @if (!context.IsFinalised && !context.IsSingleSig)
                        {
                            <Button Color="Color.Info" Clicked="@(() => LoadAndOpenModal(context))" @onclick:stopPropagation="true">Add key</Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Filterable="false" ShowCaption="false" Sortable="false" Width="140px">
                    <DisplayTemplate>
                        @if (!context.IsFinalised)
                        {
                            <Button Color="Color.Warning" Clicked="@(() => LoadAndOpenFinaliseTextModal(context))" Block @onclick:stopPropagation="true">Finalise</Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.Name)" Caption="@nameof(Wallet.Name)" Sortable="false" Displayable="@IsColumnVisible(WalletsColumnName.Name)">
                    <EditTemplate>
                        <Validation Validator="@ValidationHelper.ValidateName">
                            <TextEdit Text="@((string) context.CellValue)" TextChanged="(text) => { context.CellValue = text; }">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </TextEdit>
                        </Validation>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.Description)" Caption="@nameof(Wallet.Description)" Sortable="false" Displayable="@IsColumnVisible(WalletsColumnName.Description)"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Caption="Hot Wallet" Field="@nameof(Wallet.IsHotWallet)" Editable="true">
                    <EditTemplate>
                        <Check TValue="bool" Disabled="@(context.Item.IsFinalised)" Checked="@((bool) context.CellValue)" CheckedChanged="(value) => OnCheckedChanged(context, value)" @ref="_hotWalletCheckComponent"/>
                    </EditTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Caption="Cold Wallet" Field="@nameof(Wallet.IsHotWallet)" Editable="false"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Caption="Finalised" Field="@nameof(Wallet.IsFinalised)" Editable="false"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Caption="Archived" Field="@nameof(Wallet.IsArchived)" Editable="true" CellsEditableOnNewCommand="false"/>
                <DataGridColumn TItem="Wallet" Displayable="false" Filterable="true" Caption="Compromised" Field="@nameof(Wallet.IsCompromised)" Editable="true" CellsEditableOnNewCommand="false"/>
                <DataGridSelectColumn TItem="Wallet" Sortable="false" Filterable="true" Displayable="@IsColumnVisible(WalletsColumnName.WalletProperties)">
                    <FilterTemplate>
                        <Dropdown>
                            <DropdownToggle>Select</DropdownToggle>
                            <DropdownMenu>
                                <div class="checkbox-drop">
                                    <Check TValue="bool" CheckedChanged="@(() => { _hotWalletFilter = !_hotWalletFilter; OnCheckedChanged(true); })">üî• Hot Wallet</Check>
                                    <Check TValue="bool" CheckedChanged="@(() => { _coldWalletFilter = !_coldWalletFilter; OnCheckedChanged(true); })">‚ùÑÔ∏è Cold Wallet</Check>
                                    <Check TValue="bool" CheckedChanged="@(() => { _finalisedWalletFilter = !_finalisedWalletFilter; OnCheckedChanged(true); })">üèÅ finalised</Check>
                                    <Check TValue="bool" CheckedChanged="@(() => { _archivedWalletFilter = !_archivedWalletFilter; OnCheckedChanged(true); })">üìÇ Archived</Check>
                                    <Check TValue="bool" CheckedChanged="@(() => { _compromisedWalletFilter = !_compromisedWalletFilter; OnCheckedChanged(true); })">‚õîÔ∏è Compromised</Check>
                                </div>
                            </DropdownMenu>
                        </Dropdown>
                    </FilterTemplate>
                    <CaptionTemplate>
                        <span>
                            Wallet Properties
                        </span>
                        <span title="@("üî• Hot Wallet\n‚ùÑÔ∏è Cold Wallet\nüèÅ Finalised\nüìÇ Archived\n‚õîÔ∏è Compromised")">
                            @("\u24D8")
                        </span>
                    </CaptionTemplate>
                    <DisplayTemplate>
                        @{
                            string walletProperties = "";
                            if (context.IsHotWallet) walletProperties = walletProperties + "üî• ";
                            else walletProperties = walletProperties + "‚ùÑÔ∏è ";
                            if (context.IsFinalised) walletProperties = walletProperties + "üèÅ ";
                            if (context.IsArchived) walletProperties = walletProperties + "üìÇ ";
                            if (context.IsCompromised) walletProperties = walletProperties + "‚õîÔ∏è ";
                            <span>@walletProperties</span>
                        }
                    </DisplayTemplate>
                </DataGridSelectColumn>
                <DataGridNumericColumn TItem="Wallet" Decimals="0" Editable="true" Field="@nameof(Wallet.MofN)" Caption="Threshold" Sortable="false" Displayable="@IsColumnVisible(WalletsColumnName.Threshold)">
                    <EditTemplate>
                        <Validation Validator="@ValidateThreshold">
                            <NumericEdit TValue="int" Value="@(IsHotWallet(_hotWalletCheckComponent) ? 1 : (int) context.CellValue)" Disabled="@(context.Item.IsFinalised || IsHotWallet(_hotWalletCheckComponent))" ValueChanged="(value) => { context.CellValue = value; }">
                                <Feedback>
                                    <ValidationError/>
                                </Feedback>
                            </NumericEdit>
                        </Validation>
                    </EditTemplate>
                </DataGridNumericColumn>
                <DataGridColumn TItem="Wallet" Editable="true" Field="@nameof(Wallet.ReferenceId)" Caption="Reference Id" Sortable="true" Displayable="@IsColumnVisible(WalletsColumnName.ReferenceId)"/>
                <DataGridColumn TItem="Wallet" Field="@nameof(Wallet.CreationDatetime)" Caption="Creation Date" Sortable="true" SortDirection="SortDirection.Descending" Displayable="@IsColumnVisible(WalletsColumnName.CreationDate)">
                    <DisplayTemplate>
                        @context.CreationDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Field="@nameof(Wallet.UpdateDatetime)" Caption="Update date" Sortable="true" Displayable="@IsColumnVisible(WalletsColumnName.UpdateDate)">
                    <DisplayTemplate>
                        @context.UpdateDatetime.Humanize()
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Wallet" Displayable="true">
                    <FilterTemplate>
                        <ColumnLayout @ref="WalletsColumnLayout" Columns="@WalletsColumns" ColumnType="WalletsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                    </FilterTemplate>
                </DataGridColumn>
            </DataGridColumns>
            <DetailRowTemplate>
                @{
                    var keys = (context as Wallet).Keys?.ToList() ?? new List<Key>();
                    <ReadOnlyKeyDatagrid Keys="@keys"></ReadOnlyKeyDatagrid>
                }
            </DetailRowTemplate>
        </DataGrid>
    </Column>
</Row>
<Modal @ref="_modalRef">
    <ModalContent Centered Size="ModalSize.ExtraLarge">
        <ModalHeader>
            <ModalTitle>Please select the key will be added this wallet</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Field>
                <FieldLabel>Select the Finance user(s) who will be a co-approver</FieldLabel>
                <SelectList TItem="ApplicationUser"
                            TValue="string"
                            Data="@_financeManagers"
                            TextField="@((item) => item.UserName)"
                            ValueField="@((item) => item.Id)"
                            SelectedValueChanged="@OnSelectedFinanceManager"
                            DefaultItemText="Choose the approver"/>

            </Field>
            @if (_selectedFinanceManager != null && _selectedFinanceManagerAvailableKeys.Any())
            {
                <Field>
                    <FieldLabel>Select the Finance user(s) key</FieldLabel>
                    <SelectList TItem="Key"
                                TValue="int"
                                Data="@_selectedFinanceManagerAvailableKeys"
                                TextField="@((item) => $"{item.Name}-{StringHelper.TruncateHeadAndTail(item.XPUB, 10)}")"
                                ValueField="@((item) => item.Id)"
                                SelectedValueChanged="@OnSelectedWalletKey"
                                DefaultItemText="Choose the key of the manager"/>
                </Field>
            }
            else
            {
                <Alert Color="Color.Warning" Visible>
                    <AlertMessage>No keys found!</AlertMessage>
                    <AlertDescription>No keys are available for this Finance Manager, either are archived/compromised or already used.</AlertDescription>

                </Alert>
            }

            <Field>
                <Alert Color="Color.Info" Visible>
                    <AlertMessage>Below you will find the key that form this wallet</AlertMessage>
                    <AlertDescription>Take into account that the NodeGuard key will be always be added to your wallet by the system</AlertDescription>

                </Alert>
                <ReadOnlyKeyDatagrid Keys="@_selectedWalletKeysPlusInternalWalletKey"></ReadOnlyKeyDatagrid>
            </Field>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseModal">Cancel</Button>
            <Button Color="Color.Primary" Clicked="@SaveAndCloseModal">Add</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_textModalRef">
    <ModalContent Centered Size="ModalSize.Large">
        <ModalHeader>
            <ModalTitle>@_textModalTitle</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <p>@_textModalContent</p>
        </ModalBody>
        <ModalFooter>
            @if (_textModalCopy)
            {
                <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard(_textModalContent))">Copy and close</Button>
            }
        </ModalFooter>
    </ModalContent>
</Modal>
<Modal @ref="_finaliseModalRef">
    <ModalContent Centered Size="ModalSize.Default">
        <ModalHeader>
            <ModalTitle>Do you want to finalise this wallet?</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <p>If you confirm to finalise this wallet, it will become a ready-to-use wallet for the system but at the same time you won't be allowed to update it in terms of keys, thresholds and other configuration parameters</p>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseAndCleanFinaliseModal">Close</Button>
            <Button Color="Color.Primary" Clicked="@FinaliseWallet">Finalise</Button>

        </ModalFooter>
    </ModalContent>
</Modal>
<Modal @ref="_importWalletModal">
    <ModalContent Centered Size="ModalSize.Default">
        <ModalHeader>
            <ModalTitle>Import external wallet</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Fields>
                <Validations @ref="_importWalletValidations">
                    <Column ColumnSize="ColumnSize.Is12">
                        <Validation Validator="ValidationRule.IsNotEmpty">
                            <Field>
                                <FieldLabel>Name</FieldLabel>
                                <FieldBody>
                                    <TextEdit @bind-Text="@_name">
                                        <Feedback>
                                            <ValidationNone>Enter a valid name</ValidationNone>
                                            <ValidationError>Invalid name</ValidationError>
                                        </Feedback>
                                    </TextEdit>
                                </FieldBody>
                            </Field>
                        </Validation>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is12">
                        <Field>
                            <FieldLabel>Description</FieldLabel>
                            <FieldBody>
                                <MemoEdit @bind-Text="@_description" Rows="4">
                                    <Feedback>
                                        <ValidationNone>Enter a valid description</ValidationNone>
                                        <ValidationError>Invalid description</ValidationError>
                                    </Feedback>
                                </MemoEdit>
                            </FieldBody>
                        </Field>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is12">
                        <Field>
                            <FieldLabel>Watch-only</FieldLabel>
                            <FieldHelp>Switch on if you want to import a watch-only wallet</FieldHelp>
                            <FieldBody>
                                <Switch TValue="bool" @bind-Checked="@_IsImportWalletModalWatchOnly"></Switch>
                            </FieldBody>
                        </Field>
                    </Column>
                    @if (_IsImportWalletModalWatchOnly)
                    {
                        <Alert Color="Color.Warning" Visible>
                            <AlertMessage></AlertMessage>
                            <AlertDescription> Watch-only wallets cannot be used to open channels in NodeGuard for security reasons(check async channel funding). Watch-only wallets should be used specifically as a target for rebalancing operations (reverse submarine swaps) or when you want to sweep funds to a wallet you don't control the keys and its not managed by NodeGuard. If you want to use multisigs, we don't recommend using imported watch-only wallets for other uses cases than the mentioned here.</AlertDescription>
                        </Alert>
                        <Alert Color="Color.Info" Visible>
                            <AlertMessage></AlertMessage>
                            <AlertDescription>
                                Only segwit descriptors for single sig(WPKH) or multisigs (WSH) are supported.
                                <br/>
                                Singlesig: <code>wpkh([‚Ä¶/84'/0'/0']xpub‚Ä¶/0/*)</code>
                                <br/>
                                Multisig: <code>wsh(sortedmulti(2,[‚Ä¶/48'/0'/0'/2']xpub‚Ä¶/0/*,[‚Ä¶/48'/0'/0'/2']xpub‚Ä¶/0/*))</code>
                            </AlertDescription>
                        </Alert>

                        <Column ColumnSize="ColumnSize.Is12">
                            <Validation AsyncValidator="@ValidateOutputDescriptor">
                                <Field>
                                    <FieldLabel>Output descriptor</FieldLabel>
                                    <FieldHelp>Segwit descriptor (Singlesig or multisig)</FieldHelp>
                                    <FieldBody>
                                        <MemoEdit @bind-Text="@_outputDescriptor" Rows="4">
                                            <Feedback>
                                                <ValidationNone>Enter a valid descriptor</ValidationNone>
                                                <ValidationError>Invalid descriptor</ValidationError>
                                            </Feedback>
                                        </MemoEdit>
                                    </FieldBody>
                                </Field>
                            </Validation>
                        </Column>
                    }
                    else
                    {
                        <Alert Color="Color.Warning" Visible>
                            <AlertMessage></AlertMessage>
                            <AlertDescription>
                                @if (@Constants.ENABLE_REMOTE_SIGNER)
                                {
                                    <p>Remote signer is enabled, therefore the seedphrase <b>won't be stored in NodeGuard database.</b>. Take into account that a seedphrase will leak all the subwallets you have on it.</p>
                                }
                                else
                                {
                                    <p>Remote signer is not enabled, therefore the seedphrase will be stored as plain-text in the NodeGuard database, please reconsider your security threat model based on this. Take into account that a seedphrase will leak all the subwallets you have on it.</p>
                                }
                            </AlertDescription>
                        </Alert>
                        <Column ColumnSize="ColumnSize.Is12">
                            <Validation AsyncValidator="@ValidateSeedphrase">
                                <Field>
                                    <FieldLabel>Seedphrase</FieldLabel>
                                    <FieldHelp>Paste your seedphrase (English wordlist only)</FieldHelp>
                                    <FieldBody>
                                        <MemoEdit @bind-Text="@_seedphrase" Rows="4">
                                            <Feedback>
                                                <ValidationNone>Enter a valid seedphrase</ValidationNone>
                                                <ValidationError>Invalid seedphrase</ValidationError>
                                            </Feedback>
                                        </MemoEdit>
                                    </FieldBody>
                                </Field>
                            </Validation>
                        </Column>
                        <Column ColumnSize="ColumnSize.Is12">
                            <Validation AsyncValidator="ValidateDerivationPath">
                                <Field>
                                    <FieldLabel>Derivation path</FieldLabel>
                                    <FieldBody>
                                        <TextEdit @bind-Text="@_derivationPath">
                                            <Feedback>
                                                <ValidationNone>Enter a valid derivation path</ValidationNone>
                                                <ValidationError>Invalid derivation path</ValidationError>
                                            </Feedback>
                                        </TextEdit>
                                    </FieldBody>
                                </Field>
                            </Validation>
                        </Column>
                    }
                </Validations>
            </Fields>

        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseAndCleanImportWalletModal">Close</Button>
            <Button Color="Color.Primary" Clicked="@ImportWallet">Import</Button>

        </ModalFooter>
    </ModalContent>
</Modal>
<Modal @ref="_transferFundsModal">
    <ModalContent Centered Size="ModalSize.Large">
        <ModalHeader>
            <ModalTitle>Transfer funds to another wallet</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Fields>
                <Validations @ref="_transferFundsValidations">
                    <Column ColumnSize="ColumnSize.Is6">
                        <Validation Validator="args => ValidationHelper.ValidateWithdrawalAmount(args)">
                            <Field>
                                <FieldLabel>Amount</FieldLabel>
                                <FieldBody>
                                    <NumericPicker TValue="decimal" Disabled="_transferAllFunds" @bind-Value="@_amountToTransfer" CurrencySymbol="‚Çø " Max="@_maxWithdrawal" Min="@_minWithdrawal" Decimals="8"/>
                                </FieldBody>
                                <FieldHelp>
                                    @($"Current amount: {Math.Round(PriceConversionService.BtcToUsdConversion((decimal) _amountToTransfer, _btcPrice), 2)} USD")
                                </FieldHelp>
                            </Field>
                        </Validation>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is6">
                        <Field>
                            <FieldBody>
                                <Check TValue="bool" @bind-Checked="@_transferAllFunds">Transfer all funds</Check>
                            </FieldBody>
                        </Field>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is6" @bind-Value="@_amountToTransfer">
                        <Field>
                            <FieldLabel><strong>From</strong> (this wallet)</FieldLabel>
                            <FieldBody>
                                <div class="flex-container">
                                    <p class="source-wallet-name">@_sourceWalletName</p>
                                    <div class="arrow-icon-container">
                                        <Icon Name="IconName.ArrowRight" class="arrow-icon" />
                                    </div>
                                </div>
                            </FieldBody>
                            <FieldHelp class="field-help">
                                 @($"Current balance: {_sourceWalletBalance:F8}");
                            </FieldHelp>
                            <FieldHelp>
                                @($"Balance after transfer: {CalculateAmountWalletSourceAfterTransaction():F8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(_sourceBalanceAfterTransaction, _btcPrice), 2)} USD)")
                            </FieldHelp>
                        </Field>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is6" @bind-Value="@_amountToTransfer">
                        <Validation Validator="@ValidationRule.IsSelected" >
                            <Field>
                                <FieldLabel><strong>To</strong></FieldLabel>
                                <FieldBody>
                                    <SelectList TItem="Wallet"
                                                TValue="int"
                                                DefaultItemDisabled
                                                Data="_walletsForTransfer"
                                                TextField="@((item) => item.Name)"
                                                ValueField="@((item) => item.Id)"
                                                SelectedValue="@_selectedTransferWalletId"
                                                SelectedValueChanged="(id) => OnSelectedWallet(id)"
                                                DefaultItemText="Choose the wallet">
                                        <Feedback>
                                            <ValidationError>You must select a valid wallet</ValidationError>
                                        </Feedback>
                                    </SelectList>
                                </FieldBody>
                                <FieldHelp Visibility="@(_transferTargetWalletBalance.IsNullOrEmpty() ? Visibility.Invisible : Visibility.Visible)">
                                    @($"Current balance: {_transferTargetWalletBalance:f8}")
                                </FieldHelp>
                                <FieldHelp Visibility="@(_transferTargetWalletBalance.IsNullOrEmpty() ? Visibility.Invisible : Visibility.Visible)">
                                    @($"Balance after transfer: {CalculateAmountWalletTargetAfterTransaction():F8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal)(targetBalance + _amountToTransfer), _btcPrice), 2)} USD)")
                                </FieldHelp>
                            </Field>
                        </Validation>
                    </Column>
                </Validations>
            </Fields>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseAndCleanTransferFundsModal">Close</Button>
            <Button Color="Color.Primary" Clicked="@TransferFunds">Transfer</Button>

        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_exportOutputDescriptorModal">
    <ModalContent Size="ModalSize.Large">
        <ModalHeader>
            @($"Export wallet") 
        </ModalHeader>
        <ModalBody>
            <p>Copy the output descriptor below and use it to import this wallet in other systems.</p>
            <p>Only segwit descriptors for single sig(WPKH) or multisigs (WSH) are supported.</p>
            <p>Singlesig: <code>wpkh([‚Ä¶/84'/0'/0']xpub‚Ä¶/0/*)</code></p>
            <p>Multisig: <code>wsh(sortedmulti(2,[‚Ä¶/48'/0'/0'/2']xpub‚Ä¶/0/*,[‚Ä¶/48'/0'/0'/2']xpub‚Ä¶/0/*))</code></p>
            <Paragraph>
                @(StringHelper.TruncateHeadAndTail(_outputDescriptorContentModal, 25))
                <Button Color="Color.Primary" Clicked="@(()=> CopyStrToClipboard(_outputDescriptorContentModal))">Copy</Button>
            </Paragraph>
            @{
                foreach(var k in _keysContentModal)
                {
                    <p>
                        @($"{k.Name}: {k.Path}")
                        <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard(k.Path))">Copy</Button>
                    </p>
                }
            }
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@CloseExportOutputDescriptorModal">Close</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<ConfirmationModal
    @ref="_multisigTransferModal"
    Title="Transferring from a multisig wallet"
    Body="Your transfer request was succesfully done. Please, go to Withdrawals page to sign for this transfer."
    CancelLabel="Yes, understood"
    OnCancel="CloseMultisigTransferModal"/>
<ConfirmationModal
    @ref="_hotWalletTransferModal"
    Title="Are you sure?"
    Body="You're about to transfer funds from this wallet. This means that the system will automatically use the funds in it without the need of manual approval. Are you sure you want to perform this operation?"
    OkLabel="Yes, understood"
    OnCancel="CloseHotWalletTransferModal"
    OnSubmit="TransferFundsHotWallet"/>
    

@code {

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal ClaimsPrincipal { get; set; }

    private List<ApplicationUser> _financeManagers = new();

    private Modal _modalRef;

    private List<Wallet> _wallets = new();

    private Wallet? _selectedWallet;

    private ApplicationUser? _selectedFinanceManager;

    private List<Key> _selectedWalletKeysPlusInternalWalletKey = new();
    private List<Key> _selectedFinanceManagerAvailableKeys = new();
    private Key? _selectedWalletKey;
    
    private Modal _exportOutputDescriptorModal;
    private string _outputDescriptorContentModal;
    private HashSet<Key> _keysContentModal = new();

    private Modal _textModalRef;
    private string _textModalTitle = string.Empty;
    private string _textModalContent = string.Empty;
    private bool _textModalCopy;

    private Modal _finaliseModalRef;
    private Wallet? _selectedWalletToFinalise;

    private bool _isFinanceManager = false;

    private decimal _btcPrice;

    private Check<bool> _hotWalletCheckComponent;

    private Modal? _importWalletModal;
    private string? _importWalletSeedphrase;
    private Validations _importWalletValidations;
    private Validations? _walletValidation;
    private Modal? _transferFundsModal;
    private Validations _transferFundsValidations;
    private List<Wallet> _walletsForTransfer = new();
    private int _selectedTransferWalletId;
    private Wallet? _sourceTransferWallet;
    private Wallet? _targetTransferWallet;
    private string _sourceWalletName => _sourceTransferWallet != null ? $"{_sourceTransferWallet.Name} " : "";
    private string _targetWalletName => _targetTransferWallet != null ? $"{_targetTransferWallet.Name} " : "";
    private string _transferTargetWalletBalance;
    private decimal targetBalance;
    private decimal _sourceBalance;
    private decimal _sourceBalanceAfterTransaction => _sourceBalance > _amountToTransfer ? _sourceBalance - _amountToTransfer : 0;
    private string _sourceWalletBalance;
    private bool _transferAllFunds;
    private decimal _maxWithdrawal = Constants.MAXIMUM_WITHDRAWAL_BTC_AMOUNT;
    private decimal _minWithdrawal = Constants.MINIMUM_WITHDRAWAL_BTC_AMOUNT;
    private decimal _amountToTransfer { get; set; }
    private ConfirmationModal _multisigTransferModal;
    private ConfirmationModal _hotWalletTransferModal;

    /// Used to change the modal view for the import wallet, true means that output descriptors will be used intead of seedphrase
    private bool _IsImportWalletModalWatchOnly = false;


    private string _seedphrase = string.Empty;
    private string _name = string.Empty;
    private string _description = string.Empty;
    private string _derivationPath = string.Empty;

    private bool _hotWalletFilter = false;
    private bool _coldWalletFilter = false;
    private bool _finalisedWalletFilter = false;
    private bool _archivedWalletFilter = false;
    private bool _compromisedWalletFilter = false;
    private DataGrid<Wallet> _walletsDataGrid;

    private ColumnLayout<WalletsColumnName> WalletsColumnLayout;
    private Dictionary<string, bool> WalletsColumns = new();
    private bool columnsLoaded;

    private string? _outputDescriptor;

    public abstract class WalletsColumnName
    {
        public static readonly ColumnDefault Name = new("Name");
        public static readonly ColumnDefault Description = new("Description");
        public static readonly ColumnDefault WalletProperties = new("Wallet Properties");
        public static readonly ColumnDefault Threshold = new("Threshold");
        public static readonly ColumnDefault ReferenceId = new("ReferenceId");
        public static readonly ColumnDefault CreationDate = new("CreationDate");
        public static readonly ColumnDefault UpdateDate = new("UpdateDate");
    }

    protected override async Task OnInitializedAsync()
    {
        _btcPrice = await PriceConversionService.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }
        if (LoggedUser != null)
        {
            if (ClaimsPrincipal.IsInRole(ApplicationUserRole.FinanceManager.ToString()))
            {
                _isFinanceManager = true;
            }
            await GetData();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private async Task LoadColumnLayout()
    {
        WalletsColumns = await LocalStorageService.LoadStorage(nameof(WalletsColumnName), ColumnHelpers.GetColumnsDictionary<WalletsColumnName>());
        columnsLoaded = true;
        StateHasChanged();
    }

    private async Task GetData()
    {
        _wallets = await WalletRepository.GetAll();
        var financeManagers = (await ApplicationUserRepository.GetUsersInRole(ApplicationUserRole.FinanceManager));
        _financeManagers = financeManagers.Where(x => x.Keys.Any()).ToList();

        if (_financeManagers.Any())
            _selectedFinanceManager = financeManagers.FirstOrDefault();
        if (_selectedFinanceManager?.Keys != null)
            _selectedFinanceManagerAvailableKeys = await FilterKeys(_selectedFinanceManager.Keys);
    }


    private async Task OnRowInserted(SavedRowItem<Wallet, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;

        if (arg.Item.IsHotWallet) arg.Item.MofN = 1;

        var addResult = await WalletRepository.AddAsync(arg.Item);


        if (addResult.Item1)
        {
            ToastService.ShowSuccess("Success");
            await GetData();
        }
        else
        {
            ToastService.ShowError("Something went wrong");
            _wallets.Remove(arg.Item);
        }
    }

    private void NewItemDefaultSetter(Wallet obj)
    {
        obj.WalletAddressType = WalletAddressType.NativeSegwit;
    }

    private async Task OnRowRemoving(CancellableRowChange<Wallet> arg)
    {
        if (arg.Item != null)
        {
            var (result, message) = WalletRepository.Remove(arg.Item);

            if (!result)
            {
                arg.Cancel = true;
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess("Success");
                await GetData();
            }
        }
    }

    private decimal CalculateAmountWalletTargetAfterTransaction()
    {
        decimal amount = _transferAllFunds ? targetBalance + _sourceBalance : targetBalance + _amountToTransfer;
        return amount;
    }

    private decimal CalculateAmountWalletSourceAfterTransaction()
    {
        if (_transferAllFunds)
        {
            return 0;
        }
        return _sourceBalanceAfterTransaction;
    }

    
    private async Task OnRowUpdated(SavedRowItem<Wallet, Dictionary<string, object>> arg)
    {
        if (arg.Item == null) return;

        if (arg.Item.IsHotWallet) arg.Item.MofN = 1;

        var updateResult = WalletRepository.Update(arg.Item);

        if (updateResult.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Something went wrong");
        }

        await GetData();
    }

    private async Task CloseModal()
    {
        CleanModal();
        await _modalRef.Close(CloseReason.UserClosing);
    }

    private void CleanModal()
    {
        _selectedWalletKeysPlusInternalWalletKey = new List<Key>();
        _selectedFinanceManager = _financeManagers.FirstOrDefault();
        _selectedFinanceManagerAvailableKeys = new();

        _selectedWallet = null;
    }

    private async Task LoadAndOpenModal(Wallet wallet)
    {
        CleanModal();
        _selectedWallet = await WalletRepository.GetById(wallet.Id);


        if (_selectedWallet != null)
        {
            await GetData();

    //Modal data
            await GetModalDefaultData();


            await _modalRef.Show();
        }
    }

    private async Task SaveAndCloseModal()
    {
        if (_selectedWallet == null) return;

    //Add the key

        if (_selectedWalletKey != null)
        {
            if (_selectedWallet.Keys == null)
            {
                ToastService.ShowError("No co-signer key found");
                return;
            }

            _selectedWallet.Keys.Add(_selectedWalletKey);

            var updateResult = WalletRepository.Update(_selectedWallet);

            if (updateResult.Item1)
            {
                ToastService.ShowSuccess("Key added");
            }
            else
            {
                ToastService.ShowError("Error while adding key...");
            }
        }


        CleanModal();

        await GetData();

        await _modalRef.Close(CloseReason.UserClosing);
    }

    private async Task OnSelectedFinanceManager(string applicationUserId)

    {
        if (!string.IsNullOrWhiteSpace(applicationUserId))
        {
            var applicationUser = await ApplicationUserRepository.GetById(applicationUserId);
            _selectedFinanceManager = applicationUser;
            if (_selectedFinanceManager != null && _selectedFinanceManager.Keys.Any() && _selectedWallet != null)
            {
    //Filter Keys
                _selectedFinanceManagerAvailableKeys = await FilterKeys(_selectedFinanceManager.Keys);
            }
        }
    }

    private async Task<List<Key>> FilterKeys(ICollection<Key> keys)
    {
        var result = new List<Key>();
        if (_selectedWallet != null && _selectedWallet.Keys != null)
        {
            result = keys.Where(x => !x.IsArchived && !x.IsCompromised && x.InternalWalletId == null).Except(_selectedWallet.Keys)
                .ToList();
        }
        else
        {
            result = keys.Where(x => !x.IsArchived && !x.IsCompromised && x.InternalWalletId == null)
                .ToList();
        }

        return result;
    }

    private async Task OnSelectedWalletKey(int keyId)
    {
        _selectedWalletKeysPlusInternalWalletKey = new List<Key>();

        if (keyId > 0)
        {
            var selectedKey = await KeyRepository.GetById(keyId);

            if (selectedKey != null)
            {
                _selectedWalletKey = selectedKey;

                _selectedWalletKeysPlusInternalWalletKey.Add(selectedKey);
            }
        }

        await GetModalDefaultData();
    }

    private async Task GetModalDefaultData()
    {
        if (_selectedWallet != null)
            _selectedWalletKeysPlusInternalWalletKey.AddRange(_selectedWallet.Keys.ToList());

        var currentInternalWalletKey = await KeyRepository.GetCurrentInternalWalletKey(_selectedWallet.InternalWalletSubDerivationPath);

    //TODO What happens when the internal wallet changes? This is not correct, FUTURE FIX required
        if (!_selectedWalletKeysPlusInternalWalletKey.Any(x => x.Id == currentInternalWalletKey.Id))
        {
            _selectedWalletKeysPlusInternalWalletKey.Add(currentInternalWalletKey);
        }
    }

    private async Task CleanTextModal()
    {
        _textModalContent = string.Empty;
        _textModalTitle = string.Empty;
    }

    private async Task CloseTextModal()
    {
        await CleanTextModal();

        await _textModalRef.Close(CloseReason.UserClosing);
    }

    private async Task LoadAndOpenTextModalBalance(Wallet wallet)
    {
        await CleanTextModal();
        if (wallet != null)
        {
            var balance = await LightningService.GetWalletBalance(wallet);

            if (balance != null)
            {
                _textModalTitle = $"Wallet: {wallet.Name} On-chain Balance";
                _textModalContent = $"Confirmed: {((Money) balance.Confirmed).ToUnit(MoneyUnit.BTC):f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(((Money) balance.Confirmed).ToUnit(MoneyUnit.BTC), _btcPrice), 2)} USD) - " +
                                    $"Unconfirmed: {((Money) balance.Unconfirmed).ToUnit(MoneyUnit.BTC):f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion(((Money) balance.Unconfirmed).ToUnit(MoneyUnit.BTC), _btcPrice), 2)} USD)";
                _textModalCopy = false;

                await _textModalRef.Show();
            }
            else
            {
                ToastService.ShowError("Error while getting the wallet on-chain balance");
            }
        }
    }

    private async Task LoadAndOpenModalTextModalUnusedAddress(Wallet wallet)
    {
        await CleanTextModal();
        if (wallet != null)
        {
            var bitcoinAddress = await LightningService.GetUnusedAddress(wallet, DerivationFeature.Deposit);

            if (bitcoinAddress != null)
            {
                _textModalTitle = $"Wallet: {wallet.Name} - Unused BTC Address for funding this wallet";
                _textModalContent = bitcoinAddress.ToString();
                _textModalCopy = true;
                await _textModalRef.Show();
            }
            else
            {
                ToastService.ShowError("Error while getting the wallet on-chain balance");
            }
        }
    }

    private async Task LoadAndOpenFinaliseTextModal(Wallet wallet)
    {
        _selectedWalletToFinalise = wallet;

        await _finaliseModalRef.Show();
    }

    private async Task FinaliseWallet()
    {
        if (_selectedWalletToFinalise == null || _selectedWalletToFinalise.IsFinalised)
            return;


        var result = await WalletRepository.FinaliseWallet(_selectedWalletToFinalise);

        if (result.Item1)
        {
            ToastService.ShowSuccess("Success");
        }
        else
        {
            ToastService.ShowError("Error while marking wallet as finalised");
        }

        _selectedWalletToFinalise = null;

        await _finaliseModalRef.Close(CloseReason.UserClosing);

        await GetData();
    }

    private async Task CloseAndCleanFinaliseModal()
    {
        _selectedWalletToFinalise = null;
        await _finaliseModalRef.Close(CloseReason.UserClosing);
    }


    private void ValidateThreshold(ValidatorEventArgs obj)
    {
        obj.Status = ValidationStatus.Success;
        if (obj.Value is int threshold)
        {
            if (threshold < 2 || threshold > 5)
            {
                obj.ErrorText = "The threshold should be minimum 2 and maximum 5";
                obj.Status = ValidationStatus.Error;
            }
        }
    }

    private void OnCheckedChanged(CellEditContext<Wallet> context, bool value)
    {
        context.CellValue = value;
    }

    private bool IsHotWallet(Check<bool>? component)
    {
        if (component == null)
        {
            return false;
        }
        return component.Checked;
    }

    private async Task CloseAndCleanImportWalletModal()
    {
        await _importWalletModal?.Close(CloseReason.UserClosing);

        _seedphrase = string.Empty;
        _name = string.Empty;
        _description = string.Empty;
        _derivationPath = string.Empty;
        _outputDescriptor = string.Empty;
        _IsImportWalletModalWatchOnly = false;
    }

    private async Task ImportWallet()
    {
        if (!await _importWalletValidations.ValidateAll())
        {
            ToastService.ShowError("Please fill in all the required fields");
            return;
        }
        (bool, string?) result = (false, null);
        if (_IsImportWalletModalWatchOnly && !string.IsNullOrWhiteSpace(_outputDescriptor))
        {
    //Import watch-only wallet
            result = await WalletRepository.ImportWatchOnlyWallet(_name, _description, _outputDescriptor, LoggedUser?.Id);
        }
        else
        {
    //Import bip39 wallet
            result = await WalletRepository.ImportBIP39Wallet(_name, _description, _seedphrase, _derivationPath);
        }


    //Handle error
        if (!result.Item1)
        {
            ToastService.ShowError("Something went wrong while importing the wallet");
            return;
        }

    //Load data
        await GetData();

    //Success
        ToastService.ShowSuccess("Wallet imported successfully");

    //Close modal
        await CloseAndCleanImportWalletModal();
    }

    private async Task ShowImportWalletModal()
    {
        _seedphrase = string.Empty;
        _name = string.Empty;
        _description = string.Empty;
        _derivationPath = string.Empty;

        await _importWalletModal?.Show();
    }

    private async Task ShowTransferFundsModal(Wallet wallet)
    {
        var availableWallets = await WalletRepository.GetAvailableWallets(true);
        _walletsForTransfer = availableWallets.Where(w => w.Id != wallet.Id).ToList();
        _transferTargetWalletBalance = string.Empty;
        _sourceTransferWallet = wallet;
        _targetTransferWallet = null;
        _transferAllFunds = false;
        _amountToTransfer = Constants.MINIMUM_WITHDRAWAL_BTC_AMOUNT;

        (_sourceBalance,_) = await BitcoinService.GetWalletConfirmedBalance(wallet);
        _sourceWalletBalance = $"{_sourceBalance:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal) _sourceBalance, _btcPrice), 2)} USD)";

        await _transferFundsModal?.Show();
    }

    private async Task<bool> TransferInnerWithdrawalProcess(WalletWithdrawalRequest withdrawalRequest)
    {
        bool result = false;

        async Task CleanUpWithdrawalRequest(string errorMessage)
        {
            ToastService.ShowError(errorMessage);
            withdrawalRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(withdrawalRequest);
            await CloseHotWalletTransferModal();
        }

        var walletWithdrawalRequestPsbt = new WalletWithdrawalRequestPSBT();

        try
        {
            var templatePSBT = await BitcoinService.GenerateTemplatePSBT(withdrawalRequest);
            walletWithdrawalRequestPsbt.WalletWithdrawalRequestId = withdrawalRequest.Id;
            walletWithdrawalRequestPsbt.PSBT = templatePSBT.ToBase64();
            walletWithdrawalRequestPsbt.SignerId = null;
        }
        catch (NoUTXOsAvailableException e)
        {
            await CleanUpWithdrawalRequest("No UTXOs available for withdrawals were found for this wallet");
            return result;
        }
        catch (ShowToUserException e)
        {
            CleanUpWithdrawalRequest(e.Message);
            return result;
        }
        catch
        {
            CleanUpWithdrawalRequest("Something went wrong");
            return result;
        }

        var addResult = await WalletWithdrawalRequestPsbtRepository.AddAsync(walletWithdrawalRequestPsbt);

        if (!addResult.Item1)
        {
            throw new ShowToUserException("Error while saving the signature");
        }

        withdrawalRequest = await WalletWithdrawalRequestRepository.GetById(withdrawalRequest.Id);

        if (withdrawalRequest != null
            && withdrawalRequest.AreAllRequiredHumanSignaturesCollected)
        {
            var isWithdrawalProcessed = await CreateJobForFunds(withdrawalRequest);
            result = isWithdrawalProcessed;
        }
        else
        {
            throw new ShowToUserException("Invalid PSBT");
        }
        return result;
    }

    private async Task<WalletWithdrawalRequest> CreateWithdrawalRequestForFunds()
    {
        var targetBitcoinAddress = await LightningService.GetUnusedAddress(_targetTransferWallet, DerivationFeature.Deposit);

        var withdrawalRequest = new WalletWithdrawalRequest
        {
            UserRequestorId = LoggedUser != null ? LoggedUser.Id : string.Empty,
            Description = @$"Funds transferred from {_sourceWalletName} to {_targetWalletName}",
            WithdrawAllFunds = _transferAllFunds,
            DestinationAddress = targetBitcoinAddress.ToString(),
            
            Amount = _amountToTransfer,
            WalletId = _sourceTransferWallet.Id,
            Status = _sourceTransferWallet.IsHotWallet
                ? WalletWithdrawalRequestStatus.PSBTSignaturesPending
                : WalletWithdrawalRequestStatus.Pending,
        };

        var withdrawalSaved = await WalletWithdrawalRequestRepository.AddAsync(withdrawalRequest);

        return withdrawalRequest;
    }

    private async Task TransferFunds()
    {
        if (!await _transferFundsValidations.ValidateAll())
        {
            ToastService.ShowError("There are fields that are not valid.");
            return;
        }

        if (_sourceTransferWallet != null && _targetTransferWallet != null)
        {
            if (_sourceTransferWallet.IsHotWallet)
            {
                await _hotWalletTransferModal.ShowModal();
            }
            else
            {
                await CreateWithdrawalRequestForFunds();
                await _multisigTransferModal.ShowModal();
                await CloseAndCleanTransferFundsModal();
            }
        }
        await CloseAndCleanTransferFundsModal();
    }

    private async Task TransferFundsHotWallet()
    {
        var withdrawalRequest = await CreateWithdrawalRequestForFunds();
        var transferSuccess = await TransferInnerWithdrawalProcess(withdrawalRequest);

        if (transferSuccess)
        {
            ToastService.ShowSuccess("Funds transferred successfully");
        }
        else
        {
            ToastService.ShowError("Error while transferring funds, please contact a superadmin for troubleshooting");
        }

        await CloseAndCleanTransferFundsModal();
        await CloseHotWalletTransferModal();
    }


    private async Task<bool> CreateJobForFunds(WalletWithdrawalRequest withdrawalRequest)
    {
        var result = false;

        try
        {
            IScheduler scheduler = await SchedulerFactory.GetScheduler();

            var map = new JobDataMap();
            map.Put("withdrawalRequestId", withdrawalRequest.Id);

            var retryList = RetriableJob.ParseRetryListFromString(Constants.JOB_RETRY_INTERVAL_LIST_IN_MINUTES);
            var job = RetriableJob.Create<PerformWithdrawalJob>(map, withdrawalRequest.Id.ToString(), retryList);
            await scheduler.ScheduleJob(job.Job, job.Trigger);

            if (withdrawalRequest != null)
            {
    // TODO: Check job id
                withdrawalRequest.JobId = job.Job.Key.ToString();
                WalletWithdrawalRequestRepository.Update(withdrawalRequest);
                result = true;
            }
        }
        catch
        {
            withdrawalRequest.Status = WalletWithdrawalRequestStatus.Failed;
            WalletWithdrawalRequestRepository.Update(withdrawalRequest);
        }

        return result;
    }

    private async Task CloseMultisigTransferModal()
    {
        await _multisigTransferModal.CloseModal();
    }

    private async Task CloseHotWalletTransferModal()
    {
        await _hotWalletTransferModal.CloseModal();
    }

    private async Task CloseAndCleanTransferFundsModal()
    {
        await _transferFundsModal?.Close(CloseReason.UserClosing);

        _selectedTransferWalletId = 0;
        _walletsForTransfer = new();
        _transferTargetWalletBalance = string.Empty;
        _sourceWalletBalance = string.Empty;
    }

    private async Task OnSelectedWallet(int id)
    {
        _selectedTransferWalletId = id;

        if (id == 0)
        {
            _transferTargetWalletBalance = string.Empty;
        }

        var targetWallet = _walletsForTransfer.SingleOrDefault(x => x.Id == id);
        _targetTransferWallet = targetWallet;

        if (targetWallet != null)
        {
             (targetBalance,_) = await BitcoinService.GetWalletConfirmedBalance(targetWallet);

            _transferTargetWalletBalance = $"{targetBalance:f8} BTC ({Math.Round(PriceConversionService.BtcToUsdConversion((decimal) targetBalance, _btcPrice), 2)} USD)";
          }
    }

    private async Task ValidateDerivationPath(ValidatorEventArgs arg1, CancellationToken arg2)
    {
        arg1.Status = ValidationStatus.Success;

    //if the string is empty, it is not valid

        if (string.IsNullOrEmpty(arg1.Value.ToString()))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid derivation path";
            return;
        }

        if (!KeyPath.TryParse(arg1.Value.ToString() ?? string.Empty, out _))
        {
    //error
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid derivation path";
        }
    }


    private async Task ValidateSeedphrase(ValidatorEventArgs arg1, CancellationToken arg2)
    {
    //Create a Mnemonic and validate it
        try
        {
            var mnemonic = new Mnemonic(arg1.Value.ToString());
            var isValid = mnemonic.IsValidChecksum;

            if (!isValid)
            {
                arg1.Status = ValidationStatus.Error;
                arg1.ErrorText = "Invalid seedphrase";
            }
            else
            {
                arg1.Status = ValidationStatus.Success;
            }
        }
        catch (Exception e)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid seedphrase";
        }
    }

    private async Task CopyStrToClipboard(string arg)
    {
        await ClipboardService.WriteTextAsync(arg);
        ToastService.ShowSuccess("Address copied");
        await CloseTextModal();
    }

    private bool OnWalletCustomFilter(Wallet wallet)
    {
        bool anyCheck = _archivedWalletFilter || _compromisedWalletFilter || _hotWalletFilter || _coldWalletFilter || _finalisedWalletFilter;
        if (!anyCheck)
            return true;

        return _archivedWalletFilter && wallet.IsArchived
               || _compromisedWalletFilter && wallet.IsCompromised
               || _hotWalletFilter && wallet.IsHotWallet
               || _coldWalletFilter && !wallet.IsHotWallet
               || _finalisedWalletFilter && wallet.IsFinalised;
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsColumnVisible(ColumnDefault column)
    {
        if (WalletsColumnLayout == null)
        {
            return true;
        }
        return WalletsColumnLayout.IsColumnVisible(column);
    }

    private Task OnCheckedChanged(bool value)
    {
        return _walletsDataGrid.Reload();
    }

    private async Task ValidateOutputDescriptor(ValidatorEventArgs arg1, CancellationToken arg2)
    {
        arg1.Status = ValidationStatus.Success;


    //Parse
        if (arg1.Value is string)
        {
            try
            {
                WalletParser.ParseOutputDescriptor(arg1.Value.ToString(), CurrentNetworkHelper.GetCurrentNetwork());
            }
            catch (Exception e)
            {
                arg1.Status = ValidationStatus.Error;
                arg1.ErrorText = "Invalid output descriptor";
            }
        }
        else
        {
    //Null
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Invalid output descriptor";
        }
    }
    
    private async Task RescanWallet(Wallet contextItem)
    {
        if (contextItem != null)
        {
            try
            {
                await WalletRepository.TrackAndScanWallet(contextItem);
            }
            catch (Exception e)
            {
                ToastService.ShowError("Something went wrong while rescanning the wallet");
            }

            ToastService.ShowSuccess("Wallet rescan job created successfully");
        }
    }

    private async Task LoadAndOpenExportOutputDescriptor(Wallet contextItem)
    {
        await CleanTextModal();
        if (contextItem != null)
        {
            try
            {
                _outputDescriptorContentModal = WalletParser.GetOutputDescriptor(contextItem);
                _keysContentModal = contextItem.Keys as HashSet<Key> ?? new HashSet<Key>();
                await _exportOutputDescriptorModal.Show();
            }
            catch (Exception e)
            {
                ToastService.ShowError("Error while getting the wallet descriptor");
            }
        }
    }

    private async Task CloseExportOutputDescriptorModal()
    {
        await _exportOutputDescriptorModal.Close(CloseReason.UserClosing);
        
        _outputDescriptorContentModal = string.Empty;
        _keysContentModal = new HashSet<Key>();
    }

}