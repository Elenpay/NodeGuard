@page "/channels"
@using System.Security.Claims
@using Humanizer
@using NBitcoin
@using Channel = NodeGuard.Data.Models.Channel
@attribute [Authorize(Roles = "NodeManager")]
<PageTitle>Active Channels</PageTitle>
<h3 class="custom-primary">Channels
    <Tooltip Class="ml-2" Text="Refresh channel information">
        <Button Color="Color.Primary" Clicked="RefreshChannelInformation"><Icon Name="IconName.SyncAlt"></Icon></Button>
    </Tooltip>
</h3>

<Row>
    <Column ColumnSize="ColumnSize.Is12">
        <DataGrid TItem="Channel"
                  @ref="_channelsDataGridRef"
                  Data="@_channels"
                  Editable
                  EditMode=DataGridEditMode.Inline
                  Responsive
                  ResizeMode="TableResizeMode.Columns"
                  ShowPager="true"
                  ShowPageSizes="true"
                  PageSize="25"
                  Filterable="true">
            <DataGridColumns>
                <DataGridCommandColumn TItem="Channel">
                    <NewCommandTemplate>
                        <Button Color="Color.Success" TextColor="TextColor.Light" hidden Clicked="@context.Clicked">New</Button>
                    </NewCommandTemplate>
                    <EditCommandTemplate>
                        <Button Color="Color.Primary" hidden Clicked="@context.Clicked">Edit</Button>
                    </EditCommandTemplate>
                    <DeleteCommandTemplate>
                        <Dropdown>
                            <DropdownToggle Color="Color.Primary">
                            </DropdownToggle>
                            <DropdownMenu>
                                @if (_isUserNodeManager)
                                {
                                    <DropdownItem Disabled="context.Item.Status == Channel.ChannelStatus.Closed" Clicked="@(() => ShowChannelManagementModal(context.Item))">Manage</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => ShowConfirmedClose(context.Item)">Close</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => ShowConfirmedClose(context.Item, true)">Force close</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => MarkAsClosed(context.Item)">Mark as closed</DropdownItem>
                                    <DropdownItem Clicked="@(() => ShowModal(context.Item))">Requests</DropdownItem>
                                }
                            </DropdownMenu>
                        </Dropdown>
                    </DeleteCommandTemplate>
                </DataGridCommandColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.SourceNodeId)" Caption="Source node" CustomFilter="OnSourceNodeIdFilter" Filterable="true" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.SOURCE_NODE)">
                    <FilterTemplate>
                        <Select TValue="int" SelectedValue="@(_sourceNodeIdFilter)" SelectedValueChanged="@(value => { _sourceNodeIdFilter = value; context.TriggerFilterChange(_sourceNodeIdFilter); })">
                            <SelectItem Value="@(0)">All</SelectItem>
                            @foreach (var node in _nodes)
                            {
                                <SelectItem Value="@(node.Id)">@(node.Name)(@(StringHelper.TruncateHeadAndTail(node.PubKey, 5)))</SelectItem>
                            }
                        </Select>
                    </FilterTemplate>
                    <DisplayTemplate>

                        @if (context.SourceNode != null)
                        {
                            @(context.SourceNode.Name + " " + StringHelper.TruncateHeadAndTail(context.SourceNode.PubKey, 5))
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.DestinationNodeId)" Caption="Destination node" CustomFilter="OnDestinationNodeIdFilter" Filterable="true" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.DESTINATION_NODE)">
                    <FilterTemplate>
                        <Select TValue="int" SelectedValue="@(_destinationNodeIdFilter)" SelectedValueChanged="@(value => { _destinationNodeIdFilter = value; context.TriggerFilterChange(_destinationNodeIdFilter); })">
                            <SelectItem Value="@(0)">All</SelectItem>
                            @foreach (var node in _nodes)
                            {
                                <SelectItem Value="@(node.Id)">@(node.Name)(@(StringHelper.TruncateHeadAndTail(node.PubKey, 5)))</SelectItem>
                            }
                        </Select>
                    </FilterTemplate>
                    <DisplayTemplate>

                        @if (context.DestinationNode != null)
                        {
                            @(context.DestinationNode.Name + " " + StringHelper.TruncateHeadAndTail(context.DestinationNode.PubKey, 5))
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.Status)" Caption="@nameof(Channel.Status)" CustomFilter="OnStatusFilter" Filterable="true" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.STATUS)">
                    <FilterTemplate>
                        <Select TValue="string" SelectedValue="@((string) _statusFilter)" SelectedValueChanged="@(value => { _statusFilter = value; context.TriggerFilterChange(_statusFilter); })">
                            <SelectItem Value="@("")">All</SelectItem>
                            <SelectItem Value="@(Channel.ChannelStatus.Open.Humanize())">@Channel.ChannelStatus.Open.Humanize()</SelectItem>
                            <SelectItem Value="@(Channel.ChannelStatus.Closed.Humanize())">@Channel.ChannelStatus.Closed.Humanize()</SelectItem>
                        </Select>
                    </FilterTemplate>
                    <DisplayTemplate>
                        @context.Status.ToString("G")
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.OpenedWithId)" Caption="Opened with" CustomFilter="OnWalletFilter" Filterable="true" Displayable="@IsColumnVisible(ChannelsColumnName.OPENED_WITH)">
                    <FilterTemplate>
                        <Select TValue="int" SelectedValue="@(_filterWalletId)" SelectedValueChanged="@(value => { _filterWalletId = value; context.TriggerFilterChange(_filterWalletId); })">
                            <SelectItem Value="@(0)">All</SelectItem>
                            @foreach (var wallet in _wallets)
                            {
                                <SelectItem Value="@(wallet.Id)">@wallet.Name</SelectItem>
                            }
                        </Select>
                    </FilterTemplate>
                    <DisplayTemplate>
                        @{
                            Wallet wallet = null;
                            if (context.OpenedWithId != null)
                            {
                                wallet = context.ChannelOperationRequests.FirstOrDefault()?.Wallet;
                            }
                            @(wallet == null ? "Unknown" : wallet.Name)
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.FundingTx)" Caption="OutPoint" Filterable="false" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.OUTPOINT)">
                    <DisplayTemplate>
                        @StringHelper.TruncateHeadAndTail(context.FundingTx, 5):@context.FundingTxOutputIndex
                        <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard($"{context.FundingTx}:{context.FundingTxOutputIndex}"))">
                            <i class="oi oi-clipboard"></i>
                        </Button>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridNumericColumn TItem="Channel" Field="@nameof(Channel.SatsAmount)" Caption="Capacity (BTC)" Filterable="false" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.CAPACITY)">
                    <DisplayTemplate>
                        @{
                            var btcAmount = new Money(context.SatsAmount, MoneyUnit.Satoshi).ToUnit(MoneyUnit.BTC);
                            @($"{btcAmount:f8} BTC")
                            @($" ({Math.Round(PriceConversionHelper.BtcToUsdConversion(btcAmount, _btcPrice), 2)} USD)")
                        }
                    </DisplayTemplate>
                </DataGridNumericColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.IsPrivate)" Caption="Private" Filterable="false" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.PRIVATE)"/>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.BtcCloseAddress)" Caption="Close address" Filterable="false" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CLOSE_ADDRESS)">
                    <DisplayTemplate>
                        @if (!string.IsNullOrEmpty(context.BtcCloseAddress))
                        {
                            @StringHelper.TruncateHeadAndTail(context.BtcCloseAddress, 5)
                            <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard(context.BtcCloseAddress))">
                                <i class="oi oi-clipboard"></i>
                            </Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.ChanId)" Caption="Availability" Sortable Filterable CustomFilter="OnAvailabilityFilter" Displayable="@IsColumnVisible(ChannelsColumnName.AVAILABILITY)">
                    <FilterTemplate>
                        <Select TValue="int" SelectedValue="@(_availabilityFilter)" SelectedValueChanged="@(value => { _availabilityFilter = value; context.TriggerFilterChange(_availabilityFilter); })">
                            <SelectItem Value="0">All</SelectItem>
                            <SelectItem Value="1">Active</SelectItem>
                            <SelectItem Value="-1">Inactive</SelectItem>
                        </Select>
                    </FilterTemplate>
                    <DisplayTemplate>
                        @{
                            var isActive = GetAvailability(context.ChanId);
                        }
                        <p>@(isActive ? "Active" : "Inactive")</p>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Caption="Channel Balance" Filterable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CHANNEL_BALANCE)">
                    <DisplayTemplate>
                        @{
                            var balance = GetPercentageBalance(context);

                        }
                        @if (balance >= 0)
                        {
                            <Progress Color="Color.Primary" Value="@balance"></Progress>
                            <Text>
                                @{
                                    @($"{balance}%")
                                }
                            </Text>
                        }
                        else
                        {
                            <p>Not available</p>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.CreationDatetime)" Caption="@nameof(Channel.CreationDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.CREATION_DATE)"/>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.UpdateDatetime)" Caption="@nameof(Channel.UpdateDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.UPDATE_DATE)"/>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.ChanId)" Caption="Channel Id" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CHANNEL_ID)">
                    <DisplayTemplate>
                        <a href="@(Constants.AMBOSS_ENDPOINT + "/edge/" + context.ChanId)" target="_blank">
                            @context.ChanId
                        </a>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Displayable="true">
                    <FilterTemplate>
                        <ColumnLayout @ref="_channelsColumnLayout" Columns="@_channelsColumns" ColumnType="ChannelsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                    </FilterTemplate>
                </DataGridColumn>
            </DataGridColumns>
        </DataGrid>
    </Column>
</Row>

<Modal @bind-Visible="@_modalVisible">
    <ModalContent Centered Scrollable Size="ModalSize.ExtraLarge">
        <ModalHeader>
            <ModalTitle>Channels requests related to Channel: @_selectedChannel?.ChanId</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <DataGrid TItem="ChannelOperationRequest"
                      Data=@_selectedChannel?.ChannelOperationRequests
                      Sortable="false"
                      ShowCaptions="true">
                <DataGridColumn Field="@nameof(ChannelOperationRequest.Id)" Caption="@nameof(ChannelOperationRequest.Id)"/>
                <DataGridColumn Field="@nameof(ChannelOperationRequest.User)" Caption="Created by"/>
                <DataGridColumn Field="@nameof(ChannelOperationRequest.RequestType)" Caption="Request type"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="SourceNode.Name" Caption="Source Node" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="DestNode.Name" Caption="Remote Node" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="Wallet.Name" Caption="Wallet" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Amount)" Caption="Value" Sortable="false" Displayable="true">
                    <DisplayTemplate>
                        @{
                            @($"{context.Amount:f8} BTC")
                            @($" ({Math.Round(PriceConversionHelper.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="ChannelOperationRequest" Caption="Signatures Collected" Sortable="false" Displayable="true">
                    <DisplayTemplate>
                        @if (context.RequestType == OperationRequestType.Open)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.IsSingleSig ? 0 : 1);
                            var signaturesRequired = context?.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                        else
                        {
                            <p>N/A</p>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Status)" Caption="Status" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.CreationDatetime)" Caption="@nameof(ChannelOperationRequest.CreationDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" SortDirection="SortDirection.Descending"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.UpdateDatetime)" Caption="@nameof(ChannelOperationRequest.UpdateDatetime).Humanize(LetterCasing.Sentence)" Sortable="false"/>
            </DataGrid>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@HideModal">Back</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_channelLiquidityModal">
    @if (_selectedChannel != null)
    {
        <ModalContent Centered Scrollable Size="ModalSize.ExtraLarge">
            <ModalHeader>
                <ModalTitle>Liquidity management for channel: @_selectedChannel.ChanId </ModalTitle>
                <CloseButton/>
            </ModalHeader>
            <ModalBody>
                <Field>
                    <FieldLabel>Enable automated liquidity management</FieldLabel>
                    <Check TValue="bool" Checked="@_selectedChannel.IsAutomatedLiquidityEnabled" CheckedChanged="OnEnableLiquidityMngmtChanged"></Check>
                </Field>
                @if (_selectedChannel.IsAutomatedLiquidityEnabled && _currentLiquidityRule != null)
                {
                    <Validations @ref="_channelManagementValidationsRef">
                        <Field>
                            <Validation Validator="ValidateLocalBalance">
                                <FieldLabel>Minimum local balance</FieldLabel>
                                <FieldHelp>Balance % that will fire a reverse swap if the channel balance goes below this percent (0 means optional)</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.MinimumLocalBalance">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and less than minimum remote balance</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Field>
                            <Validation Validator="ValidateRemoteBalance">
                                <FieldLabel>Minimum remote balance</FieldLabel>
                                <FieldHelp>Balance % that will fire a swap if the channel balance goes above this percent (0 means optional)</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.MinimumRemoteBalance">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and bigger than minimum local balance</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Field>
                            <Validation Validator="ValidateTargetBalance">
                                <FieldLabel>Target balance</FieldLabel>
                                <FieldHelp>Desired target balance % after a swap operation is performed</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.RebalanceTarget">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and in between minimum local and remote balance (0 means optional)</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Field>
                            <Validation Validator="ValidationRule.IsSelected">
                                <FieldLabel>Wallet to use in Swaps operations</FieldLabel>
                                <SelectList TItem="Wallet"
                                            TValue="int"
                                            Data="@_availableWallets"
                                            SelectedValue="_currentLiquidityRule.WalletId"
                                            TextField="@((item) => item.Name)"
                                            ValueField="@((item) => item.Id)"
                                            SelectedValueChanged="@OnSelectedWalletChanged"
                                            DefaultItemText="Choose the wallet to fund/receive swap amounts">
                                    <Feedback>
                                        <ValidationError>A wallet for swaps operation must be selected as target/origin of funds</ValidationError>
                                    </Feedback>
                                </SelectList>
                            </Validation>
                        </Field>
                    </Validations>
                }
            </ModalBody>
            <ModalFooter>
                <Button Color="Color.Secondary" Clicked="@CloseChannelManagementModal">Cancel</Button>
                <Button Color="Color.Primary" Clicked="@SaveAndCloseChannelManagementModal">Save</Button>
            </ModalFooter>
        </ModalContent>
    }

</Modal>


@inject IChannelRepository ChannelRepository
@inject IToastService ToastService
@inject ClipboardService ClipboardService
@inject IMessageService MessageService
@inject ILightningService LightningService
@inject ILiquidityRuleRepository LiquidityRuleRepository
@inject IWalletRepository WalletRepository
@inject INodeRepository NodeRepository
@inject ILocalStorageService LocalStorageService

@code {
    private List<Channel>? _channels = new List<Channel>();
    private Channel? _selectedChannel;
    private bool _modalVisible;
    private bool _isUserNodeManager;
    private DataGrid<Channel>? _channelsDataGridRef;
    private Modal? _channelLiquidityModal;
    private List<Wallet> _availableWallets = new List<Wallet>();
    private LiquidityRule? _currentLiquidityRule = new LiquidityRule();
    private Validations? _channelManagementValidationsRef;
    private string _statusFilter = "Open";
    private int _availabilityFilter = 0;
    private int _sourceNodeIdFilter;
    private int _destinationNodeIdFilter;
    private List<Node> _nodes = new List<Node>();
    private List<Wallet> _wallets = new List<Wallet>();
    private int _filterWalletId;

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private decimal _btcPrice;

    private ColumnLayout<ChannelsColumnName>? _channelsColumnLayout;
    private Dictionary<string, bool> _channelsColumns = new();
    private bool _columnsLoaded;
    // This dictionary is used to store the balance of each channel, key is the channel id, value is a tuple with the node id as local in the pair, local balance, remote balance
    private Dictionary<ulong, ChannelStatus> _channelsBalance = new();

    public abstract class ChannelsColumnName
    {
        public static readonly ColumnDefault SOURCE_NODE = new("Source Node");
        public static readonly ColumnDefault DESTINATION_NODE = new("Destination Node");
        public static readonly ColumnDefault STATUS = new("Status");
        public static readonly ColumnDefault OPENED_WITH = new("Opened With");
        public static readonly ColumnDefault OUTPOINT = new("Outpoint");
        public static readonly ColumnDefault CAPACITY = new("Capacity (BTC)");
        public static readonly ColumnDefault PRIVATE = new("Private");
        public static readonly ColumnDefault CLOSE_ADDRESS = new("Close Address");
        public static readonly ColumnDefault AVAILABILITY = new("Availability");
        public static readonly ColumnDefault CHANNEL_BALANCE = new("Channel Balance");
        public static readonly ColumnDefault CREATION_DATE = new("Creation Date");
        public static readonly ColumnDefault UPDATE_DATE = new("Update Date");
        public static readonly ColumnDefault CHANNEL_ID = new("Channel Id");
    }

    protected override async Task OnInitializedAsync()
    {
        _btcPrice = PriceConversionHelper.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }
        if (LoggedUser != null)
        {
            await FetchData();
            if (ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.NodeManager.ToString()))
            {
                _isUserNodeManager = true;
            }
        }
    }

    private async Task FetchData()
    {
        _availableWallets = await WalletRepository.GetAvailableWallets();
        if (LoggedUser?.Id != null)
        {
            _channels = await ChannelRepository.GetAllManagedByUserNodes(LoggedUser.Id);
        }
        _nodes = await NodeRepository.GetAll();
        _wallets = await WalletRepository.GetAll();
        _channelsDataGridRef?.FilterData();
        _channelsBalance = await LightningService.GetChannelsStatus();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !_columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private async Task LoadColumnLayout()
    {
        _channelsColumns = await LocalStorageService.LoadStorage(nameof(ChannelsColumnName), ColumnHelpers.GetColumnsDictionary<ChannelsColumnName>());
        _columnsLoaded = true;
        StateHasChanged();
    }

    private async Task ShowConfirmedClose(Channel? channel, bool forceClose = false)
    {
        await RefreshChannelInformation();
        var isChannelActive = GetAvailability(channel?.ChanId);
        var preMessage = "";
        if (forceClose && isChannelActive)
        {
            preMessage = "This channel is active!. ";
        }

        if (await MessageService.Confirm($"{preMessage}Are you sure you want to {(forceClose ? "force " : string.Empty)}close this channel?", "Confirmation"))
        {
            if (channel != null)
            {
                channel.DestinationNode = await NodeRepository.GetById(channel.DestinationNodeId) ?? throw new InvalidOperationException();
                channel.SourceNode = await NodeRepository.GetById(channel.SourceNodeId) ?? throw new InvalidOperationException();
                var result = await ChannelRepository.SafeRemove(channel, forceClose);

                if (!result.Item1)
                {
                    ToastService.ShowError("Something went wrong");
                }
                else
                {
                    ToastService.ShowSuccess("Channel closed successfully");
                    await FetchData();
                }
            }
            else
            {
                ToastService.ShowError("Something went wrong. Please refresh the page");
            }
        }
    }

    private void ShowModal(Channel channel)
    {
        _modalVisible = true;
        _selectedChannel = channel;
    }

    private void HideModal()
    {
        _modalVisible = false;
        _selectedChannel = null;
    }

    private async Task CopyStrToClipboard(string arg)
    {
        await ClipboardService.WriteTextAsync(arg);
        ToastService.ShowSuccess("Text copied");
    }

    private int GetPercentageBalance(Channel channel)
    {
        try
        {
            var result = -1.0;
            if (_channelsBalance.TryGetValue(channel.ChanId, out var values))
            {
    // Calculate the capacity as the sum of the second and third values in the tuple
                var capacity = values.LocalBalance + values.RemoteBalance;

    // Calculate the result as the percentage of the remote balance to the capacity
                result = (values.RemoteBalance / (double) capacity) * 100;


                result = Math.Round(result, 2);
            }


            return Convert.ToInt32(result);
        }
        catch (Exception)
        {
            ToastService.ShowError($"Channel balance for channel id:{channel.Id} could not be retrieved");
            return -1;
        }
    }

    private bool GetAvailability(ulong? channelId)
    {
        if (channelId == null) return false;
        try
        {
            if (_channelsBalance.TryGetValue(channelId.Value, out var value))
            {
                return value.Active;
            }
        }
        catch (Exception)
        {
            ToastService.ShowError($"Channel availability for channel id:{channelId} could not be retrieved");
        }
        return false;
    }

    private async Task OnSelectedWalletChanged(int arg)
    {
        if (_currentLiquidityRule != null) _currentLiquidityRule.WalletId = arg;
    }

    private async Task CloseChannelManagementModal()
    {
        if (_channelLiquidityModal != null) await _channelLiquidityModal.Close(CloseReason.UserClosing);
        await ClearManagementModal();
        await FetchData();
    }

    private async Task SaveAndCloseChannelManagementModal()
    {
        if (_channelManagementValidationsRef != null && await _channelManagementValidationsRef.ValidateAll())
        {
    //Save the channel
            if (_selectedChannel != null)
            {
                var updateResult = ChannelRepository.Update(_selectedChannel);
                if (!updateResult.Item1)
                {
                    ToastService.ShowError("Something went wrong");
                }
                else
                {
                    ToastService.ShowSuccess("Channel updated successfully");
                }
            }

    //Save the liquidity rule if the liquidity rule id is below or equal zero
            if (_currentLiquidityRule != null)
            {
                if (_currentLiquidityRule.Id <= 0)
                {
                    var liquidityRuleResult = await LiquidityRuleRepository.AddAsync(_currentLiquidityRule);
                    if (!liquidityRuleResult.Item1)
                    {
                        ToastService.ShowError("Something went wrong");
                    }
                    else
                    {
                        ToastService.ShowSuccess("Liquidity rule added successfully");
                    }
                }
                else
                {
                    var liquidityRuleResult = LiquidityRuleRepository.Update(_currentLiquidityRule);
                    if (!liquidityRuleResult.Item1)
                    {
                        ToastService.ShowError("Something went wrong");
                    }
                    else
                    {
                        ToastService.ShowSuccess("Liquidity rule updated successfully");
                    }
                }
            }

            await CloseChannelManagementModal();
        }
        else
        {
            ToastService.ShowError("Please fix the errors");
        }
    }

    private async Task ClearManagementModal()
    {
        _selectedChannel = null;
        _currentLiquidityRule = new LiquidityRule();
    }

    private async Task ShowChannelManagementModal(Channel channel)
    {
        await ClearManagementModal();

        _selectedChannel = channel;

        var destinationNode = channel.DestinationNode;
        var sourceNode = channel.SourceNode;
        var node = string.IsNullOrEmpty(sourceNode.ChannelAdminMacaroon) ? destinationNode : sourceNode;

    //If there is a liquidity rule for this channel, we load it, the first one
        _currentLiquidityRule = _selectedChannel?.LiquidityRules.FirstOrDefault() ?? new LiquidityRule
        {
            MinimumLocalBalance = 20,
            MinimumRemoteBalance = 80,
            RebalanceTarget = 50,
            ChannelId = channel.Id,
            NodeId = node.Id
        };

        if (_channelLiquidityModal != null) await _channelLiquidityModal.Show();
    }

    private async Task OnEnableLiquidityMngmtChanged(bool enabledLiquidityMngmt)
    {
        if (_selectedChannel != null)
        {
            _selectedChannel.IsAutomatedLiquidityEnabled = enabledLiquidityMngmt;

            if (!enabledLiquidityMngmt)
            {
                _currentLiquidityRule = null;
            }
            else
            {
                var node = string.IsNullOrEmpty(_selectedChannel.SourceNode.ChannelAdminMacaroon) ? _selectedChannel.DestinationNode : _selectedChannel.SourceNode;
                _currentLiquidityRule = _selectedChannel.LiquidityRules.FirstOrDefault() ?? new LiquidityRule
                {
                    MinimumLocalBalance = 20,
                    MinimumRemoteBalance = 80,
                    RebalanceTarget = 50,
                    ChannelId = _selectedChannel.Id,
                    NodeId = node.Id
                };
            }

            var updateResult = ChannelRepository.Update(_selectedChannel);

            if (!updateResult.Item1)
            {
                ToastService.ShowError("Something went wrong");
            }
            else
            {
                ToastService.ShowSuccess("Channel updated successfully");
            }
        }
    }

    private void ValidateTargetBalance(ValidatorEventArgs arg1)
    {
        if(_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;

    //If the value is 0 is valid
        if (_currentLiquidityRule.RebalanceTarget == 0 || _currentLiquidityRule.RebalanceTarget == null)
        {
            return;
        }
    //Check that the target balance is between 0 and 100
        if (_currentLiquidityRule.RebalanceTarget < 0 || _currentLiquidityRule.RebalanceTarget > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Target balance must be between 0 and 100";
        }


    //Check that the rebalancetarget of the current liquidity rule is between the mininum local and minimum remote balance
        if (_currentLiquidityRule.RebalanceTarget < _currentLiquidityRule.MinimumLocalBalance ||
            _currentLiquidityRule.RebalanceTarget > _currentLiquidityRule.MinimumRemoteBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Rebalance target must be between the minimum local and minimum remote balance";
        }
    }

    private void ValidateRemoteBalance(ValidatorEventArgs arg1)
    {
        if(_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;

    //If the minimum local balance is 0 this cannot be 0
        if ((_currentLiquidityRule.MinimumLocalBalance == 0 || _currentLiquidityRule.MinimumLocalBalance == null)
            && (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance cannot be 0 if the minimum local balance is 0";
        }

    //If the value is 0 is valid
        if (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null)
        {
            return;
        }


    //Check that the minimum remote balance is between 0 and 100
        if (_currentLiquidityRule.MinimumRemoteBalance < 0 || _currentLiquidityRule.MinimumRemoteBalance > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance must be between 0 and 100";
        }


    //Check that the Minimum remote balance must be greater than the minimum local balance
        if (_currentLiquidityRule.MinimumRemoteBalance <= _currentLiquidityRule.MinimumLocalBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance must be greater than the minimum local balance";
        }
    }

    private void ValidateLocalBalance(ValidatorEventArgs arg1)
    {
        if (_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;
    //If the minimum remote balance is 0 this cannot be 0
        if ((_currentLiquidityRule.MinimumLocalBalance == 0 || _currentLiquidityRule.MinimumLocalBalance == null)
            && (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance cannot be 0 if the minimum remote balance is 0";
        }

    //If the value is 0 is valid
        if (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null)
        {
            return;
        }


    //Check that the balance is between 0 and 100

        if (_currentLiquidityRule.MinimumLocalBalance < 0 || _currentLiquidityRule.MinimumLocalBalance > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance must be between 0 and 100";
        }

    //Check that the Minimum local balance must be less than the minimum remote balance
        if (_currentLiquidityRule.MinimumLocalBalance >= _currentLiquidityRule.MinimumRemoteBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance must be less than the minimum remote balance";
        }
    }

    private bool OnStatusFilter(object? itemValue, object? searchValue)
    {
    //If searchValue is null, we set it to the filter initial value in the field
        searchValue ??= _statusFilter;
        if (searchValue is string statusFilter)
        {
            return statusFilter == "*" || statusFilter == itemValue?.ToString();
        }

        return true;
    }

    private bool OnWalletFilter(object? itemValue, object? searchValue)
    {
    //If the wallet is null it might be a externally created channel, so we return true
        if (itemValue == null) return true;

        return searchValue == null || (int) searchValue == 0 || (int) itemValue == (int) searchValue;
    }

    private bool OnSourceNodeIdFilter(object? itemValue, object? searchValue)
    {
    //If searchValue is null, we set it to the filter initial value in the field
        searchValue ??= _sourceNodeIdFilter;
        if (searchValue is int nodeIdFilter)
        {
            return nodeIdFilter == 0 || nodeIdFilter == itemValue as int?;
        }

        return true;
    }

    private bool OnDestinationNodeIdFilter(object? itemValue, object? searchValue)
    {
    //If searchValue is null, we set it to the filter initial value in the field
        searchValue ??= _destinationNodeIdFilter;
        if (searchValue is int nodeIdFilter)
        {
            return nodeIdFilter == 0 || nodeIdFilter == itemValue as int?;
        }

        return true;
    }


    private async Task MarkAsClosed(Channel contextItem)
    {
        var result = await ChannelRepository.MarkAsClosed(contextItem);

        if (result.Item1)
        {
            ToastService.ShowSuccess("Channel marked as closed");
        }
        else
        {
            ToastService.ShowError("Something went wrong: " + result.Item2);
        }

        await FetchData();
    }

    private bool CheckDisableCloseChannelButton(Channel channel)
    {
        var lastRequest = channel.ChannelOperationRequests.LastOrDefault();

        // If the channel is not created by the node guard, we dont disable the button
        if (lastRequest == null || channel.CreatedByNodeGuard == false) return false;

        // If the channel is created by the node guard, we disable the button if the channel is closed or if the last request is a close request and is confirmed or is pending confirmation
        return channel.Status == Channel.ChannelStatus.Closed || (lastRequest.RequestType == OperationRequestType.Close
                                                                  && lastRequest.Status == ChannelOperationRequestStatus.OnChainConfirmed
                                                                  || lastRequest.Status == ChannelOperationRequestStatus.OnChainConfirmationPending);
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsColumnVisible(ColumnDefault column)
    {
        if (_channelsColumnLayout == null)
        {
            return true;
        }
        return _channelsColumnLayout.IsColumnVisible(column);
    }

    private async Task RefreshChannelInformation()
    {
        _channelsBalance = await LightningService.GetChannelsStatus();
        StateHasChanged();
    }

    private bool OnAvailabilityFilter(object? itemvalue, object? searchvalue)
    {
        if (searchvalue == null || (int)searchvalue == 0) return true;
        var isActive = GetAvailability((ulong?)itemvalue);
        if ((int)searchvalue == 1 && isActive) return true;
        if ((int)searchvalue == -1 && !isActive) return true;
        return false;
    }

}