@page "/channels"
@using System.Security.Claims
@using Humanizer
@using NBitcoin
@using Blazorise.Components
@using Channel = NodeGuard.Data.Models.Channel
@attribute [Authorize(Roles = "NodeManager")]
<PageTitle>Active Channels</PageTitle>
<h3 class="custom-primary">Channels
    <Tooltip Class="ml-2" Text="Refresh channel information">
        <Button Color="Color.Primary" Clicked="RefreshChannelInformation"><Icon Name="IconName.SyncAlt"></Icon></Button>
    </Tooltip>
</h3>

<Row>
    <Column ColumnSize="ColumnSize.Is12">
        <Row Class="mb-3" @key="_filtersResetKey">
            <Column ColumnSize="ColumnSize.Is2">
                <Field>
                    <FieldLabel>Source Node</FieldLabel>
                    <Autocomplete TItem="Node"
                                  TValue="int?"
                                  Data="@_nodes"
                                  TextField="@(item => item.Name + " (" + StringHelper.TruncateHeadAndTail(item.PubKey, 5) + ")")"
                                  ValueField="@(item => item.Id)"
                                  @bind-SelectedValue="@_sourceNodeIdFilterValue"
                                  @bind-SelectedValue:after="OnFiltersChanged"
                                  Placeholder="All"
                                  FreeTyping="false"
                                  MinLength="0"
                                  Filter="AutocompleteFilter.Contains" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is2">
                <Field>
                    <FieldLabel>Dest Node</FieldLabel>
                    <Autocomplete TItem="Node"
                                  TValue="int?"
                                  Data="@_nodes"
                                  TextField="@(item => item.Name + " (" + StringHelper.TruncateHeadAndTail(item.PubKey, 5) + ")")"
                                  ValueField="@(item => item.Id)"
                                  @bind-SelectedValue="@_destinationNodeIdFilterValue"
                                  @bind-SelectedValue:after="OnFiltersChanged"
                                  Placeholder="All"
                                  FreeTyping="false"
                                  MinLength="0"
                                  Filter="AutocompleteFilter.Contains" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is1">
                <Field>
                    <FieldLabel>Status</FieldLabel>
                    <Autocomplete TItem="string"
                                  TValue="string"
                                  Data="@_statusOptions"
                                  TextField="@(item => item)"
                                  ValueField="@(item => item)"
                                  @bind-SelectedValue="@_statusFilterValue"
                                  @bind-SelectedValue:after="OnFiltersChanged"
                                  Placeholder="All"
                                  FreeTyping="false"
                                  MinLength="0"
                                  Filter="AutocompleteFilter.Contains" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is2">
                <Field>
                    <FieldLabel>Channel Id</FieldLabel>
                    <TextEdit @bind-Text="@_channelIdFilterValue"
                              @bind-Text:after="OnFiltersChanged"
                              Placeholder="All" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is1">
                <Field>
                    <FieldLabel>Availability</FieldLabel>
                    <Autocomplete TItem="string"
                                  TValue="string"
                                  Data="@_availabilityOptions"
                                  TextField="@(item => item)"
                                  ValueField="@(item => item)"
                                  @bind-SelectedValue="@_availabilityFilterValue"
                                  @bind-SelectedValue:after="OnFiltersChanged"
                                  Placeholder="All"
                                  FreeTyping="false"
                                  MinLength="0"
                                  Filter="AutocompleteFilter.Contains" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is1">
                <Field>
                    <FieldLabel>From</FieldLabel>
                    <DatePicker TValue="DateTimeOffset?" @bind-Date="@_fromDateFilter" @bind-Date:after="OnFiltersChanged" Placeholder="From Date" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is1">
                <Field>
                    <FieldLabel>To</FieldLabel>
                    <DatePicker TValue="DateTimeOffset?" @bind-Date="@_toDateFilter" @bind-Date:after="OnFiltersChanged" Placeholder="To Date" />
                </Field>
            </Column>
            <Column ColumnSize="ColumnSize.Is1" Class="d-flex align-items-end pb-3">
                <Button Color="Color.Secondary" Clicked="@ClearAllFilters">
                    <Icon Name="IconName.Times" /> Clear
                </Button>
            </Column>
        </Row>
        <DataGrid TItem="Channel"
                  @ref="_channelsDataGridRef"
                  Data="@_channels"
                  ReadData="@OnReadData"
                  TotalItems="@_totalItems"
                  Editable
                  EditMode=DataGridEditMode.Inline
                  Responsive
                  ResizeMode="TableResizeMode.Columns"
                  ShowPager="true"
                  ShowPageSizes="true"
                  PageSize="25">
            <DataGridColumns>
                <DataGridCommandColumn TItem="Channel">
                    <NewCommandTemplate>
                        <Button Color="Color.Success" TextColor="TextColor.Light" hidden Clicked="@context.Clicked">New</Button>
                    </NewCommandTemplate>
                    <EditCommandTemplate>
                        <Button Color="Color.Primary" hidden Clicked="@context.Clicked">Edit</Button>
                    </EditCommandTemplate>
                    <DeleteCommandTemplate>
                        <Dropdown>
                            <DropdownToggle Color="Color.Primary">
                            </DropdownToggle>
                            <DropdownMenu>
                                @if (_isUserNodeManager)
                                {
                                    <DropdownItem Disabled="context.Item.Status == Channel.ChannelStatus.Closed" Clicked="@(() => ShowChannelManagementModal(context.Item))">Manage</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => ShowConfirmedClose(context.Item)">Close</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => ShowConfirmedClose(context.Item, true)">Force close</DropdownItem>
                                    <DropdownItem Disabled="@(CheckDisableCloseChannelButton(context.Item))" Clicked="() => MarkAsClosed(context.Item)">Mark as closed</DropdownItem>
                                    <DropdownItem Clicked="@(() => ShowModal(context.Item))">Requests</DropdownItem>
                                }
                            </DropdownMenu>
                        </Dropdown>
                    </DeleteCommandTemplate>
                </DataGridCommandColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.SourceNodeId)" Caption="Source node" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.SOURCE_NODE)">
                    <DisplayTemplate>

                        @if (context.SourceNode != null)
                        {
                            @(context.SourceNode.Name + " " + StringHelper.TruncateHeadAndTail(context.SourceNode.PubKey, 5))
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.DestinationNodeId)" Caption="Destination node" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.DESTINATION_NODE)">
                    <DisplayTemplate>

                        @if (context.DestinationNode != null)
                        {
                            @(context.DestinationNode.Name + " " + StringHelper.TruncateHeadAndTail(context.DestinationNode.PubKey, 5))
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.Status)" Caption="@nameof(Channel.Status)" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.STATUS)">
                    <DisplayTemplate>
                        @context.Status.ToString("G")
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.OpenedWithId)" Caption="Opened with" Displayable="@IsColumnVisible(ChannelsColumnName.OPENED_WITH)">
                    <DisplayTemplate>
                        @{
                            Wallet wallet = null;
                            if (context.OpenedWithId != null)
                            {
                                wallet = context.ChannelOperationRequests.FirstOrDefault()?.Wallet;
                            }
                            @(wallet == null ? "Unknown" : wallet.Name)
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.FundingTx)" Caption="OutPoint" Filterable="false" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.OUTPOINT)">
                    <DisplayTemplate>
                        @StringHelper.TruncateHeadAndTail(context.FundingTx, 5):@context.FundingTxOutputIndex
                        <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard($"{context.FundingTx}:{context.FundingTxOutputIndex}"))">
                            <i class="oi oi-clipboard"></i>
                        </Button>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.ChanId)" Caption="Channel Id" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CHANNEL_ID)">
                    <DisplayTemplate>
                        <a href="@(Constants.AMBOSS_ENDPOINT + "/edge/" + context.ChanId)" target="_blank">
                            @context.ChanId
                        </a>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridNumericColumn TItem="Channel" Field="@nameof(Channel.SatsAmount)" Caption="Capacity (BTC)" Filterable="false" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.CAPACITY)">
                    <DisplayTemplate>
                        @{
                            var btcAmount = new Money(context.SatsAmount, MoneyUnit.Satoshi).ToUnit(MoneyUnit.BTC);
                            @($"{btcAmount:f8} BTC")
                            @($" ({Math.Round(PriceConversionService.BtcToUsdConversion(btcAmount, _btcPrice), 2)} USD)")
                        }
                    </DisplayTemplate>
                </DataGridNumericColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.IsPrivate)" Caption="Private" Filterable="false" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.PRIVATE)"/>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.BtcCloseAddress)" Caption="Close address" Filterable="false" Sortable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CLOSE_ADDRESS)">
                    <DisplayTemplate>
                        @if (!string.IsNullOrEmpty(context.BtcCloseAddress))
                        {
                            @StringHelper.TruncateHeadAndTail(context.BtcCloseAddress, 5)
                            <Button Color="Color.Primary" Clicked="@(() => CopyStrToClipboard(context.BtcCloseAddress))">
                                <i class="oi oi-clipboard"></i>
                            </Button>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.ChanId)" Caption="Availability" Sortable Displayable="@IsColumnVisible(ChannelsColumnName.AVAILABILITY)">
                    <DisplayTemplate>
                        @{
                            var isActive = GetAvailability(context.ChanId);
                        }
                        <p>@(isActive ? "Active" : "Inactive")</p>
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Caption="Channel Balance" Filterable="false" Displayable="@IsColumnVisible(ChannelsColumnName.CHANNEL_BALANCE)">
                    <DisplayTemplate>
                        @{
                            var balance = GetPercentageBalance(context);
                        }
                        @if (balance >= 0)
                        {
                            <Tooltip Text="@GetBalanceTooltipInformation(context)">
                                <Progress Color="Color.Primary" Value="@balance"></Progress>
                            </Tooltip>
                            <Text>
                                @{
                                    @($"{balance}%")
                                }
                            </Text>
                        }
                        else
                        {
                            <p>Not available</p>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.CreationDatetime)" Caption="@nameof(Channel.CreationDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.CREATION_DATE)"/>
                <DataGridColumn TItem="Channel" Field="@nameof(Channel.UpdateDatetime)" Caption="@nameof(Channel.UpdateDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" Displayable="@IsColumnVisible(ChannelsColumnName.UPDATE_DATE)"/>
                <DataGridColumn TItem="Channel" Displayable="true">
                    <FilterTemplate>
                        <ColumnLayout @ref="_channelsColumnLayout" Columns="@_channelsColumns" ColumnType="ChannelsColumnName" OnUpdate="@OnColumnLayoutUpdate"/>
                    </FilterTemplate>
                </DataGridColumn>
            </DataGridColumns>
        </DataGrid>
    </Column>
</Row>

<Modal @bind-Visible="@_modalVisible">
    <ModalContent Centered Scrollable Size="ModalSize.ExtraLarge">
        <ModalHeader>
            <ModalTitle>Channels requests related to Channel: @_selectedChannel?.ChanId</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            @* TODO: Convert this grid to paginated ReadData to avoid loading all records in memory. *@
            <DataGrid TItem="ChannelOperationRequest"
                      Data=@_selectedChannel?.ChannelOperationRequests
                      Sortable="false"
                      ShowCaptions="true">
                <DataGridColumn Field="@nameof(ChannelOperationRequest.Id)" Caption="@nameof(ChannelOperationRequest.Id)"/>
                <DataGridColumn Field="@nameof(ChannelOperationRequest.User)" Caption="Created by"/>
                <DataGridColumn Field="@nameof(ChannelOperationRequest.RequestType)" Caption="Request type"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="SourceNode.Name" Caption="Source Node" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="DestNode.Name" Caption="Remote Node" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="Wallet.Name" Caption="Wallet" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Amount)" Caption="Value" Sortable="false" Displayable="true">
                    <DisplayTemplate>
                        @{
                            @($"{context.Amount:f8} BTC")
                            @($" ({Math.Round(PriceConversionService.BtcToUsdConversion(context.Amount, _btcPrice), 2)} USD)")
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="ChannelOperationRequest" Caption="Signatures Collected" Sortable="false" Displayable="true">
                    <DisplayTemplate>
                        @if (context.RequestType == OperationRequestType.Open)
                        {
                            var signaturesCollected = context.NumberOfSignaturesCollected + (context.Wallet.IsSingleSig ? 0 : 1);
                            var signaturesRequired = context?.Wallet?.MofN ?? 0;
                            @($"{signaturesCollected} out of {signaturesRequired}")
                        }
                        else
                        {
                            <p>N/A</p>
                        }
                    </DisplayTemplate>
                </DataGridColumn>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.Status)" Caption="Status" Sortable="false" Displayable="true"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.CreationDatetime)" Caption="@nameof(ChannelOperationRequest.CreationDatetime).Humanize(LetterCasing.Sentence)" Sortable="true" SortDirection="SortDirection.Descending"/>
                <DataGridColumn TItem="ChannelOperationRequest" Field="@nameof(ChannelOperationRequest.UpdateDatetime)" Caption="@nameof(ChannelOperationRequest.UpdateDatetime).Humanize(LetterCasing.Sentence)" Sortable="false"/>
            </DataGrid>
        </ModalBody>
        <ModalFooter>
            <Button Color="Color.Secondary" Clicked="@HideModal">Back</Button>
        </ModalFooter>
    </ModalContent>
</Modal>

<Modal @ref="_channelLiquidityModal">
    @if (_selectedChannel != null)
    {
        <ModalContent Centered Scrollable Size="ModalSize.ExtraLarge">
            <ModalHeader>
                <ModalTitle>Liquidity management for channel: @_selectedChannel.ChanId </ModalTitle>
                <CloseButton/>
            </ModalHeader>
            <ModalBody>
                <Field>
                    <FieldLabel>Enable automated liquidity management</FieldLabel>
                    <Check TValue="bool" Checked="@_selectedChannel.IsAutomatedLiquidityEnabled" CheckedChanged="OnEnableLiquidityMngmtChanged"></Check>
                </Field>
                @if (_selectedChannel.IsAutomatedLiquidityEnabled && _currentLiquidityRule != null)
                {
                    <Validations @ref="_channelManagementValidationsRef">
                        <Field>
                            <Validation Validator="ValidateLocalBalance">
                                <FieldLabel>Minimum local balance</FieldLabel>
                                <FieldHelp>Balance % that will fire a reverse swap if the channel balance goes below this percent (0 means optional)</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.MinimumLocalBalance">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and less than minimum remote balance</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Field>
                            <Validation Validator="ValidateRemoteBalance">
                                <FieldLabel>Minimum remote balance</FieldLabel>
                                <FieldHelp>Balance % that will fire a swap if the channel balance goes above this percent (0 means optional)</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.MinimumRemoteBalance">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and bigger than minimum local balance</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Field>
                            <Validation Validator="ValidateTargetBalance">
                                <FieldLabel>Target balance</FieldLabel>
                                <FieldHelp>Desired target balance % after a swap operation is performed</FieldHelp>
                                <NumericEdit TValue="decimal?" Min="0M" Max="100M" @bind-Value="_currentLiquidityRule.RebalanceTarget">
                                    <Feedback>
                                        <ValidationError>The number should be between 0 and 100 and in between minimum local and remote balance (0 means optional)</ValidationError>
                                    </Feedback>
                                </NumericEdit>
                            </Validation>
                        </Field>
                        <Row>
                            <Column>
                                @* Swaps *@
                                <Field Style="padding-top: 1.5rem">
                                    <Validation Validator="ValidationRule.IsSelected">
                                        <FieldLabel>Wallet to use in SWAPS operations</FieldLabel>
                                        <SelectList TItem="Wallet"
                                                    TValue="int"
                                                    Data="@_availableWallets"
                                                    SelectedValue="_currentLiquidityRule.SwapWalletId"
                                                    TextField="@((item) => item.Name)"
                                                    ValueField="@((item) => item.Id)"
                                                    SelectedValueChanged="@OnSelectedSwapWalletChanged"
                                                    DefaultItemText="Choose the wallet to fund or receive the swaps">
                                            <Feedback>
                                                <ValidationError>A wallet for swaps operation must be selected as target/origin of funds</ValidationError>
                                            </Feedback>
                                        </SelectList>
                                    </Validation>
                                </Field>
                            </Column>
                            <Column>
                                @* Reverse swaps *@
                                <Field>
                                    <Switch TValue="bool" Checked="@_currentLiquidityRule.IsReverseSwapWalletRule" CheckedChanged="value => _currentLiquidityRule.IsReverseSwapWalletRule = value">
                                        @(_currentLiquidityRule.IsReverseSwapWalletRule ? "Wallet based liquidity rule" : "Address based liquidity rule")
                                    </Switch>
                                    @if (_currentLiquidityRule.IsReverseSwapWalletRule)
                                    {
                                        <Validation Validator="ValidationRule.IsSelected">
                                            <FieldLabel>Wallet to use in REVERSE SWAPS operations</FieldLabel>
                                            <SelectList TItem="Wallet"
                                                        TValue="int"
                                                        Data="@_availableWallets"
                                                        SelectedValue="_currentLiquidityRule.ReverseSwapWalletId ?? 0"
                                                        TextField="@((item) => item.Name)"
                                                        ValueField="@((item) => item.Id)"
                                                        SelectedValueChanged="@OnSelectedReverseSwapWalletChanged"
                                                        DefaultItemText="Choose the wallet to fund/receive reverse swap amounts">
                                                <Feedback>
                                                    <ValidationError>A wallet for swaps operation must be selected as target/origin of funds</ValidationError>
                                                </Feedback>
                                            </SelectList>
                                        </Validation>
                                    }
                                    else
                                    {
                                        <Validation Validator="@ValidateBitcoinAddress">
                                            <FieldLabel>Address to use in REVERSE SWAPS operations</FieldLabel>
                                            <TextEdit Text="@((string)_currentLiquidityRule.ReverseSwapAddress)" TextChanged="(text) => _currentLiquidityRule.ReverseSwapAddress = text">
                                                <Feedback>
                                                    <ValidationError>A valid bitcoin address must be provided</ValidationError>
                                                </Feedback>
                                            </TextEdit>
                                        </Validation>
                                    }
                                </Field>
                            </Column>
                        </Row>
                        
                    </Validations>
                }
            </ModalBody>
            <ModalFooter>
                <Button Color="Color.Secondary" Clicked="@CloseChannelManagementModal">Cancel</Button>
                <Button Color="Color.Primary" Clicked="@SaveAndCloseChannelManagementModal">Save</Button>
            </ModalFooter>
        </ModalContent>
    }

</Modal>


@inject IChannelRepository ChannelRepository
@inject IToastService ToastService
@inject ClipboardService ClipboardService
@inject IMessageService MessageService
@inject ILightningService LightningService
@inject ILiquidityRuleRepository LiquidityRuleRepository
@inject IWalletRepository WalletRepository
@inject INodeRepository NodeRepository
@inject ILocalStorageService LocalStorageService
@inject IPriceConversionService PriceConversionService
@inject IAuditService AuditService

@code {
    private List<Channel>? _channels = new List<Channel>();
    private Channel? _selectedChannel;
    private bool _modalVisible;
    private bool _isUserNodeManager;
    private DataGrid<Channel>? _channelsDataGridRef;
    private Modal? _channelLiquidityModal;
    private List<Wallet> _availableWallets = new List<Wallet>();
    private LiquidityRule? _currentLiquidityRule = new LiquidityRule();
    private Validations? _channelManagementValidationsRef;
    
    // Server-side filter values
    private string? _statusFilterValue = "Open";
    private int? _sourceNodeIdFilterValue;
    private int? _destinationNodeIdFilterValue;
    private string? _channelIdFilterValue;
    private DateTimeOffset? _fromDateFilter;
    private DateTimeOffset? _toDateFilter;
    
    // Client-side availability filter
    private string? _availabilityFilterValue;

    private int _filtersResetKey;
    
    // Filter options
    private List<string> _statusOptions = new List<string> { "Open", "Closed" };
    private List<string> _availabilityOptions = new List<string> { "Active", "Inactive" };
    
    private List<Node> _nodes = new List<Node>();
    private int _totalItems;

    [CascadingParameter]
    private ApplicationUser? LoggedUser { get; set; }

    [CascadingParameter]
    private ClaimsPrincipal? ClaimsPrincipal { get; set; }

    private decimal _btcPrice;

    private ColumnLayout<ChannelsColumnName>? _channelsColumnLayout;
    private Dictionary<string, bool> _channelsColumns = new();
    private bool _columnsLoaded;
    // This dictionary is used to store the balance of each channel, key is the channel id, value is a tuple with the node id as local in the pair, local balance, remote balance
    private Dictionary<ulong, ChannelState> _channelsBalance = new();

    public abstract class ChannelsColumnName
    {
        public static readonly ColumnDefault SOURCE_NODE = new("Source Node");
        public static readonly ColumnDefault DESTINATION_NODE = new("Destination Node");
        public static readonly ColumnDefault STATUS = new("Status");
        public static readonly ColumnDefault OPENED_WITH = new("Opened With");
        public static readonly ColumnDefault OUTPOINT = new("Outpoint");
        public static readonly ColumnDefault CAPACITY = new("Capacity (BTC)");
        public static readonly ColumnDefault PRIVATE = new("Private");
        public static readonly ColumnDefault CLOSE_ADDRESS = new("Close Address");
        public static readonly ColumnDefault AVAILABILITY = new("Availability");
        public static readonly ColumnDefault CHANNEL_BALANCE = new("Channel Balance");
        public static readonly ColumnDefault CREATION_DATE = new("Creation Date");
        public static readonly ColumnDefault UPDATE_DATE = new("Update Date");
        public static readonly ColumnDefault CHANNEL_ID = new("Channel Id");
    }

    protected override async Task OnInitializedAsync()
    {
        _btcPrice = await PriceConversionService.GetBtcToUsdPrice();
        if (_btcPrice == 0)
        {
            ToastService.ShowError("Bitcoin price in USD could not be retrieved.");
        }
        if (LoggedUser != null)
        {
            _nodes = await NodeRepository.GetAll();
            _availableWallets = await WalletRepository.GetAvailableWallets(true);
            if (ClaimsPrincipal != null && ClaimsPrincipal.IsInRole(ApplicationUserRole.NodeManager.ToString()))
            {
                _isUserNodeManager = true;
            }
        }
        _channelsBalance = await LightningService.GetChannelsState();
    }

    private async Task OnReadData(DataGridReadDataEventArgs<Channel> e)
    {
        if (LoggedUser?.Id == null) return;

        var pageNumber = e.Page;
        var pageSize = e.PageSize;

        // Parse status filter
        int? statusFilter = null;
        if (!string.IsNullOrEmpty(_statusFilterValue))
        {
            statusFilter = _statusFilterValue == "Open" ? (int)Channel.ChannelStatus.Open : (int)Channel.ChannelStatus.Closed;
        }

        var fromDate = _fromDateFilter.HasValue
            ? new DateTimeOffset(DateTime.SpecifyKind(_fromDateFilter.Value.Date, DateTimeKind.Local)).ToUniversalTime()
            : (DateTimeOffset?)null;
        var toDate = _toDateFilter.HasValue
            ? new DateTimeOffset(DateTime.SpecifyKind(_toDateFilter.Value.Date.AddDays(1).AddTicks(-1), DateTimeKind.Local)).ToUniversalTime()
            : (DateTimeOffset?)null;

        var (channels, totalCount) = await ChannelRepository.GetPaginatedAsync(
            LoggedUser.Id,
            pageNumber,
            pageSize,
            statusFilter,
            _sourceNodeIdFilterValue,
            _destinationNodeIdFilterValue,
            _channelIdFilterValue,
            fromDate,
            toDate);

        // Apply client-side availability filter
        if (!string.IsNullOrEmpty(_availabilityFilterValue))
        {
            if (_availabilityFilterValue == "Active")
            {
                channels = channels.Where(c => GetAvailability(c.ChanId)).ToList();
            }
            else if (_availabilityFilterValue == "Inactive")
            {
                channels = channels.Where(c => !GetAvailability(c.ChanId)).ToList();
            }
        }

        _channels = channels;
        _totalItems = totalCount;
    }

    private async Task OnFiltersChanged()
    {
        await _channelsDataGridRef.Reload();
    }

    private async Task FetchData()
    {
        await _channelsDataGridRef.Reload();
    }

    private async Task ClearAllFilters()
    {
        _statusFilterValue = null;
        _sourceNodeIdFilterValue = null;
        _destinationNodeIdFilterValue = null;
        _channelIdFilterValue = null;
        _availabilityFilterValue = null;
        _fromDateFilter = null;
        _toDateFilter = null;
        _filtersResetKey++;
        await _channelsDataGridRef.Reload();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && !_columnsLoaded)
        {
            await LoadColumnLayout();
        }
    }

    private async Task LoadColumnLayout()
    {
        _channelsColumns = await LocalStorageService.LoadStorage(nameof(ChannelsColumnName), ColumnHelpers.GetColumnsDictionary<ChannelsColumnName>());
        _columnsLoaded = true;
        StateHasChanged();
    }

    private async Task ShowConfirmedClose(Channel? channel, bool forceClose = false)
    {
        await RefreshChannelInformation();
        var isChannelActive = GetAvailability(channel?.ChanId);
        var preMessage = "";
        if (forceClose && isChannelActive)
        {
            preMessage = "This channel is active!. ";
        }

        if (await MessageService.Confirm($"{preMessage}Are you sure you want to {(forceClose ? "force " : string.Empty)}close this channel?", "Confirmation"))
        {
            if (channel != null)
            {
                channel.DestinationNode = await NodeRepository.GetById(channel.DestinationNodeId) ?? throw new InvalidOperationException();
                channel.SourceNode = await NodeRepository.GetById(channel.SourceNodeId) ?? throw new InvalidOperationException();
                var result = await ChannelRepository.SafeRemove(channel, forceClose);

                var actionType = forceClose ? AuditActionType.ForceClose : AuditActionType.Close;
                if (!result.Item1)
                {
                    ToastService.ShowError("Something went wrong");
                    await AuditService.LogAsync(actionType, AuditEventType.Failure, AuditObjectType.Channel,
                        channel.Id.ToString(),
                        $"Failed to {(forceClose ? "force " : "")}close channel. ChanId: {channel.ChanId}");
                }
                else
                {
                    ToastService.ShowSuccess("Channel closed successfully");
                    await AuditService.LogAsync(actionType, AuditEventType.Success, AuditObjectType.Channel,
                        channel.Id.ToString(),
                        $"Channel {(forceClose ? "force " : "")}closed. ChanId: {channel.ChanId}");
                    await FetchData();
                }
            }
            else
            {
                ToastService.ShowError("Something went wrong. Please refresh the page");
            }
        }
    }

    private void ShowModal(Channel channel)
    {
        _modalVisible = true;
        _selectedChannel = channel;
    }

    private void HideModal()
    {
        _modalVisible = false;
        _selectedChannel = null;
    }

    private async Task CopyStrToClipboard(string arg)
    {
        await ClipboardService.WriteTextAsync(arg);
        ToastService.ShowSuccess("Text copied");
    }

    private int GetPercentageBalance(Channel channel)
    {
        try
        {
            var result = -1.0;
            if (_channelsBalance.TryGetValue(channel.ChanId, out var values))
            {
    // Calculate the capacity as the sum of the second and third values in the tuple
                var capacity = values.LocalBalance + values.RemoteBalance;

    // Calculate the result as the percentage of the remote balance to the capacity
                result = (values.RemoteBalance / (double) capacity) * 100;


                result = Math.Round(result, 2);
            }


            return Convert.ToInt32(result);
        }
        catch (Exception)
        {
            ToastService.ShowError($"Channel balance for channel id:{channel.Id} could not be retrieved");
            return -1;
        }
    }

    private bool GetAvailability(ulong? channelId)
    {
        if (channelId == null) return false;
        try
        {
            if (_channelsBalance.TryGetValue(channelId.Value, out var value))
            {
                return value.Active;
            }
        }
        catch (Exception)
        {
            ToastService.ShowError($"Channel availability for channel id:{channelId} could not be retrieved");
        }
        return false;
    }

    private async Task OnSelectedSwapWalletChanged(int arg)
    {
        if (_currentLiquidityRule != null) _currentLiquidityRule.SwapWalletId = arg;
    }
    
    private async Task OnSelectedReverseSwapWalletChanged(int arg)
    {
        if (_currentLiquidityRule != null) _currentLiquidityRule.ReverseSwapWalletId = arg;
    }

    private async Task CloseChannelManagementModal()
    {
        if (_channelLiquidityModal != null) await _channelLiquidityModal.Close(CloseReason.UserClosing);
        await ClearManagementModal();
        await FetchData();
    }

    private async Task SaveAndCloseChannelManagementModal()
    {
        if (_channelManagementValidationsRef != null && await _channelManagementValidationsRef.ValidateAll())
        {
    //Save the channel
            if (_selectedChannel != null)
            {
                var updateResult = ChannelRepository.Update(_selectedChannel);
                if (!updateResult.Item1)
                {
                    ToastService.ShowError("Something went wrong");
                    await AuditService.LogAsync(AuditActionType.Update, AuditEventType.Failure, AuditObjectType.Channel,
                        _selectedChannel.Id.ToString(),
                        $"Failed to update channel. ChanId: {_selectedChannel.ChanId}");
                }
                else
                {
                    ToastService.ShowSuccess("Channel updated successfully");
                    await AuditService.LogAsync(AuditActionType.Update, AuditEventType.Success, AuditObjectType.Channel,
                        _selectedChannel.Id.ToString(),
                        $"Channel updated. ChanId: {_selectedChannel.ChanId}");
                }
            }

    //Save the liquidity rule if the liquidity rule id is below or equal zero
            if (_currentLiquidityRule != null)
            {
                if (_currentLiquidityRule.Id <= 0)
                {
                    var liquidityRuleResult = await LiquidityRuleRepository.AddAsync(_currentLiquidityRule);
                    if (!liquidityRuleResult.Item1)
                    {
                        ToastService.ShowError("Something went wrong");
                        await AuditService.LogAsync(AuditActionType.Create, AuditEventType.Failure, AuditObjectType.LiquidityRule,
                            _currentLiquidityRule.ChannelId.ToString(),
                            $"Failed to add liquidity rule for channel. ChannelId: {_currentLiquidityRule.ChannelId}");
                    }
                    else
                    {
                        ToastService.ShowSuccess("Liquidity rule added successfully");
                        await AuditService.LogAsync(AuditActionType.Create, AuditEventType.Success, AuditObjectType.LiquidityRule,
                            _currentLiquidityRule.Id.ToString(),
                            $"Liquidity rule created. ChannelId: {_currentLiquidityRule.ChannelId}, MinLocal: {_currentLiquidityRule.MinimumLocalBalance}%, MinRemote: {_currentLiquidityRule.MinimumRemoteBalance}%, Target: {_currentLiquidityRule.RebalanceTarget}%");
                    }
                }
                else
                {
                    var liquidityRuleResult = LiquidityRuleRepository.Update(_currentLiquidityRule);
                    if (!liquidityRuleResult.Item1)
                    {
                        ToastService.ShowError("Something went wrong");
                        await AuditService.LogAsync(AuditActionType.Update, AuditEventType.Failure, AuditObjectType.LiquidityRule,
                            _currentLiquidityRule.Id.ToString(),
                            $"Failed to update liquidity rule. RuleId: {_currentLiquidityRule.Id}");
                    }
                    else
                    {
                        ToastService.ShowSuccess("Liquidity rule updated successfully");
                        await AuditService.LogAsync(AuditActionType.Update, AuditEventType.Success, AuditObjectType.LiquidityRule,
                            _currentLiquidityRule.Id.ToString(),
                            $"Liquidity rule updated. ChannelId: {_currentLiquidityRule.ChannelId}, MinLocal: {_currentLiquidityRule.MinimumLocalBalance}%, MinRemote: {_currentLiquidityRule.MinimumRemoteBalance}%, Target: {_currentLiquidityRule.RebalanceTarget}%");
                    }
                }
            }

            await CloseChannelManagementModal();
        }
        else
        {
            ToastService.ShowError("Please fix the errors");
        }
    }

    private async Task ClearManagementModal()
    {
        _selectedChannel = null;
        _currentLiquidityRule = new LiquidityRule();
    }

    private async Task ShowChannelManagementModal(Channel channel)
    {
        await ClearManagementModal();

        _selectedChannel = channel;

        var destinationNode = channel.DestinationNode;
        var sourceNode = channel.SourceNode;
        var node = string.IsNullOrEmpty(sourceNode.ChannelAdminMacaroon) ? destinationNode : sourceNode;

    //If there is a liquidity rule for this channel, we load it, the first one
        _currentLiquidityRule = _selectedChannel?.LiquidityRules.FirstOrDefault() ?? new LiquidityRule
        {
            MinimumLocalBalance = 20,
            MinimumRemoteBalance = 80,
            RebalanceTarget = 50,
            ChannelId = channel.Id,
            NodeId = node.Id
        };

        if (_channelLiquidityModal != null) await _channelLiquidityModal.Show();
    }

    private async Task OnEnableLiquidityMngmtChanged(bool enabledLiquidityMngmt)
    {
        if (_selectedChannel != null)
        {
            _selectedChannel.IsAutomatedLiquidityEnabled = enabledLiquidityMngmt;

            if (!enabledLiquidityMngmt)
            {
                _currentLiquidityRule = null;
            }
            else
            {
                var node = string.IsNullOrEmpty(_selectedChannel.SourceNode.ChannelAdminMacaroon) ? _selectedChannel.DestinationNode : _selectedChannel.SourceNode;
                _currentLiquidityRule = _selectedChannel.LiquidityRules.FirstOrDefault() ?? new LiquidityRule
                {
                    MinimumLocalBalance = 20,
                    MinimumRemoteBalance = 80,
                    RebalanceTarget = 50,
                    ChannelId = _selectedChannel.Id,
                    NodeId = node.Id
                };
            }

            var updateResult = ChannelRepository.Update(_selectedChannel);
            var actionType = enabledLiquidityMngmt ? AuditActionType.EnableLiquidityManagement : AuditActionType.DisableLiquidityManagement;

            if (!updateResult.Item1)
            {
                ToastService.ShowError("Something went wrong");
                await AuditService.LogAsync(actionType, AuditEventType.Failure, AuditObjectType.Channel,
                    _selectedChannel.Id.ToString(),
                    $"Failed to {(enabledLiquidityMngmt ? "enable" : "disable")} liquidity management. ChanId: {_selectedChannel.ChanId}");
            }
            else
            {
                ToastService.ShowSuccess("Channel updated successfully");
                await AuditService.LogAsync(actionType, AuditEventType.Success, AuditObjectType.Channel,
                    _selectedChannel.Id.ToString(),
                    $"Liquidity management {(enabledLiquidityMngmt ? "enabled" : "disabled")}. ChanId: {_selectedChannel.ChanId}");
            }
        }
    }

    private void ValidateTargetBalance(ValidatorEventArgs arg1)
    {
        if(_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;

    //If the value is 0 is valid
        if (_currentLiquidityRule.RebalanceTarget == 0 || _currentLiquidityRule.RebalanceTarget == null)
        {
            return;
        }
    //Check that the target balance is between 0 and 100
        if (_currentLiquidityRule.RebalanceTarget < 0 || _currentLiquidityRule.RebalanceTarget > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Target balance must be between 0 and 100";
        }


    //Check that the rebalancetarget of the current liquidity rule is between the mininum local and minimum remote balance
        if (_currentLiquidityRule.RebalanceTarget < _currentLiquidityRule.MinimumLocalBalance ||
            _currentLiquidityRule.RebalanceTarget > _currentLiquidityRule.MinimumRemoteBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Rebalance target must be between the minimum local and minimum remote balance";
        }
    }

    private void ValidateRemoteBalance(ValidatorEventArgs arg1)
    {
        if(_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;

    //If the minimum local balance is 0 this cannot be 0
        if ((_currentLiquidityRule.MinimumLocalBalance == 0 || _currentLiquidityRule.MinimumLocalBalance == null)
            && (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance cannot be 0 if the minimum local balance is 0";
        }

    //If the value is 0 is valid
        if (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null)
        {
            return;
        }


    //Check that the minimum remote balance is between 0 and 100
        if (_currentLiquidityRule.MinimumRemoteBalance < 0 || _currentLiquidityRule.MinimumRemoteBalance > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance must be between 0 and 100";
        }


    //Check that the Minimum remote balance must be greater than the minimum local balance
        if (_currentLiquidityRule.MinimumRemoteBalance <= _currentLiquidityRule.MinimumLocalBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum remote balance must be greater than the minimum local balance";
        }
    }

    private void ValidateLocalBalance(ValidatorEventArgs arg1)
    {
        if (_currentLiquidityRule == null) return;
    //Default validation status
        arg1.Status = ValidationStatus.Success;
    //If the minimum remote balance is 0 this cannot be 0
        if ((_currentLiquidityRule.MinimumLocalBalance == 0 || _currentLiquidityRule.MinimumLocalBalance == null)
            && (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null))
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance cannot be 0 if the minimum remote balance is 0";
        }

    //If the value is 0 is valid
        if (_currentLiquidityRule.MinimumRemoteBalance == 0 || _currentLiquidityRule.MinimumRemoteBalance == null)
        {
            return;
        }


    //Check that the balance is between 0 and 100

        if (_currentLiquidityRule.MinimumLocalBalance < 0 || _currentLiquidityRule.MinimumLocalBalance > 100)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance must be between 0 and 100";
        }

    //Check that the Minimum local balance must be less than the minimum remote balance
        if (_currentLiquidityRule.MinimumLocalBalance >= _currentLiquidityRule.MinimumRemoteBalance)
        {
            arg1.Status = ValidationStatus.Error;
            arg1.ErrorText = "Minimum local balance must be less than the minimum remote balance";
        }
    }


    private async Task MarkAsClosed(Channel contextItem)
    {
        var result = await ChannelRepository.MarkAsClosed(contextItem);

        if (result.Item1)
        {
            ToastService.ShowSuccess("Channel marked as closed");
            await AuditService.LogAsync(AuditActionType.MarkAsClosed, AuditEventType.Success, AuditObjectType.Channel,
                contextItem.Id.ToString(),
                $"Channel marked as closed. ChanId: {contextItem.ChanId}");
        }
        else
        {
            ToastService.ShowError("Something went wrong: " + result.Item2);
            await AuditService.LogAsync(AuditActionType.MarkAsClosed, AuditEventType.Failure, AuditObjectType.Channel,
                contextItem.Id.ToString(),
                $"Failed to mark channel as closed. ChanId: {contextItem.ChanId}. Error: {result.Item2}");
        }

        await FetchData();
    }

    private bool CheckDisableCloseChannelButton(Channel channel)
    {
        var lastRequest = channel.ChannelOperationRequests.LastOrDefault();

        // If the channel is not created by the node guard, we dont disable the button
        if (lastRequest == null || channel.CreatedByNodeGuard == false) return false;

        // If the channel is created by the node guard, we disable the button if the channel is closed or if the last request is a close request and is confirmed or is pending confirmation
        return channel.Status == Channel.ChannelStatus.Closed || (lastRequest.RequestType == OperationRequestType.Close
                                                                  && lastRequest.Status == ChannelOperationRequestStatus.OnChainConfirmed
                                                                  || lastRequest.Status == ChannelOperationRequestStatus.OnChainConfirmationPending);
    }

    private void OnColumnLayoutUpdate()
    {
        StateHasChanged();
    }

    private bool IsColumnVisible(ColumnDefault column)
    {
        if (_channelsColumnLayout == null)
        {
            return true;
        }
        return _channelsColumnLayout.IsColumnVisible(column);
    }

    private async Task RefreshChannelInformation()
    {
        await FetchData();
        _channelsBalance = await LightningService.GetChannelsState();
        StateHasChanged();
    }

    private string GetBalanceTooltipInformation(Channel channel)
    {
        var sourcePubKey = StringHelper.TruncateHeadAndTail(channel.SourceNode.PubKey, 5);
        var destinationPubKey = StringHelper.TruncateHeadAndTail(channel.DestinationNode.PubKey, 5);
        var source = string.IsNullOrWhiteSpace(channel.SourceNode.Name) ? sourcePubKey : channel.SourceNode.Name;
        var destination = string.IsNullOrWhiteSpace(channel.DestinationNode.Name) ? destinationPubKey : channel.DestinationNode.Name;
        if (!channel.SourceNode.IsManaged)
        {
            return $"{destination}  - {source}";
        }
        return $"{source}  - {destination}";
    }
    
    private void ValidateBitcoinAddress(ValidatorEventArgs obj)
    {
        var str = obj.Value as string;

        obj.Status = ValidationStatus.Success;

        try
        {
            BitcoinAddress.Create(str!, CurrentNetworkHelper.GetCurrentNetwork());
        }
        catch (Exception)
        {
            obj.ErrorText = "Invalid bitcoin address";
            obj.Status = ValidationStatus.Error;

        }
    }
}